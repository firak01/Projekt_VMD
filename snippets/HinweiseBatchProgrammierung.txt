REM ###################################################################
REM Allgemeine Hinweise für die Batch Programmierung
REM zum Kommentieren
     REM Normale Kommentar mit REM
	 REM Schneller zu tippen sind aber zwei Doppelpunkte am Anfang ::
	
REM zur Schleife:
	REM Die Variable darf nur aus einem Buchstaben bestehen! "%t" ist erlaubt, "%test" nicht! Bei der Verwendung mehrerer Befehle muss zwischen "DO" und der Klammer "(" ein Leerzeichen sein.
	REM so würde eine Schleife rückwärts gezählt for /l %%x in (10,-1,1) do (
	REM was bedeuted das /l. Es muss etwas listenmäßiges sein und ist wichtig?.... 
		REM Lösung: Mit solchen Schleifen kann man Aktionen eine bestimmte Anzahl oft ausführen. Dazu muss man den Parameter /L angeben.
		REM Beispiel wenn in :timRight staende: for %%x in (2,1,341) do ( würde wegen fehlendem /l nur einmal ausgeführt
	
REM Zum if - Befehl
	REM Der Parameter /i unterbindet eine Differenzierung der Groß-/Kleinbuchstaben.
	REM Bei der Verwendung mehrerer Befehle muss zwischen Bedingung und der Klammer "(" ein Leerzeichen sein.
	
REM Zum set - Befehl, d.h. zu Variablen:
	REM Der Parameter /a 
		REM wird dazu verwendet Rechenoperationen durchzuführen
		
	REM zum Ausrufezeichen z.B. !theVariable!
		REM Definiert eine Variable, zur Verzögerten Berechenung, d.h. erst zur Laufzeit berechnen. Siehe SETLOCAL ENABLEDELAYEDEXPANSION.
	    REM Zur verzögerten Übersetzung von Variablen. Bewirkt, dass die Variable nicht zur Kompilierzeit sondern erst zur Laufzeit übersetzt wird (setzt die Verwendung von SETLOCAL zur Aktivierung von verzögerter Übersetzung voraus)	

	REM Dagegen wird mit % 
		REM eine Variable wohl schon beim kompilieren berechnet.
		
	REM TIP: SET in Anführungszeichen
		REM Setze die Wertzuweisung hinter dem SET in Anführungszeichen, damit soll verhindert werden, dass unbeabsichtigte Leerzeichen am Ende der Zeiel in den Wert rutschen.
		REM Das ist bei mathematischen SET Rechenoperationen nicht notwendig
	
REM Zum Goto:EOF Befehl
	REM Das entspricht einem Return in einer normalen Script-/Programmiersprache.

REM Funktionen zur Stringverarbeitung: http://www.dostips.com/DtTipsStringOperations.php	
REM Einige Grundlagenexperimente zur Stringverarbeitung, die funktionieren
	REM set myStr="a b c d ef "		
	REM echo.myStr am Anfang="%myStr%"
	REM echo.mit Tilde -3 ist ... der drittletzte Buchstabe von date "%date:~-3,1%"
	REM echo.mit Tilde -3 sind ... die beiden (Achtung Logik) drittletzten Buchstabe von date "%date:~-3,2%"
	
	REM echo.mystring mit Tilde 0 ist alles !myStr:~0!
	REM echo.mystring mit Tilde -2,1 ist ... der letzte Buchstabe "!myStr:~-2,1!"
	REM echo.mystring mit Tilde -3,1 ist ... der vorletzte Buchstabe "!myStr:~-3,1!"
	REM echo.mystring mit Tilde -3,2 ist ... der vorletzte und letzte Buchstabe "!myStr:~-3,2!"
	

REM PROBLEM: In einer Schleife dynamisch eine Variable einfügen. Wie ich diese Formel entwickelt habe: call set "myStrReduced=%%myStr:~-32,!itemp!%%"
REM https://www.administrator.de/wissen/arbeite-batch-umgebungsvariablen-erstellung-umgang-erweiterungen-ver%C3%A4nderungen-117069.html			
			
			REM Wie rechnet man das zur Laufzeit aus... set myStrReduced="!myStr!:~-12,!itemp!"
			REM Nicht funktionierendes:
			REM set myStrReduced=!myStr!:~-12,!itemp!
			REM set myStrReduced=!myStr:~-12,itemp!
			REM set myStrReduced=!%myStr%:~-12,%itemp%!
			REM set myStrReduced=!!myStr!:~-12,!itemp!!
			REM funktioniert echo.andere Syntax %myStr:~-12,4%
			REM funktioniert aber nicht nicht echo.kombinations-syntax %myStr:~-12,!itemp!%
			
			REM nein set myStrReduced=%!myStr!:~-12,!itemp!%
			REM nein call set myStrReduced=%%!myStr!:~-12,9%			
			REM Loesung   call set "myStrReduced=%%myStr:~-32,!itemp!%%"
			REM echo.reduzierter String "!myStrReduced!"
							

	REM Beispiele, die bei der Lösungsfindung geholfen haben:
			REM funktionierendes Beispiel01:
			REM setlocal enabledelayedexpansion
			REM set string=This is my string to work with.
			REM echo.anderesBeispiel !string!
			REM set find=my string
			REM set replace=your replacement
			REM call set string=%%string:!find!=!replace!%%
			REM echo.anderesBeispiel !string!
						
			REM funktionierendes Beispiel02:
			REM setlocal enabledelayedexpansion
			REM set string=This is my string to work with.
			REM call set string=%%string:to work with.=%%
			REM echo.anderesBeispiel02 !string!

REM CALL
REM Wenn ein Leerzeichen in dem Übergabestring ist, wir das als Trenner der an die Funktion übergebenen Argumente angesehen
	REM Funktionierendes Beispiel:
	REM set myTime=Das ist toll
	REM set myTime=%myTime: =_%
	REM call :StringLeftInclude !myTime! _
	REM set "myTime=!returnStringLeftInclude!"
	REM echo myTime links=!myTime!
