<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">
   <!-- damit definiert man für antcontrib einen eigenen Namespace -->
   <!-- damit definiert man für FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
    <!-- ######## Scriptdefs ############################################################################--> 		
	<!-- ########################### -->	
	<!-- ############################################################-->
	<scriptdef name="arrayAppendJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="valueinput" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("valueinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert: '" + objectArray[x]+ "'");
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				}
			}
						
			//3. Erweitere das Array
			icountGlobal++;
			//print("Wert anhängen an position " + icountGlobal + ": '" + myValue + "'");
			
			//TODO An dieser Stelle bei der Erweiterung arrays anzuhängen: Prüfen, ob das ein Einzelwert oder ein Array ist.
			myArrayReturn[icountGlobal]=myValue;
																						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayCopyJsZZZ" language="javascript">
		<!-- Hiermit man ein Array in eine anderes neues Array.
             Beispielsweise sinnvoll, wenn von einer Funktion ein neues Array zurückgegeben wird,
             man aber noch mit dem alten 'Variablennamen' weiterarbeiten möchte.			 -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			
			//Kopiervorgang, noch ohne irgendwelche FlagControl Erweiterungen.			
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
				myArrayReturn[icount]=objectArray[x];
			};
															
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="arrayDebugJsZZZ" language="javascript">
		<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
			   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
			   - der Inhalt
			   - die Größe des Arrays			-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="arrayinput" />
		<attribute name="ilevel" />	
		<![CDATA[										 								
			var myArray = attributes.get("arrayinput");					
			var myLevel = attributes.get("ilevel");					
			if(myLevel<=0){
				
			}else{
			
			<!-- Typausgabe -->
			print("typeof myarray = " + typeof(myArray));
					
			
			var iSize=0;
			if(Array.isArray(myArray)){
				print("Array uebergeben bekommen");
				iSize = myArray.length;
				print("Arraygroesse="+iSize);
				
				//TODO: Die gleichen Ausgaben wie im KEIN ARRAY Fall.
				//- Werte
			}else{
				print("kein Array uebergeben bekommen.");
				
				var icount=0;					
				if(typeof(myArray)=="object"){
					print("Object uebergeben bekommen.");
					
					if(myLevel>=2){
					//das listet alle Methoden des objekts auf.... scheint ein String zu sein....
					//print("ALLE METHODEN DES OBJEKTS:");
					//for(x in myArray){
					//	print(x);		
					//};	
					
					print("#################################");
					print("ALLE METHODEN UND CODEINHALT DES OBJEKTS:");
					for(xx in myArray){
						print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
						print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
					};
					};//myLevel>=2;
					
					print("#################################");
					print("myArray ist jetzt leider ein String ='"+ myArray +"'");
					//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
					
					print("splitte diesen String nach Komma.");
					var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
					for(x in objectArray){
						print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					};
					
					//var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
					//for(x2 in objectArray02){
					//	print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
					//};
					
					//var objectArrayString = myArray.toString();
					//var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
					//for(z in objectArray03){
					//	print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					//};
					
					print("#################################");
					print("Versuch die Werte auszugeben: ");	
					//Merke: Voraussetzung ist:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 for(yy in objectArray){
							print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
						};
					}else{
						//print("kein Objekt");
					};
			};
			};//myLevel <= 0;
		]]>
	</scriptdef>
	
	 <!-- ########################### -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="ireturn" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iReturn = -1;
										
			//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
			var icount=0;
			var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
			if(typeof(objectArray)=="object"){
			for(x in objectArray){
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				}else{
					icount++;
				};				
			}							
			}else{
				iReturn=0;
			}
			
			iReturn = icount;
			
			project.setProperty(attributes.get("ireturn"), iReturn);
		]]>
	</scriptdef>
	
	<!-- ########################### -->	
	<scriptdef name="arrayGetJsZZZ" language="javascript">
		<!-- Hiermit holt man den Wert an einer Indexposition (beginnend mit 0)
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="index" />
		<attribute name="arrayget" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iIndex = attributes.get("index");
			var objReturn="<#!!FGLUNDEFINED!!#>";
			main:{
				if(iIndex <= -1) break main;
				
				//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
				var icount=-1;
				var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				if(typeof(objectArray)=="object"){
				for(x in objectArray){
					//print("x="+x);
					//print("objectArray[x]="+objectArray[x]);
					
					//Undefinierte, d.h. nur initialisierte Arrays abfangen
					//Sie haben die Groesse 0 und an erster Stelle das <#!!FGLUNDEFINED!!#>
					if(objectArray.length<=1 && objectArray[x]=="<#!!FGLUNDEFINED!!#>"){						
						break main;
					}else{
						icount++;
						if(icount==iIndex){
							objReturn = objectArray[x];
							break main;
						}				
					}; //end if
					}; //end for
				}; //end if(typeof(objectArray)=="object")				
			}; //end main:
			project.setProperty(attributes.get("arrayget"), objReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->		
	<scriptdef name="arrayInitJsZZZ" language="javascript">
		<!-- Hiermit faked man die Erstellung eines Arrays.
			 Da scheinbar kein "call by reference" gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="isize" />
		<attribute name="arrayreturn" />		
		<![CDATA[										 
			var mySize = attributes.get("isize");	
			//print("iSize = '" + mySize + "'");
			
			//Prüfen, ob mySize eine Zahl ist. 
			//Merke: Ist z.B. die Flaka - Variable nicht oder leer deklariert, kommt hier der Variablenname '${irgendwas}' an.
			//           Das bewirkt, dass dieses '${irgendwas}' als erstes Element in´s Array kommt und das Array sofort die Größe 1 hat, was in dem Fall nicht beabsichtigt ist.
			if(isNumber(mySize)){
				//print("eine Zahl");
				var myArrayReturn = new Array(); //Merke: Egal was man hier als Groesse angiebt [irgendwas] wird als Wert übernommen genauso wie leiglich: irgendwas
				
				if(mySize==0){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
				}
				if(mySize>=1){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					for(icount=0; icount<=mySize-1; icount++){
						myArrayReturn[icount]="<#!!FGLEMPTY!!#>";
					}												
				}								
			}else{
				//print("KEINE Zahl");
				var myArrayReturn = new Array();

				//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
				myArrayReturn="<#!!FGLUNDEFINED!!#>";
			}
						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
		]]>
	</scriptdef>
	
	
	<!-- ######## Scriptdefs ############################################################################--> 		
 	<!-- ########################### -->		
	<scriptdef name="isBooleanZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie boolean interpretiert werden kann. -->
		<!-- Es werden Ausdrücke wie null, eins nicht in boolean umgesetzt.
		
		    In boolean umgesetzt werden:
			- Strings 0, 1 
			- Strings true, false
			
			TODO: 
			- Zahlen 0, 1
		-->
			
			
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isboolean" />
		<![CDATA[		   		  
		   var bBooleanValue = null;
		   var bIsBoolean = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   print("myValueInput='"+myValueInput+"'");		   			
			if(isNumber(myValueInput)){
				print("boolean liegt als Zahl vor.");	
				if (myValueInput=='1') {			   
					bBooleanValue = true;
					bIsBoolean = true;
				}else if(myValueInput=='0'){
					bBooleanValue = false;
					bIsBoolean = true;
				}else{
					bBooleanValue = null;
					bIsBoolean = false;
				};
			}else{			
				print("boolean liegt als String vor.");	
				if (myValueInput=='true') {			   
				   bBooleanValue = true;
				   bIsBoolean = true;
				}else if(myValueInput=='false') {
					bBooleanValue = false;
					bIsBoolean = true;				
				}else{					
					bIsBoolean = false;
				};			
			}
						
			project.setProperty(attributes.get("valuereturn"), bBooleanValue);
			project.setProperty(attributes.get("isboolean"), bIsBoolean);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			//TODO: Diese Funktion in JSZ-Kernel Bibliotheken packen. 
			//TODO: In einer entsprechenden Scriptdef Funktion nutzen.
			function convertBoolToInt()
			{
				var testBool = true;
				result = (testBool)?1:0;
				alert(result);
			}
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->		
	<scriptdef name="isDirectoryZZZ" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist Package notwendig
		   importClass(java.io.File);                               //Bei BasisJava darf Package nicht vorneweg stehen.
		   var text = attributes.get("text");		 
		   //var fd = new java.io.File(text);
		   var fd = new File(text);
		   var berg = false;
		   if (fd.isDirectory()) {
			   //print("js true");
		       berg = true;
			} else {
				//print("js false");
				berg = false;
			}
			project.setProperty(attributes.get("property"), berg);
		 ]]>
	</scriptdef>
	
	 <!-- ########################### -->
	 <scriptdef name="stringLeftString" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
      print("matchstring="+match);
	   //! FEHLER BEI EINEM BEGINNENDEN BACKSLASH
	   
	   
       sReturn = getStrLeftStr(text, match);
	   print("sReturn="+sReturn);
	   
       project.setProperty(attributes.get("returnstring"), sReturn);
	   
	   //aus JSZ - Kernel 
	   function getStrLeftStr(sourceStr, keyStr){
		return (sourceStr.indexOf(keyStr) == -1 | keyStr=='') ? '' : sourceStr.split(keyStr)[0];
		}
     ]]>
  </scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="substringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		 ]]>
	</scriptdef>

	   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="-declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
  	
	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
  	
  
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur -->
 <property name="dest.dirRepositoryVmdLib" value="lib" />
  <property name="dest.dirRepositoryVmdBat" value="bat" />
  <property name="dest.dirRepositoryVmdSrc" value="src" />
  <property name="dest.dirRepositoryVmdMisc" value="misc" />
  <property name="dest.dirRepositoryVmdTest" value="test" />
  <property name="dest.dirRepositoryVmdArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  <loadproperties>
  	<file file="${vmd}"/>
  	<!--<file file="${env.VMD}"/>-->
  </loadproperties> 
  <echo>test1 hat den Wert: ${test1}</echo>  	 
  <echo>conf.dirRepositoryVmdPath hat den Wert: ${conf.dirRepositoryVmdPath}</echo>
  <property name="dest.dirRepositoryVmdPath" value="c:/1fgl/repository/Projekt_VMD" />  
 
  <!-- TODO GOON: Prüfe die Controldateien auf Existenz und Validität. Setze bGOON Variablen, die dann in den Targets abgeprüft werden. -->
  	
  	
  <!-- ######### CLIENT ############################################################################## -->
  <!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
  <!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
  <!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
  <property name="src.dirFglClient" value="client" /> 
  <property name="src.dirFglPath" value="C:/1fgl"/>
  <property name="src.dirFglClientPath" value="${src.dirFglPath}/${src.dirFglClient}" /> 

  <!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
  	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}" />
    <property name="src.dirFglClientFileName" value = "Fgl${env.COMPUTERNAME}_Installationen.txt"/><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>src.dirFglClientFilePath ::= '${src.dirFglClientFilePath}/${src.dirFglClientFileName}'</fl:let>
	<echo>Wert von src.dirFglClientFilePath=${src.dirFglClientFilePath}</echo>
	</target>
  
  <!-- ################################################################################# -->
  <!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
   <target name="compile" depends="-declaration, -init,-FglRepositoryBackup,-FglCopyClient2archive,-FglCopyLocal_Main">
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  
  <target name="-init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
       
<target name="-FglRepositoryBackup">
	<!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
	<property name ="dest.dirRepositoryVmdBackupPath" value="${dest.dirRepositoryVmdPath}Backups" />
  
	<echo>Creating Backup:</echo>
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade -->
	<mkdir dir="//${dest.dirRepositoryVmdPath}"/>
	<mkdir dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" />
	<mkdir dir="//${dest.dirRepositoryVmdBackupPath}"/>

	<echo>a) VmdRepository Archive:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind. -->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}"
	/>
</target>
	
	
<target name="-FglCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing Files to Repository:</echo>
	<echo>a) VMD File:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
	     <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${src.dirFglClientFileName}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
		 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- Beispiel für ein antcallback, in dem aus einer Schleife ein Wert zurückgeliefert wird. -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="-FglCopyLocal_Main">
	<echo>######################################</echo>
	
	<!-- Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	
	<!-- 1. Rechne den Dateinamen aus -->
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	
	 <!-- Todo: Eigentlich müssen oben erst die conf - Parameter definiert werden und daraus werden dann die dest/src Parameter ggfs. geholt -->
	<property name="conf.dirRepositoryVmdPath" value="${dest.dirRepositoryVmdPath}" /> 
	<property name="conf.dirRepositoryVmdBat" value="${dest.dirRepositoryVmdBat}" />
	
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />

	<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
    <property name="conf.copyLocalFileName" value = "Fgl${env.COMPUTERNAME}_copy_local.properties"/>
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryVmdPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
	<echo>Copy files general, by property file:</echo>
	<echo>${conf.copyLocalFilePath}</echo>
	
	<!-- 2a. Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<fl:when test=" '${conf.copyLocalFilePath}'.tofile.exists == true ">
			<echo>Datei existiert: ${conf.copyLocalFilePath}</echo>

			<!-- 2. Lies den Inhalt der Datei als Properties-Datei ein. -->	
			<!--<loadproperties>
				<file file="${conf.copyGeneralFilePath}"/>
			</loadproperties> 
			<echo>test1 hat den Wert: ${test1}</echo> -->
			
			
			<!-- 2a. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
			
			<!-- Test: Gib den Inhalt der Datei aus -->
			<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
			<!-- <echo>${myfile}</echo> -->
	
	
			<!--2b. Werte den Inhalt der Datei zeilenweise aus -->			
			<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
			<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
				<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
					<file file="${conf.copyLocalFilePath}" />
				</tokens>
				<sequential>
					<fl:let>myCase ::= "neue Zeile"</fl:let><!-- für jede Zeile wird der mögliche Verarbeitungsfall neu ermittelt -->
					<var name="line.length" unset="true" />
					<length string="@{line}" property="line.length" />
					<ac:if>
						<ac:equals arg1="${line.length}" arg2="0" />
						<ac:then>
							<!-- <fl:echo>Leerzeile...</fl:echo> -->
						</ac:then>
						<ac:else>													
							<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->							
							<substringZZZ text="@{line}" start="0" end="1" property="subtext" /><!-- anwenden der oben definierten scriptdef funktion substring -->
							<!-- <fl:echo message="subtext = ${subtext}" />	 -->						
							<ac:if>
								<ac:equals arg1="${subtext}" arg2="#" />
								<ac:then>
									<!-- <fl:echo>Kommentarzeile, wird uebersprungen...</fl:echo> -->
								</ac:then>
								<ac:else>
									<fl:echo>Zeile: @{line}</fl:echo>
									<!-- <echo>Steuerungszeile, wird ausgewertet...</echo> -->
									
									<!-- 2c. Splitte die Zeile mit Flaka - Splitt funktion (steht in der Flaka Doku unter EL). -->							 				 							
									<!-- <fl:echo>linker Teil der Zeile => #{split('@{line}','=')[0]}</fl:echo> --><!-- beachte, dass mit dem #{ ... } die Funktion aufgerufen wird, so dass ihr Ergebnis in den String eingefügt werden kann.-->
									<!-- <fl:echo>rechter Teil der Zeile => #{split('@{line}','=')[1]}</fl:echo> -->
	
									<!-- Schreibe das in eine Flaka - Variable -->		
									<fl:let>myLeftPart ::= split('@{line}','=')[0]</fl:let>		
									<fl:let>myRightPart ::= split('@{line}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
									<fl:echo>Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
									<fl:echo>Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
														 							
									<!-- TODO: Idee: in der initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
									<fl:when test="null('${myRightPart}')">
										<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): @{line}</echo>
										<fl:fail message="Rechter Teil der Steuerungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
										<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
										<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
											 <fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										     <fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>
									<fl:when test="null('${myLeftPart}')">
										<echo>Linker Teil der Steuerungsanweisung existiert nicht (von...): @{line}</echo>
										<fl:fail message="Linker Teil der Steuerungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
										<!-- Merke: Das wäre beim Kopieren einer Datei von einem feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
										<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
											 <fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										     <fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>

									<!-- ### Ermittle hier den Fall. Schreibe den Wert in diese Variable und fülle damit ein Array -->
									<fl:let>myCase ::= "undefined"</fl:let>																										
									<antcallback target="-FGLCopyLocal_Analyze" return="returnAnalyse, returnString">
										<param name="leftPart" value="${myLeftPart}"/>
										<param name="rightPart" value="${myRightPart}"/>
									</antcallback>
											
									<fl:echo>Ergebnis der Analyse: ${returnString}</fl:echo>
									<fl:let>myAnalyze ::= "${returnString}"</fl:let>
									
                                    <!--### Aufruf des Controllers der verschiedenen Fälle ####################-->									
									<antcallback target="-FGLCopyLocal_Control" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
												<param name="analyze" value="${myAnalyze}"/>
												<param name="leftPart" value="${myLeftPart}"/>
												<param name="rightPart" value="${myRightPart}"/>												
									</antcallback>
									<fl:let>mySrca.filedir ::= "${returnSrca.filedir}"</fl:let>
									<fl:let>mySrca.filename ::= "${returnSrca.filename}"</fl:let>
									<fl:let>myDesta.filedir ::= "${returnDesta.filedir}"</fl:let>
									<fl:let>myDesta.filename ::= "${returnDesta.filename}"</fl:let>
									
									
									<!-- TODO GOON 20150719: Hänge die zurückgelieferten Arrays an die schon existierenden an -->																	
									<!-- myStringaLeftTotal
									     myStringaRightTotal
									-->
						</ac:else>
					</ac:if>
					</ac:else>
					</ac:if>
				</sequential>
			</for>			
			
			<!-- ### NOCH TESTPHASe Hier erst einmal das Kopieren der Arrayinhalte testen -->	
			<fl:logo>TEST ARRAYBEHANDLUNG UND KOPIEREN</fl:logo>
			<fl:let>myArraySize ::= 0</fl:let>
					
			<!-- <fl:let>mySrc.filedir ::= "C:\VMWare\FGLXPHannibalVideoPlay3_768MB "</fl:let> -->	
<!-- 			<fl:let>mySrc.filedir ::= "C:\1fgl\repository\Projekt_VMD\testused"</fl:let>			
			<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
			<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySrc.filedir}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />			
			<fl:let>mySrca.filedir::="${myArray}"</fl:let> -->
			<arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->
			
			<!-- <fl:let>mySrc.filename ::= "FGLXPHannibalVideoPlay1VM.txt "</fl:let> -->
<!-- 			<fl:let>mySrc.filename ::= "file_copyBeispiel00.txt"</fl:let>
			<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
			<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySrc.filename}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
			<fl:let>mySrca.filename ::="${myArray}"</fl:let>					 -->
			<arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			
			<!-- <fl:let>myDest.filedir ::= "C:\1fgl\repository\Projekt_VMD\vmd "</fl:let> -->
<!-- 			<fl:let>myDest.filedir ::= "C:\temp"</fl:let>			
			<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
			<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${myDest.filedir}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
			<fl:let>myDesta.filedir ::="${myArray}"</fl:let> -->
			<arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			
			
			<!-- <fl:let>myDest.filename ::= "FGLXPHannibalVideoPlay1VM.txt"</fl:let> -->
<!-- 			<fl:let>myDest.filename ::= "file_copyBeispiel00.txt"</fl:let>
			<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
			<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${myDest.filename}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
			<fl:let>myDesta.filename ::="${myArray}"</fl:let> -->
			<arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			

			<!--### Kopiere die Dateien der beiden Arrays #####################-->
			<antcallback target="-FGLCopyLocal_CopyFileByFile" return="returnCopy">					
					<param name="srca.filename" value="${mySrca.filename}"/>
					<param name="srca.filedir" value="${mySrca.filedir}"/>
					<param name="desta.filedir" value="${myDesta.filedir}"/>
					<param name="desta.filename" value="${myDesta.filename}"/>					
			</antcallback>
		</fl:when>
		<fl:otherwise>
				<echo>Konfigurations-Datei existiert NICHT: ${conf.copyLocalFilePath}</echo>
				<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</fl:otherwise>
	</fl:choose>

</target>


<!-- ######################################################################### -->
<target name = "-FGLCopyLocal_CopyFileByFile">
	<fl:let>mySrca.filedir ::= "${srca.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${srca.filename}"</fl:let>
	<fl:let>myDesta.filedir ::= "${desta.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${desta.filename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	
			
	
	<!-- Prüfen: Alle Arrays sollen gleich lang sein.-->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filedir}" ireturn="iSize.Srca.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filename}" ireturn="iSize.Srca.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filedir}" ireturn="iSize.Desta.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filename}" ireturn="iSize.Desta.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<ac:if>
		<and>
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Srca.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filedir}" />
		</and>
		<ac:then>		
				<fl:echo message="Alle Arrays sind gleich lang: ${iSize.Srca.filedir} " />				
		</ac:then>
		<ac:else>
				<fl:fail message="Unterschiedliche Arraylaengen: iSize.Srca.filedir={$iSize.Srca.filedir} | iSize.Srca.filename=${iSize.Srca.filename} | iSize.Desta.filedir=${iSize.Desta.filedir} | iSize.Desta.filename=${iSize.Desta.filename}  "/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:else>
	</ac:if>
	
	<!-- Merke es gibt ein antcontrib Target 'Pathtofileset' dies hier vielleicht anwenden ? -->
	
	<!-- Todo: Schleife über alle Arraypositionen-->
	<!-- Todo GOON 20150711: Hole die Werte der aktuellen Arrayposition -->
	<arrayGetJsZZZ arrayinput="${mySrca.filedir}" index="0" arrayget="mySrc.filedir"/>	
	<arrayGetJsZZZ arrayinput="${mySrca.filename}" index="0" arrayget="mySrc.filename"/>	
	<arrayGetJsZZZ arrayinput="${myDesta.filedir}" index="0" arrayget="myDest.filedir"/>	
	<arrayGetJsZZZ arrayinput="${myDesta.filename}" index="0" arrayget="myDest.filename"/>	
		
	<!-- 4. Der eigentliche Kopiervorgang -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing File ${mySrc.filedir}\${mySrc.filename} to Destination: ${myDest.filedir}\${myDest.filename} </echo>
												
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
	<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
	              TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
	<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
	<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
	<fileset dir="//${mySrc.filedir}">		
	<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
	<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
	<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
													
		<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${mySrc.filename}" />				
	</fileset>
	<globmapper from="${mySrc.filename}" to="${myDest.filename}"/>
	</copy>									
</target>


<target name="-FGLCopyLocal_Analyze">
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>

	<!-- Prüfe, ob Datei vom Linken Teil existiert -->
	<fl:choose>
		<fl:when test=" '${myLeftPart}'.tofile.exists == true ">
			<echo>Datei existiert (von...): ${myLeftPart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${myLeftPart}" property="myisdirectoryLeftPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<!-- <echo>linker Teil: isdirectory=${myisdirectoryLeftPart}</echo> -->
														
			<fl:when test="${myisdirectoryLeftPart} == true">
					<!-- A) Linker Teil - Verzeichnis-Fall: -->
					<echo>Linker Teil: ist Verzeichnis</echo>
					<fl:let>myCase ::= "D"</fl:let>	<!-- D=directory-->																						 
			</fl:when>
			<fl:when test="${myisdirectoryLeftPart} != true">
					<!-- B) Linker Teil - Dateipfad-Fall:-->
					<echo>Linker Teil: ist KEIN Verzeichnis</echo>
					<fl:let>myCase ::= "F"</fl:let><!-- F=file-->
			</fl:when>
		</fl:when>
		<fl:otherwise>
			<echo>Datei/Verzeichnis existiert NICHT (von...): ${myLeftPart}</echo>
			<fl:let>myCase ::= "X"</fl:let>
			<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</fl:otherwise>
	</fl:choose>
	
		<!-- Prüfe, ob Datei vom Rechten Teil existiert -->
	<fl:choose>
		<fl:when test=" '${myRightPart}'.tofile.exists == true ">
			<echo>Datei existiert (nach...): ${myRightPart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${myRightPart}" property="myisdirectoryRightPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<!-- <echo>rechter Teil: isdirectory=${myisdirectoryRightPart}</echo> -->
														
			<fl:when test="${myisdirectoryRightPart} == true">
					<!-- A) Rechter Teil - Verzeichnis-Fall: -->
					<echo>Rechter Teil: ist Verzeichnis</echo>
					<fl:let>myCase ::= "${myCase}D"</fl:let>	<!-- D=directory-->																								 
			</fl:when>
			<fl:when test="${myisdirectoryRightPart} != true">
					<!-- B) Rechter Teil - Dateipfad-Fall:-->
					<echo>Rechter Teil: ist KEIN Verzeichnis</echo>
					<fl:let>myCase ::= "${myCase}F"</fl:let><!-- F=file-->
			</fl:when>
		</fl:when>
		<fl:otherwise>
			<echo>Datei/Verzeichnis existiert NICHT (nach...): ${myRightPart}</echo>
			<fl:let>myCase ::= "${myCase}X"</fl:let>
			<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</fl:otherwise>
	</fl:choose>	
	<echo>Soweit ermittelter Fall: ${myCase}</echo>
	<fl:let>returnAnalyze ::= true</fl:let>
	<fl:let>returnString ::= "${myCase}"</fl:let>										
</target>

<target name="-FGLCopyLocal_Control">
	<fl:let>myAnalyze ::= "${analyze}"</fl:let>
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myLeftPart ::= "${rightPart}"</fl:let>
	
	<!--### START: Aufruf der verschiedenen Fälle ####################-->
	<!-- F=file, D=directory,X=not existing. Es geht nicht um die Konfiguration, sondern darum, dass die Dateien / Verzeichnisse existieren -->
	
	<!-- TODO GOON: Je nach Fall ein anderes Target aufrufen. Dadurch ist der Code modularer --> 	
	<!-- TODO: jeweils ein Array erstellen 1) mit den Werten des Ausgangsdateipfads, 2) mit den Werten des Zieldateipfads -->
	<!-- todo codeschnipsel unten teilweise hier wieder einfügen oder in ein extra Target packen -->
										
	<ac:if>
		<ac:equals arg1="${myAnalyze}" arg2="XX"/>										
		<ac:then>
			<echo>Fall: Datei/Verzeichnis links nicht existent, Datei/Verzeichnis rechts nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
		</ac:then>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="XD"/>										
		<ac:then>
			<echo>Fall: Datei/Verzeichnis links nicht existent, rechts Datei</echo>
			<fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="DX"/>										
		<ac:then>
			<echo>Fall: links Datei, Datei/Verzeichnis rechts nicht existent</echo>
			<!-- TODO: Prüfe, ob rechts ein Verzeichnisname ist. Kopiere von links nach rechts. mache ggfs. fehlende Unterverzeichnisse. -->
		</ac:then>
	</ac:elseif>									
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="DF"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts Datei</echo>
			<!-- TODO: Kopiere die rechts benannte Datei aus dem links angegebenen Verzeichnis nach rechts -->
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="FD"/>										
		<ac:then>
			<echo>Fall: links Datei, rechts Verzeichnis</echo>
			<!-- TODO: Kopiere die links benannte Datei in das rechts angegebenen Verzeichnis -->
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="DD"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts Verzeichnis</echo>
			<!-- TODO: Kopiere alle Dateien aus dem einen Verzeichnis in das andere -->
		</ac:then>
	</ac:elseif>
	<ac:elseif>		
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FF"/>
			<ac:equals arg1="${myAnalyze}" arg2="FX"/>
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Datei (oder noch nicht existent)</echo>

			<antcallback target="-FGLCopyLocal_Control_FF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			<arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			<arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			<arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
			
			
			
			<fl:echo>Ergebnis des Controll_FF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>mySrca.filedir ::= "${returnSrca.filedir}"</fl:let>
			<fl:let>mySrca.filename ::= "${returnSrca.filename}"</fl:let>
			<fl:let>myDesta.filedir ::= "${returnDesta.filedir}"</fl:let>
			<fl:let>myDesta.filename ::= "${returnDesta.filename}"</fl:let>
		</ac:then>
	</ac:elseif>									
	<ac:else>
		<fl:fail message="Ungueltiges Analyseergebnis: ${myAnalyze}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
	</ac:else>											
	</ac:if>
	
	<fl:let>returnControl ::= true</fl:let>
	<fl:let>returnSrca.filedir ::= "${mySrca.filedir}"</fl:let>
	<fl:let>returnSrca.filename ::= "${mySrca.filename}"</fl:let>
	<fl:let>returnDesta.filedir ::= "${myDesta.filedir}"</fl:let>
	<fl:let>returnDesta.filename ::= "${myDesta.filename}"</fl:let>
</target>


<target name="-FGLCopyLocal_Control_FF">
	<!-- TODO GOON: 20150710 -->
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myLeftPart ::= "${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_FF</fl:echo>
	<!-- TODO tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	
	<!-- TODO GOON: "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_FF_Part" return="returnControl, returnA.filedir, returnA.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	
		<!-- TODO GOON: Rueckgabewerte sind jetzt kaputt. WARUM ? -->
		<arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->
			<echo> KAPUTT !</echo>
	<arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<fl:let>mySrca.filedir ::= "${returnA.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${returnA.filename}"</fl:let>
	
	
	<echo>Behandle rechten Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_FF_Part" return="returnControl, returnA.filedir, returnA.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	
	
	
	
	
	
	
	<!-- TODO GOON: Rueckgabewerte sind jetzt kaputt. WARUM ? -->
	<arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->		
	<echo> KAPUTT !</echo>
	<arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->		
	<fl:let>myDesta.filedir ::= "${returnA.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${returnA.filename}"</fl:let>

	<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->
	
	<fl:let>returnControll ::= true</fl:let>
	<fl:let>returnSrca.filedir ::= "${mySrca.filedir}"</fl:let>
	<fl:let>returnSrca.filename ::= "${mySrca.filename}"</fl:let>
	<fl:let>returnDesta.filedir ::= "${myDesta.filedir}"</fl:let>
	<fl:let>returnDesta.filename ::= "${myDesta.filename}"</fl:let>	
</target>

<target name="-FGLCopyLocal_Control_FF_Part">
	<!-- TODO GOON: 20150710 -->
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myPart ::= "${sPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_FF_Part</fl:echo>
	<fl:echo>fuer: ${myPart}</fl:echo>
	
	
	<!-- TODO: Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->
	<!-- <echo>src.filedir = #{split('aabcc','b')[0]}</echo> -->
	<!-- Z.B.: Hiermit holt man ggfs. den Laufwerksnamen, oder auch das letzte Element -->
	<!-- <echo>src.filedir = #{split('${myLeftPart}','\\\\')[0]}</echo> -->
	<fl:let>sfileadir ::= split('${myPart}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																	

												
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>								
	<echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<fl:let>xtractedvalue ::= split('${myPart}','\\\\')[${index}]; 
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	<echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- TODO GOON 20150717: Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!--Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftString' uebergeben. -->
	<fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo> 
	<fl:let>xtractedvalueTemp ::= #{"format('\\%s', xtractedvalue)"}	</fl:let>
	
	<!-- DETAILKAPUTT: Hier sollte der letze backslash weg sein -->
	<echo>DETAILKAPUTT !</echo>
	<stringLeftString text="${myPart}" matchstring="${xtractedvalueTemp}" returnstring="myPath" />
	<echo>Der Pfad ist: ${myPath}</echo>
	
	<!-- 4. Packe die Werte in ein Array -->
	<arrayInitJsZZZ isize="0" arrayreturn="myfileaname"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" -->
	<arrayAppendJsZZZ arrayinput="${myfileaname}" valueinput="${xtractedvalue}" arrayreturn="fileaname" sflagcontrol="" />
	<arrayDebugJsZZZ arrayinput="${fileaname}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	
	<arrayInitJsZZZ isize="0" arrayreturn="myfileadir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" -->
	<arrayAppendJsZZZ arrayinput="${myfileadir}" valueinput="${myPath}" arrayreturn="fileadir" sflagcontrol="" />
	<arrayDebugJsZZZ arrayinput="${fileadir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	
	
	<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<fl:let>returnControl ::= true</fl:let>
	<fl:let>returnA.filedir ::= "${fileadir}"</fl:let>
	<fl:let>returnA.filename ::= "${fileaname}"</fl:let>
</target>

</project>