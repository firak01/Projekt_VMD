<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
   xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
    <!-- ######## Scriptdefs ############################################################################--> 		
	<!-- ########################### -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<attribute name="arrayinput" />
		<attribute name="ireturn" />
		<![CDATA[
			var lista = attributes.get("lista");		 
			var iReturn = -1;
										
			//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
			var icount=0;
			var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
			if(typeof(objectArray)=="object"){
			for(x in objectArray){
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				}else{
					icount++;
				};				
			}							
			}else{
				iReturn=0;
			}
			
			iReturn = icount;
			
			project.setProperty(attributes.get("ireturn"), iReturn);
		]]>
	</scriptdef>
	
	<!-- ########################### -->		
	<scriptdef name="isDirectoryZZZ" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist Package notwendig
		   importClass(java.io.File);                               //Bei BasisJava darf Package nicht vorneweg stehen.
		   var text = attributes.get("text");		 
		   //var fd = new java.io.File(text);
		   var fd = new File(text);
		   var berg = false;
		   if (fd.isDirectory()) {
			   //print("js true");
		       berg = true;
			} else {
				//print("js false");
				berg = false;
			}
			project.setProperty(attributes.get("property"), berg);
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="substringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		 ]]>
	</scriptdef>

	   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
  	
	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
  	
  
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur -->
 <property name="dest.dirRepositoryVmdLib" value="lib" />
  <property name="dest.dirRepositoryVmdBat" value="bat" />
  <property name="dest.dirRepositoryVmdSrc" value="src" />
  <property name="dest.dirRepositoryVmdMisc" value="misc" />
  <property name="dest.dirRepositoryVmdTest" value="test" />
  <property name="dest.dirRepositoryVmdArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  <loadproperties>
  	<file file="${vmd}"/>
  	<!--<file file="${env.VMD}"/>-->
  </loadproperties> 
  <echo>test1 hat den Wert: ${test1}</echo>  	 
  <echo>conf.dirRepositoryVmdPath hat den Wert: ${conf.dirRepositoryVmdPath}</echo>
  <property name="dest.dirRepositoryVmdPath" value="c:/1fgl/repository/Projekt_VMD" />  
 
  <!-- TODO GOON: Prüfe die Controldateien auf Existenz und Validität. Setze bGOON Variablen, die dann in den Targets abgeprüft werden. -->
  	
  	
  <!-- ######### CLIENT ############################################################################## -->
  <!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
  <!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
  <!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
  <property name="src.dirFglClient" value="client" /> 
  <property name="src.dirFglPath" value="C:/1fgl"/>
  <property name="src.dirFglClientPath" value="${src.dirFglPath}/${src.dirFglClient}" /> 

  <!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
  	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}" />
    <property name="src.dirFglClientFileName" value = "Fgl${env.COMPUTERNAME}_Installationen.txt"/><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>src.dirFglClientFilePath ::= '${src.dirFglClientFilePath}/${src.dirFglClientFileName}'</fl:let>
	<echo>Wert von src.dirFglClientFilePath=${src.dirFglClientFilePath}</echo>
	</target>
  
  <!-- ################################################################################# -->
   <target name="compile" depends="declaration, init,FglRepositoryBackup,FglCopyClient2archive,FglCopyLocal">
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  
  <target name="init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
       
<target name="FglRepositoryBackup">
	<!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
	<property name ="dest.dirRepositoryVmdBackupPath" value="${dest.dirRepositoryVmdPath}Backups" />
  
	<echo>Creating Backup:</echo>
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade -->
	<mkdir dir="//${dest.dirRepositoryVmdPath}"/>
	<mkdir dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" />
	<mkdir dir="//${dest.dirRepositoryVmdBackupPath}"/>

	<echo>a) VmdRepository Archive:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind. -->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}"
	/>
</target>
	
	
<target name="FglCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing Files to Repository:</echo>
	<echo>a) VMD File:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
	     <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${src.dirFglClientFileName}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
		 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- Beispiel für ein antcallback, in dem aus einer Schleife ein Wert zurückgeliefert wird. -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="FglCopyLocal">
	<echo>######################################</echo>
	
	<!-- Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	
	<!-- 1. Rechne den Dateinamen aus -->
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	
	 <!-- Todo: Eigentlich müssen oben erst die conf - Parameter definiert werden und daraus werden dann die dest/src Parameter ggfs. geholt -->
	<property name="conf.dirRepositoryVmdPath" value="${dest.dirRepositoryVmdPath}" /> 
	<property name="conf.dirRepositoryVmdBat" value="${dest.dirRepositoryVmdBat}" />
	
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />

	<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
    <property name="conf.copyLocalFileName" value = "Fgl${env.COMPUTERNAME}_copy_local.properties"/>
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryVmdPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
	<echo>Copy files general, by property file:</echo>
	<echo>${conf.copyLocalFilePath}</echo>
	
	<!-- 2a. Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<when test=" '${conf.copyLocalFilePath}'.tofile.exists == true ">
			<echo>Datei existiert: ${conf.copyLocalFilePath}</echo>

			<!-- 2. Lies den Inhalt der Datei als Properties-Datei ein. -->	
			<!--<loadproperties>
				<file file="${conf.copyGeneralFilePath}"/>
			</loadproperties> 
			<echo>test1 hat den Wert: ${test1}</echo> -->
			
			
			<!-- 2a. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
			
			<!-- Test: Gib den Inhalt der Datei aus -->
			<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
			<!-- <echo>${myfile}</echo> -->
	
	
			<!--2b. Werte den Inhalt der Datei zeilenweise aus -->			
			<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
			<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
				<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
					<file file="${conf.copyLocalFilePath}" />
				</tokens>
				<sequential>
					<var name="line.length" unset="true" />
					<length string="@{line}" property="line.length" />
					<if>
						<equals arg1="${line.length}" arg2="0" />
						<then>
							<echo>Zeile: 
							</echo>
						</then>
						<else>						
							<echo>Zeile: @{line}</echo>
							<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->							
							<substringZZZ text="@{line}" start="0" end="1" property="subtext" /><!-- anwenden der oben definierten scriptdef funktion substring -->
							<!-- <echo message="subtext = ${subtext}" />	 -->						
							<if>
								<equals arg1="${subtext}" arg2="#" />
								<then>
									<echo>Kommentarzeile, wird uebersprungen...</echo>
								</then>
								<else>
									<echo>Steuerungszeile, wird ausgewertet...</echo>
									
									<!-- 2c. Splitte die Zeile mit Flaka - Splitt funktion (steht in der Flaka Doku unter EL). -->							 				 							
									<!-- <fl:echo>linker Teil der Zeile => #{split('@{line}','=')[0]}</fl:echo> --><!-- beachte, dass mit dem #{ ... } die Funktion aufgerufen wird, so dass ihr Ergebnis in den String eingefügt werden kann.-->
									<!-- <fl:echo>rechter Teil der Zeile => #{split('@{line}','=')[1]}</fl:echo> -->
	
									<!-- Schreibe das in eine Flaka - Variable -->		
									<fl:let>myLeftPart ::= split('@{line}','=')[0]</fl:let>		
									<fl:let>myRightPart ::= split('@{line}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
									<fl:echo>Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
									<fl:echo>Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
														 							
									<fl:when test="null('${myRightPart}')">
										<!-- TODO: Idee: in der initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
										<!-- FEHLER, Datei nicht definiert -->
										<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): @{line}</echo>
										<fl:fail message="Rechter Teil der Steuereungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
									<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
		<!-- 								<fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
										<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										<fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>

									<!-- Prüfe, ob Datei vom Linken Teil existiert -->
									<fl:choose>
										<when test=" '${myLeftPart}'.tofile.exists == true ">
											<echo>Datei existiert (von...): ${myLeftPart}</echo>
											
											<!-- Erstelle / Initialisiere neu eine Liste der "Zieldateien", das kann nur eine sein oder auch alle Dateien eines Verzeichnisses -->
											<fl:let>listaDestinationFiles ::= list()</fl:let>
											
											<!-- Prüfe, ob es ein Verzeichnis ist -->
											<isDirectoryZZZ text="${myLeftPart}" property="myisdirectory" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
											<echo>linker Teil: isdirectory=${myisdirectory}</echo>
											<!-- A) Linker Teil - Verzeichnis-Fall: TODO: Wenn der linke Teil ein Verzeichnis ist, alle Dateien darin kopieren, sofern der rechte Teil auch ein Verzeichnis ist. -->
											<fl:when test="true('${myisdirectory}')">
												<fl:fail message="Linker Teil der Steuerungsanweisung ist ein Verzeichnis: ${myLeftPart}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
											</fl:when>
											
											<!-- B) Linker Teil - Dateipfad-Fall: Ermittle den Ausgangsdateipfad und den -namen -->
																											
											<!-- TODO: Prüfe, ob der rechte Teil ein Verzeichnis ist... -->
											<!-- Falls JA: Hole vom linken Teil den Dateinamen und hänge ihn an das Verzeichnis an -->
											<!-- Falls NEIN: Nimm das Verzeichnis, wie es ist. -->																												
											<isDirectoryZZZ text="${myRightPart}" property="myisdirectory" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
											<echo>Rechter Teil: isdirectory=${myisdirectory}</echo>																								
											<fl:choose>
												<!-- Die Vorgehensweise beim Kopieren erfordert es, dass es eine Variable für das Verzeichnis und eine Variable für die Datei gibt. (für das fileset include) -->
												<when test=" '${myisdirectory}'=='true'">
													<echo>Rechter Teil (nach...) ${myRightPart} ist ein Verzeichnis </echo>
													<fl:let>dest.filedir ::= ${myRightPart}</fl:let>
													<fl:let>dest.filename ::= ${src.filename}</fl:let>																									
												</when>
												<otherwise>
													<echo>Rechter Teil (nach...) ${myRightPart} ist KEIN Verzeichnis </echo>
													<!-- TODO GOON: Hole den Namen des Verzeichnisses (als Pfad), hole den Dateinamen -->
													<fl:let>dest.filedir ::= split('${myRightPart}','\\')[0]</fl:let>
													<fl:let>dest.filename ::= split('${myRightPart}','\\')[1]</fl:let>
												</otherwise>
											</fl:choose>
											<fl:echo>dest.filedir => ${dest.filedir}</fl:echo>
											<fl:echo>dest.filename => ${dest.filename}</fl:echo>
											
											
											<!-- TODO: Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->
											<!-- <echo>src.filedir = #{split('aabcc','b')[0]}</echo> -->
											
											<!-- Z.B.: Hiermit holt man ggfs. den Laufwerksnamen, oder auch das letzte Element -->
											<!-- <echo>src.filedir = #{split('${myLeftPart}','\\\\')[0]}</echo> -->
											<fl:let>src.fileadir ::= split('${myLeftPart}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
											<!-- 2. ermittle die groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
											<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																													
											<!-- 			Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
											<arrayElementCountJsZZZ arrayinput="${src.fileadir}" ireturn="mylistasize"/>
											<echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</echo>
																						
											<fl:for var="mydir" in="split('${myLeftPart}','\\\\')">
											<echo>#{mydir}</echo><!-- Aufruf der Variablen als EL Expression -->
											</fl:for>
											
											<!-- 3. Ermittle die Indexposition -->
											<!-- TODO: Array Scriptdef, um den wert an einer Indexposition zu bekommen,
											           Array Scriptdef, um den Wert an der letzten Indexposition zu bekommen. -->													   
											<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
											<var name="op1" value="${mylistasize}"/>
											<var name="op2" value="1"/>
											<var name="op" value="-"/>
											<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
											<echo>errechneter wert fuer Index des letzten Pfadteils: #{index}</echo>
											<fl:let>
												xtractedvalue ::= split('${myLeftPart}','\\\\')[${index}]; <!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
											</fl:let>
											<echo>An letzter Stelle gefundener wert: #{xtractedvalue}</echo>
											
											<!-- TODO: Hänge diesen Wert an das Zielverzeichnis an. Das ist der Zieldateipfad -->
											
											
											<!-- 4. Der eigentliche Kopiervorgang -->
											<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
											<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
											<echo>Pushing File ${src.filedir}\${src.filename} to Repository: ${dest.filedir}\${dest.filename} </echo>
											
											<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
											<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
											  <fileset dir="//${src.dirFglClientPath}">	
												 <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
												 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
												
												<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
												<include name="${src.dirFglClientFileName}" />		
											  </fileset>
											</copy>
											
											<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
											<echo>b) Misc Files:</echo>
											<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
											<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
											  <fileset dir="//${src.dirFglClientPath}">	
												 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
												<include name="**.txt"/>
											  </fileset>
											</copy>
										</when>
										<otherwise>
												<echo>Datei existiert NICHT (von...): ${myLeftPart}</echo><!-- hier auch kein fail, sondern nur diese Warnung -->												
										</otherwise>
									</fl:choose>			
								</else>
							</if>											
						</else>
					</if>
				</sequential>
			</for>			
		</when>
		<otherwise>
				<echo>Datei existiert NICHT: ${conf.copyLocalFilePath}</echo>
				<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</otherwise>
	</fl:choose>

</target>



</project>