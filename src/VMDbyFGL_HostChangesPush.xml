<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">
   <!-- damit definiert man für antcontrib , bzw. FLAKA einen eigenen Namespace. Antcontrib wird hier per taskdef (siehe unten) hinzugefügt. -->
   
   
   <!-- ### Notepad++ Hotkeys:
        ALT + 0, ALT +1, .... XML Tags der Ebene zusammenklappen. -->
   

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
    <!-- ######## Scriptdefs ############################################################################--> 		
	<!-- ############################################################-->
	<scriptdef name="arrayAppendJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="valueinput" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("valueinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;					
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				}
			}
						
			//3. Erweitere das Array UM ENCODIERTEN WERT
			icountGlobal++;
			print("Wert encoded anhängen an position " + icountGlobal + ": '" + myValue + "'");
			var textEncoded = encodeMyHtml(myValue);
			print("Encoded Wert wird kopiert: '" + textEncoded + "'");
			
			//TODO An dieser Stelle bei der Erweiterung arrays anzuhängen: Prüfen, ob das ein Einzelwert oder ein Array ist.
			myArrayReturn[icountGlobal]=textEncoded;
																						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			
		//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayAppendArrayJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="array2append" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myArray2append = attributes.get("array2append");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
			
			var objectArray2append = myArray2append.split(',');  //Merke: Versuche so ein Array zu machen.							
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
						
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".		
			//print("Uebernimm Werte des Ausgangsarrays:");
			for(x in objectArray){
				//print("Wert vom Ausgangsarray: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					};
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugebende Array
			icount=-1; 
			var icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert: '" + objectArray[x]+ "'");
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				};
			};
						
			//3. Erweitere das Array, UM ALLE ANDEREN ARRAYWERTE
			for(z in objectArray2append){								
				if(objectArray2append[z]=="<#!!FGLUNDEFINED!!#>"){
					//print("<#!!FGLUNDEFINED!!#> Wert NICHT anhaengen.");
				}else{
					icountGlobal++;
					//print("Wert anhaengen an position " + icountGlobal + ": '" + objectArray2append[z]+ "'");
					myArrayReturn[icountGlobal]=objectArray2append[z];
				};
				
				
			};			
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayCopyJsZZZ" language="javascript">
		<!-- Hiermit man ein Array in eine anderes neues Array.
             Beispielsweise sinnvoll, wenn von einer Funktion ein neues Array zurückgegeben wird,
             man aber noch mit dem alten 'Variablennamen' weiterarbeiten möchte.			 -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			
			//Kopiervorgang, noch ohne irgendwelche FlagControl Erweiterungen.			
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
				myArrayReturn[icount]=objectArray[x];
			};
															
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################ -->
	<scriptdef name="arrayDebugJsZZZ" language="javascript">
		<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
			   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
			   - der Inhalt
			   - die Größe des Arrays			-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="arrayinput" />
		<attribute name="ilevel" />	
		<![CDATA[	
			enableJava();
			var myArray = attributes.get("arrayinput");					
			var myLevel = attributes.get("ilevel");					
			if(myLevel<=0){
				
			}else{
			if(myArray===undefined) print("myarray = undefined");
			if(myArray==null) print("myarray = NULL");	
			
			//Typausgabe
			print("typeof myarray = " + typeof(myArray));
					
			
			var iSize=0;
			if(Array.isArray(myArray)){
				print("Array uebergeben bekommen");
				iSize = myArray.length;
				print("Arraygroesse="+iSize);
				
				//TODO: Die gleichen Ausgaben wie im KEIN ARRAY Fall.
				//- Werte
			}else{
				print("kein Array uebergeben bekommen.");
				
				var icount=0;					
				if(typeof(myArray)=="object"){
					print("Object uebergeben bekommen.");
					
					if(myLevel>=2){
					//das listet alle Methoden des objekts auf.... scheint ein String zu sein....
					//print("ALLE METHODEN DES OBJEKTS:");
					//for(x in myArray){
					//	print(x);		
					//};	
					
					print("#################################");
					print("ALLE METHODEN UND CODEINHALT DES OBJEKTS:");
					for(xx in myArray){
						print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
						print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
					};
					};//myLevel>=2;
					
					debugArrayAsString(myArray);
				}else{
					print("kein Objekt");
					debugArrayAsString(myArray);					
				};
			};
			};//myLevel <= 0;
			
			
			function debugArrayAsString(myArray){
					print("#################################");
					print("myArray ist jetzt leider ein String ='"+ myArray +"'");
					//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
					
					print("splitte diesen String nach Komma.");
					var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
					for(x in objectArray){
						print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					};
					
					//var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
					//for(x2 in objectArray02){
					//	print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
					//};
					
					//var objectArrayString = myArray.toString();
					//var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
					//for(z in objectArray03){
					//	print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					//};
					
					print("#################################");
					print("Versuch die Werte auszugeben: ");	
					//Merke: Voraussetzung ist:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 for(yy in objectArray){
							print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
						};
			}
			
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
			
		]]>
	</scriptdef>
	
	 <!-- ########################################################### -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="ireturn" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iReturn = -1;
										
			//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
			var icount=0;
			var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
			if(typeof(objectArray)=="object"){
			for(x in objectArray){
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				}else{
					icount++;
				};				
			}							
			}else{
				iReturn=0;
			}
			
			iReturn = icount;
			
			project.setProperty(attributes.get("ireturn"), iReturn);
		]]>
	</scriptdef>
	
	<!-- ########################### -->	
	<scriptdef name="arrayGetJsZZZ" language="javascript">
		<!-- Hiermit holt man den Wert an einer Indexposition (beginnend mit 0)
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	-->
				
		<!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="index" />
		<attribute name="arrayget" />
		<attribute name="sflagcontrol" /><!-- sflagcontrol werte: raw=mache kein unescape. -->
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iIndex = attributes.get("index");
			var mysFlagControl = attributes.get("sflagcontrol");
			var objReturn="<#!!FGLUNDEFINED!!#>";
			main:{
				if(iIndex <= -1) break main;
				
				//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
				var icount=-1;
				var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				if(typeof(objectArray)=="object"){
				for(x in objectArray){
					print("x="+x);
					print("objectArray[x]="+objectArray[x]);
					
					//Undefinierte, d.h. nur initialisierte Arrays abfangen
					//Sie haben die Groesse 0 und an erster Stelle das <#!!FGLUNDEFINED!!#>
					if(objectArray.length<=1 && objectArray[x]=="<#!!FGLUNDEFINED!!#>"){						
						break main;
					}else{
						icount++;
						if(icount==iIndex){
							//Per Schalter das unescapen abstellbar machen. Also auf Wunsch also die 'raw Werte' zurückliefern.
							if(mysFlagControl=='raw'){
							    objReturn = objectArray[x];
							}else{
								var textUnescaped = unescape(objectArray[x]); //Merke: In ArrayAppendJsZZZ werden die Strings nur noch encoded angehängt.
								objReturn = textUnescaped;								
							}
							break main;
						}				
					}; //end if
					}; //end for
				}; //end if(typeof(objectArray)=="object")				
			}; //end main:
			project.setProperty(attributes.get("arrayget"), objReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->		
	<scriptdef name="arrayInitJsZZZ" language="javascript">
		<!-- Hiermit faked man die Erstellung eines Arrays.
			 Da scheinbar kein "call by reference" gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="isize" />
		<attribute name="arrayreturn" />		
		<![CDATA[										 
			var mySize = attributes.get("isize");	
			//print("iSize = '" + mySize + "'");
			
			//Prüfen, ob mySize eine Zahl ist. 
			//Merke: Ist z.B. die Flaka - Variable nicht oder leer deklariert, kommt hier der Variablenname '${irgendwas}' an.
			//           Das bewirkt, dass dieses '${irgendwas}' als erstes Element in´s Array kommt und das Array sofort die Größe 1 hat, was in dem Fall nicht beabsichtigt ist.
			if(isNumber(mySize)){
				//print("eine Zahl");
				var myArrayReturn = new Array(); //Merke: Egal was man hier als Groesse angiebt [irgendwas] wird als Wert übernommen genauso wie leiglich: irgendwas
				
				if(mySize==0){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
				}
				if(mySize>=1){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					for(icount=0; icount<=mySize-1; icount++){
						myArrayReturn[icount]="<#!!FGLEMPTY!!#>";
					}												
				}								
			}else{
				//print("KEINE Zahl");
				var myArrayReturn = new Array();

				//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
				myArrayReturn="<#!!FGLUNDEFINED!!#>";
			}
						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->	
	<scriptdef name="arrayLeftBackStringJsZZZ" language="javascript">
		<!-- Hiermit schneodet man von den Werten eines Arrays einen Stringwert ab. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="sinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'before' von vorne bzw. 'behind' von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("sinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			//   UND erweitere jeden Arrayeintrag um den gewünschten String.
			//   TODO: sFlagControl auswerten, zum unterscheiden ob der String vorangestellt oder angehängt wird.
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert und abgeschnitten: '" + objectArray[x]+ "' leftback von '" + myValue + "'");
					myArrayReturn[icount]=getStrLeftBackStr(objectArray[x], myValue);
				}else{
					//nix
				}
			}
						
													
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			
			//äquivalent zu JSZ - Kernel
			//@LeftBack equivalent, !!! casesensitive
			function getStrLeftBackStr(sourceStr, keyStr){
				arr = sourceStr.split(keyStr)
				arr.pop();
				return (keyStr==null | keyStr=='') ? '' : arr.join(keyStr)
			}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->	
	<scriptdef name="arrayPlusStringJsZZZ" language="javascript">
		<!-- Hiermit häng man an die Werte eines Arrays einen Stringwert an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="sinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'before' von vorne bzw. 'behind' von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("sinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			//   UND erweitere jeden Arrayeintrag um den gewünschten String.
			//   TODO: sFlagControl auswerten, zum unterscheiden ob der String vorangestellt oder angehängt wird.
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert und erweitert: '" + objectArray[x]+ "' plus '" + myValue + "'");
					myArrayReturn[icount]=objectArray[x] + myValue;
				}else{
					//nix
				}
			}
																			
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
  <!-- ########################### -->
  <scriptdef name="arrayStringImplodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
				
	<!-- Fügt die Strings eines Arrays zusammen. Dabei untere / oberen Indes als Grenze der zu verarbeitenden Arraywerte angeben. -1 ist jeweils min / max. -->
	<attribute name="inputarraystring" />
	<attribute name="inputdelimiter"/>
	<attribute name="inputindexlow"/>
	<attribute name="inputindexhigh"/>

    <attribute name="returnstring" /> 
	<attribute name="returncontrol" /> 
	
    <![CDATA[
		//normalerweise verwendet man join, wie in dem Beispiel:
		//var str_to_split = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z";
		//var myarray = str_to_split.split(",");
		//var output=myarray.join("");
		//
		//Aber hier soll nur ein bestimmter Bereich von... bis... gejoint werden. 
		//Sinnvoll um vom Array vorne oder hinten etwas abzuschneiden.
	    
		var myArrayString = attributes.get("inputarraystring");		
		var myDelimiter = attributes.get("inputdelimiter");
		var myiIndexLow = attributes.get("inputindexlow");
		var myiIndexHigh = attributes.get("inputindexhigh");
		//print("myiIndexLow=" + myiIndexLow);
		//print("myiIndexHigh=" + myiIndexHigh);
		
		
		var myStringReturn = "";
		var bReturnControl = true;
		
		if(myArrayString===undefined){
			//print("myString = undefined");
			bReturnControl = false;
		}else if(myArrayString===null){
			//print("myString = null");			
			bReturnControl = false;
		}else{
			if(myDelimiter===undefined){
				//print("myDelimiter = 'undefined'");
				myStringReturn=myArrayString.join("");
				bReturnControl = false;
			}else if(myDelimiter===''){
				//print("myDelimiter = 'leer'");
				myStringReturn=myArrayString.join("");
				bReturnControl = false;
			}else{	
				//print("myDelimiter = " + myDelimiter);
			
				if(myiIndexLow===undefined){
					myiIndexLow=0;
				}else if(myiIndexLow==null){
					myiIndexLow=0;
				}else if(myiIndexLow<=-1){
					myiIndexLow=0;
				}
				
				//Merke: Versuche so ein 'echtes' Array zu machen, sonst geht man Buchstabe für Buchstabe vor.
				var objectArray = myArrayString.split(',');  
										
				//Hole die Anzahl der Einträge im Array, ggfs. für einen ungueltigen oberen Wert
				myiIndexMax = objectArray.length-1;
				//print("myiIndexMax="+myiIndexMax);
				if(myiIndexHigh===undefined){
					myiIndexHigh=myiIndexMax;
				}else if(myiIndexLow==null){
					myiIndexHigh=myiIndexMax;
				}else if(myiIndexHigh>myiIndexMax){
					myiIndexHigh=myiIndexMax;
				}else if(myiIndexHigh<=-1){
					myiIndexHigh=myiIndexMax;
				}
				
				//Falsch: damit geht man Buchstabe für Buchstabe vor: 
				//for (var i = myiIndexLow, len = myiIndexHigh; i<len; i++){
				//	print("myArrayString[i]="+myArrayString[i]);
				//	myStringReturn+=myArrayString[i];
				//	print("myStringReturn="+myStringReturn);
				//}						 		
				var iIndexCount=-1;
				for(x in objectArray){
					iIndexCount++;
					//print("objectArray[x]="+objectArray[x]);
					if(iIndexCount>=myiIndexLow){  //noch kaputt: Fehler durch >= provizieren . Richtig muss es nur >  heissen.
						if(iIndexCount >= myiIndexHigh) break;
						if(myStringReturn!="") myStringReturn+=myDelimiter;
						myStringReturn+=objectArray[x];					
						//print("myStringReturn="+myStringReturn);
					}
				}								
			}
		}				 
		project.setProperty(attributes.get("returnstring"), myStringReturn);
		project.setProperty(attributes.get("returncontrol"), bReturnControl);
				
     ]]>
	</scriptdef>	
	
  <!-- ########################### -->
  <scriptdef name="arrayStringTrimJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
				
	<!-- Entfernt leere Strings aus einem Array. bReturnControl=true, wenn etwas entfernt wurde. -->
	<!-- Controlstring: "trim = die einzelnen Strings sollen einem trim zur Pruefung unterzogen werden. Keine Veraenderung des Werts"
						 trimmed = wie trim, aber Veraenderung des Werts.-->
	<attribute name="inputarraystring" />
	<attribute name="inputcontrolstring" /> <!-- so mögliche Erweiterungen wie 'fulltrim' realisieren. -->
	
    <attribute name="returnarraystring" /> 
	<attribute name="returncontrol" /> 
	
    <![CDATA[
		var myArrayString = attributes.get("inputarraystring");		
		var myControlString = attributes.get("inputcontrolstring");	
	
		var myArrayReturn = new Array();			
		var bReturnControl = false;
		
		if(myArrayString===undefined){
			print("myString = undefined");
			bReturnControl = false;
		}else if(myArrayString===null){
			print("myString = null");			
			bReturnControl = false;
		}else{
						
				//Merke: Versuche so ein 'echtes' Array zu machen, sonst geht man Buchstabe für Buchstabe vor.
				var objectArray = myArrayString.split(',');  
														
				//Falsch: damit geht man Buchstabe für Buchstabe vor: 
				//for (var i = myiIndexLow, len = myiIndexHigh; i<len; i++){
				//	print("myArrayString[i]="+myArrayString[i]);
				//	myStringReturn+=myArrayString[i];
				//	print("myStringReturn="+myStringReturn);
				//}	

			
				
				//innerhalb der Schleife bReturnControl nur auf true setzen, nicht auf false... Grund: Einmal true gesetzt, soll es so gesetzt bleiben.
				var iIndexCount = -1;
				for(x in objectArray){
					print("objectArray[x]="+objectArray[x]);
					var sCheckValue = objectArray[x];
					var sValue = objectArray[x];
					if(myControlString=="trimmed"){
						sCheckValue = objectArray[x].trim();
						sValue= objectArray[x].trim();						
					}else if(myControlString=="trim"){	
						sCheckValue = objectArray[x].trim();
						//Keine Veraenderung des Werts
					};	
					
					//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
					if(sCheckValue=="<#!!FGLUNDEFINED!!#>"){
						//mache nix... myArrayReturn[icount]="<#!!FGLUNDEFINED!!#>";		//Wenn undefiniert, dann bleibt der Wert undefiniert.
						bReturnControl=true;
					}else if(sCheckValue=="<#!!FGLEMPTY!!#>"){
						//mache nix... myArrayReturn[icount]="Neuer Wert "+ icount; 		//Leere Werte werden automatisch erzeugt.
						bReturnControl=true;
					}else if(sCheckValue==""){
						//mache nix...
						bReturnControl=true;
					}else{						
						iIndexCount++;
						myArrayReturn[iIndexCount]=sValue; //Bestehende Werte werden nur kopiert.
						if(sValue==objectArray[x]){
							//mache nix...
						}else{	
							bReturnControl=true;
						};
					};		
				}								
			}	
			
			//abschliessende Pruefung
			if(myArrayReturn.lenght==0){
				print("Setze undefined Dummy - Wert.");
				myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
			};	
		project.setProperty(attributes.get("returnarraystring"), myArrayReturn);
		project.setProperty(attributes.get("returncontrol"), bReturnControl);
				
     ]]>
	</scriptdef>	
	
	<!-- ############################################################-->	
	<scriptdef name="getFilenameFromPathJsZZZ" language="javascript">
		 <attribute name="pathstring" />
		 <attribute name="returnfilename" />
		 <attribute name="returncontrol" />
		 <attribute name="returnacontrolstring" />
		 <attribute name="sflagcontrol" />
		 <![CDATA[
		   //Hole aus dem angegebenen Dateipfad den Dateinamen
		   var sPath = attributes.get("pathstring");
		   
		   var berg=false;
		   var myArrayErg = new Array();
		   var myFlagControl = attributes.get("sflagcontrol");
		   
		   print("Starte getFilenameFromPathZZZ '" + sPath + "'");

		   //TODO: So soll man den Dateinamen aus einem String bekommen, per JavaScript.
		   //      Dies ggfs. in JSZ-Kernel uebernehmen
		   //var filename = fullPath.replace(/^.*[\\\/]/, '')
		   
		   //Hier wird aber eine schon vorhandene JAZ-Kernel Methode verwendet.
		   enableJava();
		   importPackage(Packages.basic.zBasic.util.file);
		   importClass(java.io.File);                               //Bei BasisJava darf Package nicht vorneweg stehen.
		   
		   //var test = java.lang.System.getProperty("java.class.path");
		   //println("classpath="+test);
		   
		   //var sFilename = FileEasyZZZ.getNameOnly(sPath);
		   //print("Per JAZ-Kernel ermittelter Dateiname (aus '" + sPath + "'): '" + sFilename +"'");
		   
		   var objFile = FileEasyZZZ.getFile(sPath);
		   //var sDirectoryName = objFile.getParent(); //Holt aus dem Dateinamen den Verzeichnisnamen.
		   var sFilename = objFile.getName(); //Holt aus dem Pfad den reinen Dateinamen.
		   
		   //Hier Rueckgabewert anhand gelungener Dateinamensermittlung
		   if(sFilename!=""){		   
			berg =true;
			myArrayErg[0]="alles o.k.";
		   }else{
			berg = false;
			myArrayErg[0]="alles o.k.";
		   }
		   
		  
		   project.setProperty(attributes.get("returnfilename"), sFilename);	
		   project.setProperty(attributes.get("returncontrol"), berg);	
		   project.setProperty(attributes.get("returnacontrolstring"), myArrayErg);

		   function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}		   
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="isArrayEmptyJsZZZ" language="javascript">
		<!-- Hiermit prueft man, ob das Array nur Werte hat, die aber als Leerwert gekennzeichet ist. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="arrayinput" />
		<attribute name="returnboolean" />
		<attribute name="sflagcontrol" />
		<![CDATA[		   		  
		   var bReturn=true;		   
		   var myArrayInput=attributes.get("arrayinput");
		   //print("myArrayInput='"+myArrayInput+"'");		   			
			
			//Das Array in einer Schleife durchgehen			
			main:{				
				//Merke: arrayinput ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
				var icount=-1;
				var objectArray = myArrayInput.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				//print('typeof(objectArray)=' + typeof(objectArray));
				if(typeof(objectArray)=="object"){
					if(objectArray.length<=0)break main;
					
					var btemp=false;
					for(x in objectArray){
						//print("x="+x);
						//print("objectArray[x]="+objectArray[x]);
											
						//Prüfe alle Werte ab, ob man nicht doch noch einen definierten Wert im Array findet.
						if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
							btemp=true;							
						}else{	
							btemp=false;
							bReturn=btemp;
							break main;
						}; //end if
					}; //end for
					bReturn=btemp;
				}; //end if(typeof(objectArray)=="object")				
			}; //end main:	
			project.setProperty(attributes.get("returnboolean"), bReturn);						
		 ]]>
	</scriptdef>	
	
 	<!-- ############################################################ -->		
	<scriptdef name="isBooleanZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie boolean interpretiert werden kann. -->
		<!-- Es werden Ausdrücke wie null, eins nicht in boolean umgesetzt.
		
		    In boolean umgesetzt werden:
			- Strings 0, 1 
			- Strings true, false
			
			TODO: 
			- Zahlen 0, 1
		-->
			
			
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isboolean" />
		<![CDATA[		   		  
		   var bBooleanValue = null;
		   var bIsBoolean = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   //print("myValueInput='"+myValueInput+"'");		   			
			if(isNumber(myValueInput)){
				//print("boolean liegt als Zahl vor: " + myValueInput);	
				if (myValueInput=='1') {			   
					bBooleanValue = true;
					bIsBoolean = true;
				}else if(myValueInput=='0'){
					bBooleanValue = false;
					bIsBoolean = true;
				}else{
					bBooleanValue = null;
					bIsBoolean = false;
				};
			}else{			
				//print("boolean liegt als String vor: " + myValueInput);	
				if (myValueInput=='true') {			   
				   bBooleanValue = true;
				   bIsBoolean = true;
				}else if(myValueInput=='false') {
					bBooleanValue = false;
					bIsBoolean = true;				
				}else{					
					bIsBoolean = false;
				};			
			}
						
			project.setProperty(attributes.get("valuereturn"), bBooleanValue);
			project.setProperty(attributes.get("isboolean"), bIsBoolean);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			//TODO: Diese Funktion in JSZ-Kernel Bibliotheken packen. 
			//TODO: In einer entsprechenden Scriptdef Funktion nutzen.
			function convertBoolToInt()
			{
				var testBool = true;
				result = (testBool)?1:0;
				alert(result);
			}
		 ]]>
	</scriptdef>
	
	<!-- ############################################################ -->		
	<scriptdef name="isDirectoryZZZ" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   enableJava();
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist Package notwendig
		   importClass(java.io.File);                               //Bei BasisJava darf Package nicht vorneweg stehen.
		   var text = attributes.get("text");
		   //print ("start isDirectoryZZZ for: '" + text +"'");
		   //var fd = new java.io.File(text);
		   var fd = new File(text);
		   var berg = false;
		   if(fd.exists()){
		   if (fd.isDirectory()) {
			   //print(fd.getPath()+" => js true");
		       berg = true;
			} else {
				//print(fd.getPath()+" =>js false");
				berg = false;
			}
			}else{
				//print(fd.getPath()+" =>js not existing!");
			}
			project.setProperty(attributes.get("property"), berg);
			
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
	<scriptdef name="isFileRootJsZZZ" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[
		   enableJava();
		   
		   //Allgemein für Import Statements gilt:
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
		   //                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
		   // import statements. Es funktionieren beide Wege. a) Packagename b) Klassenname
			importClass(Packages.basic.zBasic.ExceptionZZZ);
			importPackage(Packages.basic.zBasic.util.file);
	 
			//#############
			 //#### EINGABE ######	 
			var myFilepath = attributes.get("inputfilepath");
			//print("myFilepath="+myFilepath);
			
			//#### Java, etc.
			var bErg = false;
			var myReturnControl = true;
			var myReturnControlString = "Alles o.k.";
			
			try{
			bErg = FileEasyZZZ.isRoot(myFilepath);
			//print("bErg="+bErg);
			
			}catch(err) {
				bErg = false; //sicher ist sicher....
				myReturnControl = false;
				myReturnControlString = handleError(err);
			}
			
		
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         			
			//#### RÜCKGABE #####
			project.setProperty(attributes.get("returnboolean"), bErg);
			project.setProperty(attributes.get("returncontrol"), myReturnControl);
			project.setProperty(attributes.get("returncontrolstring"), myReturnControlString);			

				
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
					//print("Verwende das alte Rhino unter Java 8");
				}catch(e){
					//print("Verwende Standard JavaScript Engine dieser Java Vesion.");
				}
			}//End function enableJava
			
			function handleError(err){
				//document.getElementById("demo").innerHTML = err.message;
				//Aber: Wir wollen auf ein ExceptionZZZ Objekt zugreifen. Seit Aenderung der Javascript Engine in Nashorn ist dies Unterschiedlich.
				//                                                                                       In Nashorn steht das Objekt direkter zur Verfügung.
					if(err instanceof ExceptionZZZ) {  //So geht das nur mit NASHORN.
						print("ExceptionZZZ Fehler abgefangen (NASHORN)");
						print("err.getMessageLast()="+ err.getMessageLast());  //DIE LÖSUNG MIT NASHORN !!!!
						myReturnControlString = "Error: " + err.getMessageLast();
					}else if(err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO !!!
						print("ExceptionZZZ Fehler abgefangen (RHINO)");
						print("err.javaException.getMessageLast()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
						myReturnControlString = "Error: " + err.javaException.getMessageLast();
					}else{
					   //weitere, unbestimmte Fehler abfangen
					   print("Unbestimmten Fehler abfangen.");
					   var version = java.lang.System.getProperty("java.version");
					   print("JavaVersion: " + version);
					   print("typeof err: "+typeof(err));					   
						if(version.substring(0,3)=="1.8"){
							print ("Javascript Engine: 'Nashorn'");
							print("Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							myReturnControlString = "Error: " + err.message;												
						}else{
							print ("Javascript Engine: 'Rhino'");
							print("err.contructor.name="+err.constructor.name);	//In Rhino wird der Fehler nicht direkt zurückgegeben.			
							if(err.constructor.name=='JavaException'){
								print("Error.name=" + err.name);
								print("Error=" + err);
								print("Error.getCause=" + err.getCause); //Ergebnis: undefined
								//print("Error.getCause()=" + err.getCause());
								print("Error.message: " + err.message);//Ergebnis der Ausgabe: basic.zBasic.ExceptionZZZ: null;
								//print("Error.message(): " + err.message());//Ergebnis: Es wird ein Fehler geworfen 'is not a function, it is "string"
								//print("Error: " + err.getMessageLast());//Ergebnis: Es wird ein Fehler geworfen 'cannot find function getMessageLast in object JavaException
								//print("Error: " + err.getMessageLast);//Ergebnis: dito, kein Unterschied zu getMessageLast()
								print("err.javaException.getMessage()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
								myReturnControlString = "Error: " + err.javaException.getMessage();
							}else{
								print("normaler Fehler.  Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							    myReturnControlString = "Error: " + err.message;
							}									
						}
					}	
				return myReturnControlString;					
			}//End function handleError
	      ]]>
  </scriptdef>
	
	<!-- ########################### -->
	<!-- Todo noch kaputt: Es gibt statt einer direkten JavaScript Lösung einen Lösung über Hilfstarget mit Macrodef -->
	<scriptdef name="isLessThanJsZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der erste Wert kleiner als der 2. Wert ist. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="inputvalue01" />
		<attribute name="inputvalue02" />
		<attribute name="returnboolean" />
		<attribute name="sflagcontrol" />
		<attribute name="returntrace" />
		<![CDATA[		   		  
		   var bReturn = true;	
		   var sScript = "isLessThanJsZZZ";
		   var sTrace = sScript;
		   
		   var myValueInput01 = attributes.get("inputvalue01");
		   var myValueInput02 = attributes.get("inputvalue01");
		   print("InputValue01='"+myInputValue01+"'");		   			
		   print("InputValue02='"+myInputValue02+"'");		   			
			
			//Wertevergleich starten			
			main:{		

				//FGL: 20160122: Code kommt aus einer "compare" Funktio und muss noch angepasst werden.
				//               ABER: ist das mit dem parseInt noch generisch?
				//<!-- returns the same results as Java's compareTo() method: -->
				//<!-- -1 if arg1 < arg2, 0 if arg1 = arg2, 1 if arg1 > arg2 -->
				var val1 = parseInt(attributes.get("arg1"));
				var val2 = parseInt(attributes.get("arg2"));
				var result = (val1 > val2 ? 1 : (val1 < val2 ? -1 : 0));
 						
			}; //end main:	
			project.setProperty(attributes.get("returnboolean"), bReturn);
			project.setProperty(attributes.get("returntrace"), sTrace);
		 ]]>
	</scriptdef>	
	
	<!-- ########################### -->
	<scriptdef name="isSetZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie als gesetzt interpretiert werden kann. -->
		<!-- Es werden Ausdrücke, die ${ } entsprechen als nicht gesetzt angesehen.
		     
		-->
			
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isset" />
		<![CDATA[		   		  
		   var bIsSetValue = null;
		   var bIsSet = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   //print("myValueInput='"+myValueInput+"'");		   			
			
			//Die ersten beiden Zeichen und das letze Zeichen prüfen.
		    var sBeginning = myValueInput.substring(0, 2);
			//print("ermittelter Anfang="+sBeginning);
			
		   enableJava();
		   importPackage(Packages.basic.zBasic.util.datatype.string);	   			  
		   var sEnding = StringZZZ.right(myValueInput,1);
			//print("Per JAZ-Kernel ermitteltes Stringende (aus '" + myValueInput + "'): '" + sEnding +"'");
			   			   
						
			if(sBeginning=="${" && sEnding=="}") {
				bIsSet=false;
			}else{
				bIsSet=true;
				bIsSetValue=myValueInput;
			}
						
			project.setProperty(attributes.get("valuereturn"), bIsSetValue);
			project.setProperty(attributes.get("isset"), bIsSet);
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
		 ]]>
	</scriptdef>	
	
	<!-- ############################################################ -->		
	<scriptdef name="isFilenameRelevantVMD" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   //Überprüft, ob der eingegebenen Dateiname ein vom VMD zu verarbeitender Dateiname ist.
		   //Daraus wird dann ermittelt, ob es sich bei dem Konfigurationseintrag um ein Verzeichnis oder um einen Dateinamen handeln muss.
		   var text = attributes.get("text");
		   var berg=false;
		   print("Starte isFilenameRelevantVMD '" + text + "'");

		   //TODO: So soll man den Dateinamen aus einem String bekommen, per JavaScript.
		   //      Dies ggfs. in JSZ-Kernel uebernehmen
		   //var filename = fullPath.replace(/^.*[\\\/]/, '')
		   
		   //Hier wird aber eine schon vorhandene JAZ-Kernel Methode verwendet.
		   enableJava();
		   importPackage(Packages.basic.zBasic.util.file);
		   
		   //var test = java.lang.System.getProperty("java.class.path");
		   //println("classpath="+test);
		   
		   var sEnding = FileEasyZZZ.getNameEnd(text);
		   print("Per JAZ-Kernel ermittelte Dateiendung (aus '" + text + "'): '" + sEnding +"'");
		   
		   //Hier die für VMD relevanten Dateiendungen erfassen.
		   if(sEnding=="txt"){		   
			berg =true;
		   }
		   if(berg==true){	
			print("Dateiendung '" + sEnding +"' ist fuer das VMD Projekt relevant.");
			}else{
			print("Dateiendung '" + sEnding +"' ist fuer das VMD Projekt NICHT relevant.");
			}
		   project.setProperty(attributes.get("property"), berg);	

		   function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}		   
		 ]]>
	</scriptdef>
		
	<!-- ########################### -->
	 <scriptdef name="stringContainsStringZZZ" language="javascript">
	 <!-- TODO: Diese Funktion in den JSZ-Kernel uebernehmen -->
	 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="text" />
		<attribute name="matchstring" />
		<attribute name="returnboolean" />     
		 <![CDATA[
		   var text = attributes.get("text");
		   var match = attributes.get("matchstring");
		   
		   var bReturn = text.indexOf(match)> -1;
		   
		   project.setProperty(attributes.get("returnboolean"), bReturn);
		 ]]>
	  </scriptdef>
  
	 <!-- ########################### -->
	 <scriptdef name="stringCountStringZZZ" language="javascript">
	 <!-- TODO: Diese Funktion in den JSZ-Kernel uebernehmen -->
	 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="text" />
		<attribute name="matchstring" />
		<attribute name="returninteger" />     
		 <![CDATA[
		   var text = attributes.get("text");
		   var match = attributes.get("matchstring");
			   
		   //Merke: So bindet man per Prototype erzeugte, die Klassen erweiternde Methoden in dieses CDATA-Konstrukt ein.   
		   String.prototype.count = function(lit, cis) {
			//lit is the string to search for ( such as 'ex' ), and 
			//cis is case-insensitivity, defaulted to false, it will allow for choice of case insensitive matches.
			var m = this.toString().match(new RegExp(lit, ((cis) ? "gi" : "g")));
			return (m != null) ? m.length : 0;
		  }
		  
		   var iReturn = text.count(match, false);	   
		   
		   project.setProperty(attributes.get("returninteger"), iReturn);
		 ]]>
	  </scriptdef>
	
	 <!-- ########################### -->
	<scriptdef name="stringEncodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
    <attribute name="returnstring" /> 
	<attribute name="returncontrol" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
		print("Starte stringEncodeJsZZZ");
			  	
       var myString = attributes.get("inputstring");
       print("myString="+myString);
	   
	   var myReturnControl=false;

	   var textEncoded = encodeMyHtml(myString);
	   print("encoded textstring=" + textEncoded);
	  
	   //Feedback, ob etwas geändert worden ist.	  
	   if(textEncoded!=myString){			
			myReturnControl = true;
		};
	   	   	 
       project.setProperty(attributes.get("returnstring"), textEncoded);
	   project.setProperty(attributes.get("returncontrol"), myReturnControl);
	   
	   
	   //TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
  </scriptdef>	
	
	 <!-- ########################### -->
  <scriptdef name="stringExplodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
	<attribute name="inputdelimiter"/>

    <attribute name="returnarraystring" /> 
	<attribute name="returncontrol" /> 
	
    <![CDATA[
		var myString = attributes.get("inputstring");
		var myDelimiter = attributes.get("inputdelimiter") ;
		
		var myArrayReturn = new Array();
		var bReturnControl = true;
		if(myString===undefined){
			//print("myString = undefined");
			bReturnControl = false;
		}else if(myString===''){
			//print("myString = leer");			
			bReturnControl = false;
		}else{
			if(myDelimiter===undefined){
				//print("myDelimiter = 'undefined'");
				myArrayReturn[0]=myString;
				bReturnControl = false;
			}else if(myDelimiter===''){
				//print("myDelimiter = 'leer'");
				myArrayReturn[0]=myString;
				bReturnControl = false;
			}else{	
				var myStringEncoded = encodeMyHtml(myString);
				print("myStringEncoded="+myStringEncoded);
				var myDelimiterEncoded = encodeMyHtml(myDelimiter);
				print("myDelimiterEncoded="+myDelimiterEncoded);
		
				 values = myStringEncoded.split(myDelimiterEncoded);
				 for(i=0; i<values.length; i++) {
					//So wird ein Array künstlich erzeugt.... project.setNewProperty(attributes.get("inputprefix")+i, values[i]);
					print("values[i]="+values[i]);
					myArrayReturn[i]=unescape(values[i]);//Das encoden wieder rueckgaengig machen.
				 }				 		
			}
		}				 
		project.setProperty(attributes.get("returnarraystring"), myArrayReturn);
		project.setProperty(attributes.get("returncontrol"), bReturnControl);
		
		
			//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
	</scriptdef>
	
	<!-- ########################################################### -->
	 <scriptdef name="stringLeftStringZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
	   //print("Starte stringLeftStringZZZ");
	   
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
       //print("matchstring="+match);
	  
	   //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
	   var matchToEncode=match;
	   var matchEncoded = encodeMyHtml(matchToEncode);
	   //print("encoded matchstring=" + matchEncoded);
	   
	   var textToEncode=text;
	   var textEncoded = encodeMyHtml(textToEncode);
	   //print("encoded textstring=" + textEncoded);
       sReturn = getStrLeftStr(textEncoded, matchEncoded);
	   sReturn = unescape(sReturn);
	   //print("sReturn="+sReturn);
	   
       project.setProperty(attributes.get("returnstring"), sReturn);
	   
	   //aus JSZ - Kernel 
	   function getStrLeftStr(sourceStr, keyStr){
		return (sourceStr.indexOf(keyStr) == -1 | keyStr=='') ? '' : sourceStr.split(keyStr)[0];
	  }
		
		//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
  </scriptdef>
	
	  <!-- ########################### -->
	 <scriptdef name="stringRightStringZZZ" language="javascript">
	 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="text" />
		<attribute name="matchstring" />
		<attribute name="returnstring" />     
		 <![CDATA[
		   var text = attributes.get("text");
		   //print("entgegengenommenes Attribut text="+text);
		   var match = attributes.get("matchstring");
		   //print("entgegengenommenes Attribut matchstring="+match);
		   
		    //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
			var matchToEncode=match;
			var matchEncoded =encodeMyHtml(matchToEncode);
			//print("encoded matchstring=" + matchEncoded);
		   		    
			var textToEncode=text;
			var textEncoded=encodeMyHtml(textToEncode);
			//print("encoded textstring=" + textEncoded);
		   
		   sReturn = getStrRightStr(textEncoded, matchEncoded);
		   //print("sReturn="+sReturn);
		   sReturn = unescape(sReturn);
		   //print("sReturn unescaped="+sReturn);
	   
		   project.setProperty(attributes.get("returnstring"), sReturn);
		   
		   //aus JSZ - Kernel 
		   function getStrRightStr(sourceStr, keyStr){
				idx = sourceStr.indexOf(keyStr);
				return (idx == -1 | keyStr=='') ? '' : sourceStr.substr(idx+keyStr.length);
			}
				
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
		 ]]>
	  </scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="stringLeftBackStringZZZ" language="javascript">
   <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
   <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	  var text = attributes.get("text");
	  var match = attributes.get("matchstring");
      //print("matchstring="+match); 
	  
	   //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
	   var matchToEncode=match;
	   var matchEncoded = encodeMyHtml(matchToEncode);
	   //print("encoded matchstring=" + matchEncoded);
	   
	   var textToEncode=text;
	   var textEncoded = encodeMyHtml(textToEncode);
	   //print("encoded textstring=" + textEncoded);
	  
      var sReturn = getStrLeftBackStr(textEncoded, matchEncoded);
	  //print("return vor unescape: getStrLeftBackStr=" + sReturn);
	  sReturn = unescape(sReturn);
      project.setProperty(attributes.get("returnstring"), sReturn);
	   
	//äquivalent zu JSZ - Kernel
	//@LeftBack equivalent, !!! casesensitive
	function getStrLeftBackStr(sourceStr, keyStr){
		arr = sourceStr.split(keyStr);
		arr.pop();		//entfernt das letzte Element aus dem Array
		//arr.shift();		//entfernt das erste Element aus dem Array
		//!! so unterschlaegt man aber keyStr: return (keyStr==null | keyStr=='') ? '' : arr.join();		
		
		var sReturn="";
		if(arr.length>=2){
		for (index = 0; index < arr.length-1; ++index) {
			sReturn=sReturn+arr[index]+keyStr;
		}
		}
		sReturn=sReturn+arr[arr.length-1];
		return sReturn;	
	}
	
	//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //Merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
  ]]>
  </scriptdef>
	
	<!-- ############################################################ -->
	<scriptdef name="stringSubStringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   if(text==''){
		   //print("Leerstring im JS Teil stringSubStringZZZ");
		   project.setProperty(attributes.get("property"), '');
		   }else{
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		   }
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="stringUnencodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
    <attribute name="returnstring" />
    <attribute name="returncontrol" />	
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
	 //TODO: Die Erweiterung endsWithPos in den JSZ - Kernel packen
	 print("Starte stringUnencodeJsZZZ");
	  
	 var myString = attributes.get("inputstring");
     //print("myString="+myString); 
	 var myReturnControl=false;
			  	  
	 var myStringUnencoded=unescape(myString);	  
	 //print("myStringUnencoded =" + myStringUnencoded);
	   
	 //Feedback, ob etwas geändert worden ist.	  
	 if(myStringUnencoded!=myString){			
		myReturnControl = true;
	 };
	   project.setProperty(attributes.get("returncontrol"), myReturnControl);	   	   	 			
       project.setProperty(attributes.get("returnstring"), myStringUnencoded);
     ]]>
  </scriptdef>	

  <!-- ##### Macrodefs, gesammelt in einem Target, das dann von den Untertargets eingebunden werden kann ##### -->
<target name="-initMacrodef">
 
	 <!-- ############## macrodefs ############################ -->
	 <macrodef name="mathMacroZZZ">
		 <!-- Verwende ein Macrodef für allgemeine mathematische operationen -->
		 <!-- Aufrufbeispiel: <math operation="/" operator1="${foo}" operator2="11" result="foooo" when=" ${foo} &lt; ${limit} "/> -->
	   <attribute name="operation"/>
	   <attribute name="operator1"/>
	   <attribute name="operator2"/>
	   <attribute name="result"/>
	   <attribute name="when"/>
	    
		<!-- Merke: Die Tags echo und math arbeiten nur innerhalb des sequential-Tags.
				Darin müssen die 'Variablen' mit @ angesprochen werden.-->
	   <sequential>
		<script language="javascript">
		<![CDATA[
		 // note => use attribute @{when} without ''  !
		 if(eval(@{when})) {    
			 //println("operator1="+@{operator1}+" | operator2="+@{operator2});
			 var tmp = 0;
			 switch ("@{operation}")
			 {
			  case "+" :
			   tmp = parseInt("@{operator1}") + parseInt("@{operator2}");
			   break;
			  case "-" :
			   tmp = parseInt("@{operator1}") - parseInt("@{operator2}");
			   break;
			  case "*" :
			   tmp = parseInt("@{operator1}") * parseInt("@{operator2}");
			   break;
			  case "/" :
			   tmp = parseInt("@{operator1}") / parseInt("@{operator2}");
			   break;
			  case "max" :
			   if(parseInt("@{operator1}") > parseInt("@{operator2}")){
					tmp=1;
				}else{
					tmp=0;
				};
				break;
			 case "min" :
				//Merke: Das 'kleiner Zeichen' kann hier in den Code nicht eingebaut werden. Wird als XML erkannt. Darum Negierung als Notlösung.
				//if(!(parseInt("@{operator1}") > parseInt("@{operator2}"))){
				//Wenn man ein cdata um den script-teil packt, klappt es auch mit den 'kleiner Zeichen'.
				if(parseInt("@{operator1}") < parseInt("@{operator2}")){
					tmp=1;
				}else{
					tmp=0;			
				}
				break;
			 }
			 //println("math result="+tmp);
			 project.setProperty("@{result}", tmp);
		   } else {
				//println("Condition: @{when} false !");
			}
		 ]]>
		</script>
	   </sequential>
	 </macrodef>
	 
	  <!-- probier mal ein macrodef zu verschachteln ... klappt -->
	  <macrodef name="greaterthanMacroZZZ">  
		   <attribute name="resultprop" default="NOT SET"/>
		   <attribute name="arg1" default="NOT SET"/>
		   <attribute name="arg2" default="NOT SET"/>	
		    
		   <!-- Merke: Die Tags echo und math arbeiten nur innerhalb des sequential-Tags.
				Darin müssen die 'Variablen' mit @ angesprochen werden.-->
		  <sequential>
			<!--<echo>-greaterhan: arg1=@{arg1} | arg2=@{arg2}</echo>-->
			<mathMacroZZZ operation="max" operator1="@{arg1}" operator2="@{arg2}" result="resultgth" when="true"/>		
			 <!--<echo>-greaterthan: result=${resultgth}</echo>-->
			 <property name="@{resultprop}" value="${resultgth}" />         
		  </sequential>
		</macrodef>
		
		<!-- probier mal ein macrodef zu verschachteln ... klappt -->
	  <macrodef name="lessthanMacroZZZ">  
		   <attribute name="resultprop" default="NOT SET"/>
		   <attribute name="arg1" default="NOT SET"/>
		   <attribute name="arg2" default="NOT SET"/>	
		    
		   <!-- Merke: Die Tags echo und math arbeiten nur innerhalb des sequential-Tags.
				Darin müssen die 'Variablen' mit @ angesprochen werden.-->
		  <sequential>
			<echo>-lessthanMacroZZZ: arg1=@{arg1} | arg2=@{arg2}</echo>
			<mathMacroZZZ operation="min" operator1="@{arg1}" operator2="@{arg2}" result="resultgth" when="true"/>		
			 <echo>-lessthanMacroZZZ: result=${resultgth}</echo>		 
			 <property name="@{resultprop}" value="${resultgth}" />         
		  </sequential>
		</macrodef>
 
 </target>  
	   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <!-- ################################################################################# -->
  <target name="compile" depends="-declaration, -init,-FglRepository_Main,-FglVmd_Main">
  <!-- <target name="compile" depends="-declaration, -init,-FglRepository_Main">--><!-- Einzeln testen --> 
  
   <!-- Die einzelnen internen Targets / Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
   
	<!-- WIRD NICHT BENÖTIGT -->
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
	
	
  	<!-- ### Behandle Uebergabeparameter von den aufrufenden Batches / Eclipse ### -->
	<!-- Es soll gelten, dass die Werte per Batchuebergabe wichtiger sind als die Werte per Umgebungsvariable! -->
	<!-- Alternative 1: Werte entgegennehmen, die an das Ant Script per -Dvmd= bzw. -D%* uebergeben wurden. Letzeres leitet alle Argumente einer Batch an das Ant-Script weiter.-->
	<!-- Alternative 2: Werte entgegennehmen, die per Batch in eine Umgebungsvariable geschrieben wurden. -->
	
	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
		
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
	<!-- controlstring wird noch nicht verwendet, sollte aber ggfs. zur weiteren Steuerung genutzt werden -->
	<property name="controlstring" value="${nothing}"/>
    <echo message="Wert fuer controlstring= ${controlstring}"/>
	<echo>VMD CONSTROLSTRING= ${env.controlstring}</echo>
					
	<property name="vmd" value="${nothing}"/><!--Merke: In der if-Abfrage <isset property="..."></isset> funktioniert nicht immer, darum mit einer eigenen Methode prüfen -->
    <echo message="Wert fuer vmd=${vmd}"/>
	<isSetZZZ valueinput="${vmd}" valuereturn="myIsSetValue" isset="myValueIsSet" /><!-- anwenden der oben definierten scriptdef funktion -->
	<isBooleanZZZ valueinput="${myValueIsSet}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<ac:if>
	 <equals arg1="${myBooleanValue}" arg2="true" />     
      <ac:then>
		<echo>VMD aus Uebergabeparameter= ${vmd}</echo>
		<fl:let>myVmdUsed::="${vmd}"</fl:let>		
	  </ac:then>
	  <ac:else>
		<echo>VMD aus Umgebungsvariable= ${env.VMD}</echo>
		<fl:let>myVmdUsed::="${env.VMD}"</fl:let><!-- Merke: Die Pfadangaben in der Batch sind mit Slash und nicht mit Backslash -->
	  </ac:else>
	 </ac:if>
	
	<property name="host" value="${nothing}"/><!--Merke: In der if-Abfrage <isset property="..."></isset> funktioniert nicht immer, darum mit einer eigenen Methode prüfen -->
    <echo message="Wert fuer host= ${host}"/>	
  	<isSetZZZ valueinput="${host}" valuereturn="myIsSetValue" isset="myValueIsSet" /><!-- anwenden der oben definierten scriptdef funktion -->
	<isBooleanZZZ valueinput="${myValueIsSet}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<ac:if>
	 <equals arg1="${myBooleanValue}" arg2="true" />
      <ac:then>
		<echo>HOST aus Uebergabeparameter= ${host}</echo>
		<fl:let>myHostUsed::="${host}"</fl:let>
	  </ac:then>
	  <ac:else>
		<echo>HOST aus Umgebungsvariable = ${env.host}</echo>
		<fl:let>myHostUsed::="${env.host}"</fl:let>
	  </ac:else>
	 </ac:if>
	
  	
<!-- 	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo> -->

  	<!-- Das Betriebssystem wird ausschliesslich in der Batch ermittelt. -->
	<echo>VMD_OS= ${env.VMD_OS}</echo>
	<property name="project.vmd.os" value="${env.VMD_OS}" />
	
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur, 
	        TODO diese Werte in projekt-Konfigurationsdatei uebernehmen, 
	        nachdem sie in den "...checProperties..." Methoden aufgenommen wurden und dort als Fallback mit dem defaultwert versehen wurden. -->
  <property name="project.vmd.dirRepositoryLib" value="lib" />
  <property name="project.vmd.dirRepositorySrc" value="src" />
  <property name="project.vmd.dirRepositoryMisc" value="misc" />
  <property name="project.vmd.dirRepositoryTest" value="test" />
  <property name="project.vmd.dirRepositoryArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  
  <!-- Hier wird der ggfs. übergebene Projektdateiname durch eine Hostspezifische Erweiterung uebersteuert. -->
  <!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET-Befehl und ENTER --> 	  
  <fl:let>vmdLocalFile ::= "project_${env.COMPUTERNAME}_vmd.properties"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
  <!-- <echo>Name der lokalen Steuerungsdatei waere: ${vmdLocalFile}</echo> -->
	
	<!-- Hole den Pfad aus der $vmd - Property, die in der Batch uebergeben wurde -->
	<!-- Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->	
	
	<!-- Konvertiere den Pfad in Windows-Format -->
	<path id="pathToConfigFile">
      <pathelement location="${myVmdUsed}"/>
    </path>
    <pathconvert targetos="windows" property="project.path.fileconfig" refid="pathToConfigFile">
    </pathconvert>
    <echo>Normierter Pfad (Windows Style)= ${project.path.fileconfig}</echo>
	
	<fl:let>vmdUsed::='${project.path.fileconfig}'</fl:let>
	<fl:let>sfileadir ::= split('${vmdUsed}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die Groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																													
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>					
	 <echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<!-- <fl:let>xtractedvalue ::= split('${vmd}','/')[${index}];  -->
	<fl:let>xtractedvalue ::= split('${vmdUsed}','\\\\')[${index}];  
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	 <echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!-- Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftStringZZZ' uebergeben. -->
	<!-- <fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo>  -->
	<fl:let>xtractedvalueTemp ::= #{"format('\\%s', xtractedvalue)"}	</fl:let>
	<!-- <fl:let>xtractedvalueTemp ::= #{"format('/%s', xtractedvalue)"}</fl:let> -->
	<stringLeftStringZZZ text="${vmdUsed}" matchstring="${xtractedvalueTemp}" returnstring="myPath" />
	<echo>Der Pfad ist: '${myPath}'</echo>

  <fl:let>vmdLocalFilePath ::= "${myPath}\\project_${env.COMPUTERNAME}_vmd.properties"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
  <echo>Pruefe Existenz lokaler Uebersteuerungs-Projektdatei: ${vmdLocalFilePath}</echo>
  
  <fl:choose>
		<fl:when test=" '${vmdLocalFilePath}'.tofile.exists == true ">
			<echo>Lokale Projektdatei existiert: ${vmdLocalFilePath}</echo>
			<fl:let>vmdUsed::='${vmdLocalFilePath}'</fl:let>
		</fl:when>
		<otherwise>
			<echo>Lokale Projektdatei existiert NICHT: ${vmdLocalFilePath} verwende Standard ${myPath}\\project_vmd.properties</echo>
			<fl:let>vmdUsed::="${myPath}\\project_vmd.properties"</fl:let>
		</otherwise>
	</fl:choose>
			
  <echo>Verwende Projektdatei: ${vmdUsed}</echo>
  <property name="projekt.vmd.configPath" value="${vmdUsed}" />
  
  <!-- Teste mal, ob ein defaultwert durch loadproperties ueberschrieben werden kann -->
  <property name="projekt.useDefaultWhenMissing" value="false" />
  
	<!-- ######## Anwenden, der lokalen Konfiguration -->
	<echo>Verwendet Projektkonfiguration: ${projekt.vmd.configPath}</echo>
	
	<!-- Prüfe, ob die angegebenen Datei vorhanden ist -->	 
	 <fl:choose>
		<fl:when test=" '${projekt.vmd.configPath}'.tofile.exists == true ">
			<echo>Ggfs. in Projektdatei angebene/zu verwendende Projektkonfiguration existiert: ${projekt.vmd.configPath}</echo>
			
			<loadproperties>
				<file file="${projekt.vmd.configPath}"/>
			</loadproperties> 	 
			<echo>test1 hat den Wert: ${test1}</echo>
	
			<echo>project.vmd.dirRepositoryPath hat den Wert: ${project.vmd.dirRepositoryPath}</echo> 				
			<echo>project.vmd.operation_mode hat den Wert: ${project.vmd.operation_mode}</echo>	
			<echo>project.vmd.dirPathClientFgl hat den Wert: ${project.vmd.dirPathClientFgl}</echo>	
			<echo>project.vmd.os hat den Wert: ${project.vmd.os}</echo>
			
			<!-- TODO GOON: Prüfe die Controldateien auf Existenz. -->
			<!-- TODO : Prüfe die Controldatei auf Validität. -->
		</fl:when>
		<otherwise>
			<echo>Ggfs. in Projektdatei angebene/zu verwendende Projektkonfiguration existiert NICHT: ${projekt.vmd.configPath}</echo>
			<fl:fail message="In Projektdatei angegebene Projektkonfiguration existiert NICHT: ${projekt.vmd.configPath}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
		</otherwise>
	</fl:choose>
	</target>
  
  <!-- ############################################################################## -->
  <target name="-init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${project.vmd.dirRepositoryArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${project.vmd.dirRepositoryMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>


<!-- ################################################################################# -->  
<target name="-FglRepository_Main">	
	<!-- Mache Backup des Repositories. -->
	
	<!-- Pruefe die Projekt-Properites -->
	<antcallback target="-FglCheckProjectPropertiesRepository" return="conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />
		
	<!-- Sind alle notwendigen Konfigurations-Properties vorhanden, weitermachen -->
	<!-- TODO GOON, noch kaputt: Hier wird 'Hinweis: <#!!FGLUNDEFINED!!#>' auf der Konsole ausgegeben, es muss also eine Target <arrayEchoZZZ> erstellt werden.
                                                    welches bei einem leeren Array (hier: dem leeren Fehlerarray) nix ausgibt und ansonsten die Fehler Zeile für Zeile ausgeben würde.	-->
	<fl:echo>myGoon hat den Wert: ${myGoon}</fl:echo>
	<ac:if>
		<ac:not>
			<ac:equals arg1="${myaError}" arg2="" />			
		</ac:not>
		<ac:then>
			<fl:echo>Hinweis: ${myaError}</fl:echo>
		</ac:then>
		<ac:else>
		</ac:else>
	</ac:if>
		<ac:if>
			<ac:equals arg1="${myGoon}" arg2="false" />
			<ac:then>
				<fl:echo>NICHT alle notwendigen Konfigurations-Properties vorhanden. Fahre NICHT fort.</fl:echo>
			</ac:then>
			<ac:else>
				<fl:echo>Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
			
				<!-- übernimm Projekt KonfigurationsPROPERTIES in hier verwendete KonfigurationsVARIABLEN -->
				<fl:let>conf.dirRepositoryArchive ::= "${project.vmd.dirRepositoryArchive}"</fl:let>
				<fl:let>conf.dirRepositoryMisc ::= "${project.vmd.dirRepositoryMisc}"</fl:let>
				
			<!-- ######### CLIENT ############################################################################## -->
			
			<!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
			<!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
			<!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
			 
			
				

		<!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
		<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
				dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<fl:let>src.dirFglClientPath::="${conf.dirPathClientFgl}" </fl:let>
	
	<!-- Die Ermittlung des Dateinamens, unbhaengig von Client oder Host.-->
	<!-- Merke: Normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
	<echo>VMD_OS=${env.VMD_OS}</echo>
	<fl:let>osUsed::='${env.VMD_OS}'</fl:let>		
	<fl:let>pathClientUsed::='${conf.dirPathClientFgl}'</fl:let>		
	<antcallback target="-computeFilenameVMD" return="returnFilename">
				<param name="osUsed" value="${osUsed}"/>
				<param name="pathClientUsed" value="${pathClientUsed}"/>					
	</antcallback>		
	<echo>Errechneter wert der VMD Datei=${returnFilename}</echo>
	<fl:let>src.dirFglClientFileName::="${returnFilename}"</fl:let><!-- Merke: Der Computername wird nicht extra gesetzte. Er kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	<fl:let>dest.dirRepositoryVmdPath::="${conf.dirRepositoryPath}"</fl:let>
	<fl:let>dest.dirRepositoryVmdBackupPath::="${dest.dirRepositoryVmdPath}Backups"</fl:let><!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
		  
	<!-- ########### Mache Backup des Repositories. ######################################################### -->
	<antcallback target="-FglRepositoryBackup" return="returnControl">
			<param name="targetDirectory" value="${dest.dirRepositoryVmdBackupPath}"/>
	</antcallback>								
	<ac:if><!-- returnControl prüfen: Backup des Repositories erfolgreich oder nicht -->
		<ac:equals arg1="${returnControl}" arg2="true" />
		<ac:then>
			<fl:echo>FglRepositoryBackup erfolgreich. Fahre fort.</fl:echo> 
				
			<antcallback target="-FglRepositoryCopyClient2archive" return="returnControl">
			<param name="sourceDirectory" value="${src.dirFglClientPath}"/>
			<param name="targetDirectory" value="${dest.dirRepositoryVmdPath}"/>
			<param name="fileNameVmd" value="${src.dirFglClientFileName}"/>
		</antcallback>
		</ac:then>		
		<ac:else>													
			<fl:echo>FglRepositoryBackup NICHT erfolgreich. Ueberspringe das Kopieren.</fl:echo> 
		</ac:else>
	</ac:if><!-- End if: Backup des Repositories erfolgreich oder nicht -->
	</ac:else>
	</ac:if>
</target>

<target name="-FglCheckProjectPropertiesRepository">
	
	<!-- Pruefe die Projekt-Properites fuer den Repository-Zweig -->
	
	<!-- Pruefe die allgemeinen Projekt-Properties -->
	<antcallback target="-FglCheckProjectProperties" return="conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<fl:let>myDirRepositoryPath ::= "${conf.dirRepositoryPath}" </fl:let>
	<fl:let>myDirPathClientFgl ::= "${conf.dirPathClientFgl}" </fl:let>
	<fl:let>myOs ::= "${conf.os}" </fl:let>
	<echo>myDirRepositoryPath hat den Wert: "${myDirRepositoryPath}"</echo>
	<echo>myDirPathClientFgl hat den Wert: "${myDirPathClientFgl}"</echo>
	<echo>myOs hat den Wert: "${myOs}"</echo>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />	

	<!-- Rueckgabebwerte -->
	<ac:var name="conf.dirRepositoryPath" value="${myDirRepositoryPath}" />
	<ac:var name="conf.dirPathClientFgl" value="${myDirPathClientFgl}" />
	<ac:var name="conf.os" value="${myOs}" />
	<ac:var name="returnControl" value="${myGoon}" />
	<arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
</target>

<target name="-FglCheckProjectProperties">

<!-- Prüfe die Existenz der notwendigen Konfigurations-Properties -->
	<!-- Merke: Oben (in Declaration) werden die project - Parameter ausgelesen und hier in conf - Parameter gepackt woraus wiederum die speziellen dest/src Parameter ggfs. geholt werden.-->
	<!-- Merke: Da solche Parameter dann für jedes Unter-Main-Target individuell sein kann, darf es nicht in eine Property gespeiert werden, sondern muss in eine Variable gepackt werden.-->	
	<fl:let>myGoon ::= true</fl:let>
	<arrayInitJsZZZ isize="0" arrayreturn="myaError"/>	
	<ac:if>
		<ac:and>
			<isset property="project.vmd.dirRepositoryPath"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.dirRepositoryPath}" arg2="\${project.vmd.dirRepositoryPath}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>			
			<fl:echo>project.vmd.dirRepositoryPath hat den Wert: '${project.vmd.dirRepositoryPath}'</fl:echo>			
			<fl:let>myDirRepositoryPath ::= "${project.vmd.dirRepositoryPath}" </fl:let> 			
		</ac:then>
		<ac:else><!-- TODO GOON: Default nur verwenden, wenn project.useDefault konfiguriert ist -->
			<fl:let>myDirRepositoryPath ::= "C:/1fgl/repository/Projekt_VMD"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.dirRepositoryPath' verwende als Standard '${myDirRepositoryPath}'." arrayreturn="myaError" sflagcontrol="" />			
		</ac:else>
	</ac:if>
	<ac:if>
		<ac:and>
			<isset property="project.vmd.dirPathClientFgl"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.dirPathClientFgl}" arg2="\${project.vmd.dirPathClientFgl}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>
			<fl:echo>project.vmd.dirPathClientFgl hat den Wert: '${project.vmd.dirPathClientFgl}'</fl:echo>			
			<fl:let>myDirPathClientFgl ::="${project.vmd.dirPathClientFgl}"</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myDirPathClientFgl ::= "c:/1fgl/client"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.dirPathClientFgl' verwende als Standard '${myDirPathClientFgl}'." arrayreturn="myaError" sflagcontrol="" />
		</ac:else>
	</ac:if>
	<ac:if>
		<ac:and>
			<isset property="project.vmd.os"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.os}" arg2="\${project.vmd.os}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>						
			<fl:echo>project.vmd.os hat den Wert: '${project.vmd.os}'</fl:echo>						
			<fl:let>myOs ::="${project.vmd.os}"</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myGoon ::= false</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.os'" arrayreturn="myaError" sflagcontrol="" />
		</ac:else>
	</ac:if>
	
	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="conf.dirRepositoryPath" value="${myDirRepositoryPath}" />
	<ac:var name="conf.dirPathClientFgl" value="${myDirPathClientFgl}" />
	<ac:var name="conf.os" value="${myOs}" />
	<ac:var name="returnControl" value="${myGoon}" />
	<arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->		
</target>
     

<target name="-FglRepositoryBackup">	
	<fl:let>myTargetDirectory ::= "${targetDirectory}"</fl:let>
	<echo>Creating Backup: ${myTargetDirectory}</echo>
	
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade, dabei gehe ich davon aus, dass alle Unterverzeichnisse automtisch erstellt werden. -->
	<mkdir dir="//${myTargetDirectory}"/>

	<echo>a) VmdRepository Archive:</echo>
	<echo>project.vmd.dirRepositoryArchive = "${project.vmd.dirRepositoryArchive}"</echo>
	<echo>conf.dirRepositoryArchive = "${conf.dirRepositoryArchive}"</echo>
	<echo>myTargetDirectory = "${myTargetDirectory}"</echo>
	
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${myTargetDirectory}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${conf.dirRepositoryArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${project.vmd.dirRepositoryArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind.
               Merke: Dabei gilt, das diese Dateien über alle Rechner identischen Inhalt haben sollen.-->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${myTargetDirectory}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${conf.dirRepositoryMisc}"
	/>
	<fl:let>myReturnControl ::= true</fl:let>
	<fl:let>returnControl ::= ${myReturnControl}</fl:let>
</target>
		
<target name="-FglRepositoryCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->	
	<echo>Pushing Files to Repository:</echo>
	<fl:let>mySourceDirectory ::= "${sourceDirectory}"</fl:let>
	<fl:let>myTargetDirectory ::= "${targetDirectory}"</fl:let>
	<fl:let>myFileNameVmd ::= "${fileNameVmd}"</fl:let>
		
	<echo>a) VMD File:</echo>
	<!-- <echo>conf.dirRepositoryArchive = "${conf.dirRepositoryArchive}"</echo>
	<echo>mySourceDirectory = "${mySourceDirectory}"</echo>
	<echo>myTargetDirectory = "${myTargetDirectory}"</echo>
	<echo>myFileNameVmd = "${myFileNameVmd}"</echo> -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${conf.dirRepositoryArchive}" overwrite="false"  preservelastmodified="true">
		<fileset dir="//${mySourceDirectory}">	  
	    <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<!-- <include name="${src.dirFglClientFileName}" /> -->	
		<include name="${myFileNameVmd}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${myTargetDirectory}/${conf.dirRepositoryMisc}" overwrite="false"  preservelastmodified="true"> 	
	  <fileset dir="//${mySourceDirectory}">
		<exclude name="${myFileNameVmd}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="-FglVmd_Main">
	<fl:let>sScript::='-FglVmd_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
	<echo>######################################</echo>
	<!-- Fuehre die in der Steuereungsdatei definierten Aktionen aus. -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	<!-- Z.B. Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	
	<!-- Pruefe die Projekt-Properites -->
	<antcallback target="-FglCheckProjectPropertiesVmd" return="conf.dirRepositoryVmdBat,conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,conf.operation_mode,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />
		
	<!-- Sind alle notwendigen Konfigurations-Properties vorhanden, weitermachen -->
	<fl:echo>myGoon hat den Wert: ${myGoon}</fl:echo>
	<ac:if>
		<ac:not>
			<ac:equals arg1="${myaError}" arg2="" />			
		</ac:not>
		<ac:then>
			<!-- TODO IDEE : mache ein Target <arrayEchoZZZ>, in dem die Elemente eines Arrays Zeile für Zeile ausgegeben werden -->
			<fl:echo>Hinweis: ${myaError}</fl:echo>
		</ac:then>
		<ac:else>
		</ac:else>
	</ac:if>
	<ac:if>
		<ac:equals arg1="${myGoon}" arg2="false" />
		<ac:then>
			<fl:echo>NICHT alle notwendigen Konfigurations-Properties vorhanden. Fahre NICHT fort.</fl:echo>
		</ac:then>
		<ac:else>
			<fl:echo>Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
			
			<!-- Konfiguriere sonstige Variablen -->						
			<!-- ... müssten normalerweise stehen in -FglCheckProjectPropertiesVmd ... -->
			<!-- wie z.B. <fl:let>conf.dirRepositoryVmdBat ::= "${project.vmd.dirRepositoryBat}" </fl:let> -->	
						
		
			<!-- Falls der Test - Modus angestellt ist, verwende die Test-Konfigurationsdatei und rechne den Dateinamen nicht aus.-->		
			<!-- <echo>conf.operation_mode='${conf.operation_mode}'</echo> -->
			<ac:if>
				<ac:equals arg1="${conf.operation_mode}" arg2="test" />
				<ac:then>
					<fl:echo>testmodus</fl:echo> 							 			
					<fl:let>conf.copyLocalFileName ::= "test_vmd.properties"</fl:let>
				</ac:then>		
				<ac:else>													
					<fl:echo>echtmodus</fl:echo>
								
					<!-- 1. Rechne den Dateinamen aus -->
					<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
					dies passiert hier durch flaka´s install-property handler task -->
					<fl:install-property-handler />
					<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->

					<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
					<fl:let>conf.copyLocalFileName ::= "Fgl${env.COMPUTERNAME}_copy_local.properties"</fl:let>
				</ac:else>
			</ac:if><!-- Testmodus oder nicht: Konfigurationsdateinamen ausrechnen -->

			<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
			<!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
			<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
			<echo>Copy files general, by property file:</echo>
			<echo>${conf.copyLocalFilePath}</echo>

			<!-- Arbeite die Steuerungsdatei ab -->					
			<antcallback target="-FglFileControlController_Main" return="returnControlString, returnControl">
				<param name="localFileControlPath" value="${conf.copyLocalFilePath}"/>												
			</antcallback>      
			<fl:echo>Ergebnis des FileControll Controllers: ${returnControlString}</fl:echo>		
										
		</ac:else>	<!-- Alle Projekt-Konfigurationsparameter sind vorhanden -->
	</ac:if>	<!-- Alle Projekt-Konfigurationsparameter sind vorhanden -->	
	
	
		</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>			
	
</target>

<target name="-FglCheckProjectPropertiesVmd">
	
	<!-- Pruefe die Projekt-Properties fuer den Repository-Zweig -->
	
	<!-- Pruefe die allgemeinen Projekt-Properties -->
	<antcallback target="-FglCheckProjectProperties" return="conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<fl:let>myDirRepositoryPath ::= "${conf.dirRepositoryPath}" </fl:let>
	<fl:let>myDirPathClientFgl ::= "${conf.dirPathClientFgl}" </fl:let>
	<fl:let>myOs ::= "${conf.os}" </fl:let>
	<echo>myDirRepositoryPath hat den Wert: "${myDirRepositoryPath}"</echo>
	<echo>myDirPathClientFgl hat den Wert: "${myDirPathClientFgl}"</echo>
	<echo>myOs hat den Wert: "${myOs}"</echo>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />	

	<!--prüfe die speziellen Projekt-Properites -->		
	<ac:if>
		<ac:and>
			<isset property="project.vmd.operation_mode"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.operation_mode}" arg2="\${project.vmd.operation_mode}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>
			<fl:echo>project.vmd.operation_mode hat den Wert: '${project.vmd.operation_mode}'</fl:echo>	
			<fl:let>myOperation_mode ::= "${project.vmd.operation_mode}"</fl:let>			
		</ac:then>
		<ac:else>			
			<fl:let>myOperation_mode ::= "prod"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.operation_mode' verwende als Standard '${myOperation_mode}'." arrayreturn="myaError" sflagcontrol="" />
		</ac:else>
	</ac:if>
	
	<ac:if>
		<ac:and>
			<isset property="project.vmd.dirRepositoryBat"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.dirRepositoryBat}" arg2="\${project.vmd.dirRepositoryBat}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>
			<fl:echo>project.vmd.dirRepositoryBat hat den Wert: '${project.vmd.dirRepositoryBat}'</fl:echo>	
			<fl:let>myDirRepositoryBat ::= "${project.vmd.dirRepositoryBat}"</fl:let>			
		</ac:then>
		<ac:else>					
			<fl:let>myDirRepositoryBat ::= "bat"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.dirRepositoryBat' verwende als Standard '${myDirRepositoryBat}'." arrayreturn="myaError" sflagcontrol="" />
		</ac:else>
	</ac:if>
	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="conf.dirRepositoryVmdBat" value="${myDirRepositoryBat}" />
	<ac:var name="conf.dirRepositoryPath" value="${myDirRepositoryPath}" />
	<ac:var name="conf.dirPathClientFgl" value="${myDirPathClientFgl}" />
	<ac:var name="conf.os" value="${myOs}" />
	<ac:var name="conf.operation_mode" value="${myOperation_mode}" />
	<ac:var name="returnControl" value="${myGoon}" />
	<arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
</target>

<!-- ######################################################################### -->
<target name="-FglFileControlController_Main">
	<fl:let>sScript::='-FglFileControlController_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	<fl:let>myLocalFileControlPath ::= "${localFileControlPath}"</fl:let>

	
	<!-- Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<fl:when test=" '${myLocalFileControlPath}'.tofile.exists == true ">
					<echo>Datei existiert: ${myLocalFileControlPath}</echo>
						
					<!-- 1a. Lies den Inhalt der Datei als Properties-Datei ein. -->	
					<!--<loadproperties>
						<file file="${conf.copyGeneralFilePath}"/>
						</loadproperties> 
						<echo>test1 hat den Wert: ${test1}</echo> -->
		
		
					<!-- 2. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
					<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
					<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
		
					<!-- Test: Gib den Inhalt der Datei aus -->
					<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
					<!-- <echo>${myfile}</echo> -->


					<!-- ################################################################ -->
					<!-- Die "Schemata" Untersuchung machen. Dazu die Steuerungsdatei Zeile für Zeile auswerten, bis zum nächsten Eintrag, der ein anderes Schema ist.
						Für das Analysierte Schema den passenden Schema-Controller aufrufen. Orientiere dich bei den Schema-Namen an den DOS Befehlen.						
						Weitere Schema Befehle sind vmd://, copy://, del://. zip://-->
										
					<!-- 1b. Werte den Inhalt der Datei zeilenweise aus -->
					<!-- Beispiel für eine Schleife in ant, und wie man mit sequentials und dem @ Parameter darin arbeiten kann.  -->			
					<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
					<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
						<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
							<file file="${myLocalFileControlPath}" />
						</tokens>
						<sequential>
							<fl:let>myCase ::= "neue Zeile"</fl:let><!-- für jede Zeile wird der mögliche Verarbeitungsfall neu ermittelt -->
							
							<var name="myLine" value="@{line}" />
							<!-- <fl:echo>Zeile:'${myLine}'</fl:echo> -->					
							
							<var name="line.length" unset="true" />
							<length string="@{line}" property="line.length" /><!-- ueber das length-Tag wird eine property gefüllt, die lediglich so aussieht als wäre sie eine Methode des line-Objekts -->							
							<!-- <fl:echo>Zeile Länge: ${line.length}</fl:echo> -->
							
							<ac:if>
								<ac:equals arg1="${line.length}" arg2="0" />
							    <ac:then>
									<fl:let>myLineTrimmed::=''</fl:let>
								</ac:then>
								<ac:else>
									<fl:let>myLineTrimmed::=trim("@{line}")</fl:let>
								</ac:else>
							</ac:if>													
							<!-- <fl:echo>Zeile trimmed:'${myLineTrimmed}'</fl:echo> 
							<var name="myLineTrimmed.length" unset="true" />
							<length string="${myLineTrimmed}" property="myLineTrimmed.length" />
							<fl:echo>Zeile trimmed Länge ${myLineTrimmed.length}</fl:echo> -->
							
							<ac:if>								
								<ac:equals arg1="${myLineTrimmed}" arg2="" />								
								<ac:then>
									<fl:echo>Leerzeile, wird übersprungen...</fl:echo>
								</ac:then>
								<ac:else>												
									<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->																
									<stringSubStringZZZ text="${myLineTrimmed}" start="0" end="1" property="subtext" /> <!-- anwenden der oben definierten scriptdef funktion substring -->
									<!-- <fl:echo message="subtext = ${subtext}" /> -->
									<ac:if>
										<ac:equals arg1="${subtext}" arg2="#" />
										<ac:then>
											<!-- <fl:echo>Kommentarzeile, wird uebersprungen...</fl:echo> -->
										</ac:then>
										<ac:else>
											<fl:echo>zu verarbeitende Zeile:'${myLineTrimmed}'</fl:echo>																																																							
											<!-- <fl:echo>1. myStringCurrent.Schema:'${myStringCurrent.Schema}'</fl:echo> -->
											<antcallback target="-FglSchemaController_Analyzer" return="returnString, returnControl,returnString.Schema,returnControl.SchemaChanged,linea.UnSchema">
												<param name="lineCurrent" value="${myLineTrimmed}" />
												<param name="stringCurrent.Schema" value="${myStringCurrent.Schema}"/>
												<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
											</antcallback>
																																
											<!-- Nach dem Untercontrolleraufruf, oder ohne Untercontrolleraufruf: Fülle linea.Schema als Kopie von lineaCurrent.Schema -->
												<!--<fl:echo>2a. returnString.Schema:'${returnString.Schema}'</fl:echo>												
												<fl:echo>2b. myStringCurrent.Schema:'${myStringCurrent.Schema}'</fl:echo>
												<fl:echo>2c. linea.Schema</fl:echo>
												<arrayDebugJsZZZ arrayinput="${linea.Schema}" ilevel="1"/>
												<fl:echo>2d. myLineaCurrent.Schema</fl:echo>
												<arrayDebugJsZZZ arrayinput="${myLineaCurrent.Schema}" ilevel="1"/>												
												<fl:echo>2e. returnControl.Schema: '${returnControl.Schema}</fl:echo> -->
											
											<!-- Falls der Controller meint returnControl.Schema==true, dann hat das Schema gewechselt und damit müssen diese Anweisungen ausgeführt werden. -->																						
												<isBooleanZZZ valueinput="${returnControl.SchemaChanged}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
												<ac:if>
												  <equals arg1="${myBooleanValue}" arg2="true" />
												  <ac:then>		
													<echo>Schemawechsel hat stattgefunden. Altes Schema ist: '${myStringCurrent.Schema}'</echo>
													
													<!-- Aufruf des SchemaControllers, der auf die Untercrontroller verteilt -->
													<fl:echo>AUFRUF DES SCHEMA-CONTROLLERS BEI SCHEMA-WECHSEL</fl:echo>
													<antcallback target="-FglSchemaController_Controller" return="returnControlString, returnControl">
														<param name="stringCurrent.Schema" value="${myStringCurrent.Schema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
														<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
													</antcallback>																										
												  </ac:then>
												  <ac:else>
													<echo>Noch hat kein Schemawechsel stattgefunden.</echo>													
												  </ac:else>
												</ac:if>
																								
												<fl:let>myStringCurrent.Schema::='${returnString.Schema}'</fl:let><!-- uebernimm das zurueckgebene Schema als neues Schema -->												
												<!-- <echo>myStringCurrent.Schema = '${myStringCurrent.Schema}'</echo> -->													 
												<arrayCopyJsZZZ arrayinput="${linea.UnSchema}" arrayreturn="myLineaCurrent.UnSchema" sflagcontrol="" /><!-- uebernimm das Zeilenarray, ggfs. als neues Schema -->												
										</ac:else>	
									</ac:if><!-- end if <ac:equals arg1="${subtext}" arg2="#" /> -->
								</ac:else>
							</ac:if><!-- end if <ac:equals arg1="${line.length}" arg2="0" /> -->
						</sequential>
					</for><!-- end for param="line"> -->	

					<!-- Wenn keine Zeilen mehr zu verarbeiten sind, das letzte Array, des letzen Schemas noch abarbeiten, durch den passenden Funktionsaufruf -->								
					<fl:echo>AUFRUF DES ABSCHLIESSENDEN SCHEMA-CONTROLLERS</fl:echo>
					<!--<fl:echo>2f. Verabeite das letze Array, fuer das Schema: '${myStringCurrent.Schema}</fl:echo>-->
					<!--<arrayDebugJsZZZ arrayinput="${myLineaCurrent.UnSchema}" ilevel="1"/>-->
					<antcallback target="-FglSchemaController_Controller" return="returnControlString, returnControl">
						<param name="stringCurrent.Schema" value="${myStringCurrent.Schema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
						<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
					</antcallback>										
					
					<!-- TODO: Die Meldungen aus den aufgerufenen Unterfunktionen zurueckgeben und nicht blos hier alles auf supergut setzen. -->
					<ac:var name="myReturnControl" value="${returnControl}" />
					<ac:var name="myReturnControlString" value="${returnControlString}"/>																					
				</fl:when><!-- Existiert die Konfigurationsdatei für das lokale Ausführen -->
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
					<ac:var name="myReturnControl" value="false" />
					<ac:var name="myReturnControlString" value="Konfigurations-Datei existiert NICHT: ${myLocalFileControlPath}"/>	
				</otherwise>
			</fl:choose>
			
			
			
			</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>			
			
			<!-- Rueckgabebwerte -->
			<ac:var name="returnControl" value="${myReturnControl}" />
			<ac:var name="returnControlString" value="${myReturnControlString}" />
			<!-- <arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="srcaTotal.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
			<!-- <arrayCopyJsZZZ arrayinput="${mySrcaTotal.filename}" arrayreturn="srcaTotal.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
			<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filedir}" arrayreturn="destaTotal.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
			<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>

<target name="-FglSchemaController_Analyzer">
	<fl:let>myLineNextSchema::="${lineCurrent}"</fl:let>
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />	
	<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.Schema}" ilevel="1"/> -->
	
	<!-- Prüfe, ob eine Zeile ueberhaupt korrekt uebergeben wurde -->
	<ac:if>
		<ac:equals arg1="${myLineNext}" arg2="0" />
		    <ac:then>
				<fl:fail message="Argument Error: Empty line"/>
			</ac:then>
			<ac:else>
				<stringSubStringZZZ text="${myLineNext}" start="0" end="1" property="subtext" /> <!-- anwenden der oben definierten scriptdef funktion substring -->
				<ac:if>
					<ac:equals arg1="${subtext}" arg2="#" />
					<ac:then>
						<fl:fail message="Argument Error: Comment line"/>
					</ac:then>
					<ac:else>
						<!-- Also nur in diesem Fall weitermachen -->
					</ac:else>
				</ac:if>
			</ac:else>
	</ac:if>
	
	<!-- Uebernimm den vorherigen Schema-Teil -->
	<fl:let>myStringCurrent.Schema::=trim('${stringCurrent.Schema}')</fl:let>
	<!--<echo>myStringCurrent.Schema=${myStringCurrent.Schema}</echo>-->
	
	<!-- Ermittle den neuen Schema-Teil, falls leer dann mache copy als Default-Schema -->
	<!-- Ermittle die Zeile ohne Schema-Anfang.-->
	<!--<echo>myLineNextSchema="${myLineNextSchema}"</echo>-->
	<stringLeftStringZZZ text="${myLineNextSchema}" matchstring="://" returnstring="schemanext" />
	<fl:let>mySchemaNext::="${schemanext}"</fl:let>
	<!--<echo>mySchemaNext="${mySchemaNext}"</echo>-->
	<fl:let>mySchemaNextTrimmed::=trim('${mySchemaNext}')</fl:let>
	<!--<echo>mySchemaNextTrimmed="${mySchemaNextTrimmed}"</echo>-->
	<ac:if>
		<ac:equals arg1="${mySchemaNextTrimmed}" arg2="" />
		    <ac:then>
				<fl:let>mySchemaNextTrimmed::="copy"</fl:let>
				<fl:let>myLineNext::="${myLineNextSchema}"</fl:let>
			</ac:then>
			<ac:else>
				<!-- Ermittle die Zeile ohne Schemateil -->				
				<stringRightStringZZZ text="${myLineNextSchema}" matchstring="${mySchemaNext}://" returnstring="myLineNext" />
				<!--<echo>myLineNext="${myLineNext}"</echo>-->
			</ac:else>
	</ac:if>
	<fl:let>myReturnString.Schema::='${mySchemaNextTrimmed}'</fl:let>
	<echo>myReturnString.Schema="${myReturnString.Schema}"</echo>
	
	

	<!-- Prüfe, ob sich das Schema geändert hat -->	
	<isSetZZZ valueinput="${myStringCurrent.Schema}" valuereturn="myIsSetValue" isset="myValueIsSet" /><!-- anwenden der oben definierten scriptdef funktion -->
	<!-- Das Ergebnis von isSetZZZ prüfen -->
	<isBooleanZZZ valueinput="${myValueIsSet}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<!--<ac:if>
	  <equals arg1="${myBooleanValue}" arg2="true" />
      <ac:then>		
		<echo>Property war gesetzt.</echo>
	  </ac:then>
	  <ac:else>
		<echo>Property war NICHT gesetzt.</echo>
	  </ac:else>
    </ac:if>-->
	 
	<fl:choose>
		<fl:when test="${myBooleanValue}==false">
			<echo>Noch nicht gesetztes altes Schema</echo>
			
			<!-- Erzeuge das Array zum ersten mal -->
			<arrayInitJsZZZ isize="0" arrayreturn="mylineaNext.UnSchema"/>
			
			<!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.Schema}" ilevel="1"/> -->
																				
		</fl:when><!-- test="'${myBooleanValue}'==false -->
	</fl:choose>
	 
	<fl:choose>		
		<fl:when test="'${mySchemaNextTrimmed}'=='${myStringCurrent.Schema}' or ${myBooleanValue}==false"><!-- TODO GOON 20151112: Hier pruefen, ob die Variable initialisiert ist -->
			<echo>Keine Schemaaenderung</echo>
			<fl:let>myReturnControl.SchemaChanged::=false</fl:let>
										
			<!-- Hänge an bestehendes Array an -->
			<arrayAppendJsZZZ arrayinput="${mylineaNext.UnSchema}" valueinput="${myLineNext}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />
	
			<!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.UnSchema}" ilevel="1"/> -->
																				
		</fl:when><!-- '${mySchemaCurrent}'=='${myStringCurrent.Schema}' -->
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->		
			<echo>Schemaaenderung vorhanden!</echo>
			<fl:let>myReturnControl.SchemaChanged::=true</fl:let>
			
			<!-- Mache neues Array. Hänge an neues Array an -->			
			<arrayInitJsZZZ isize="0" arrayreturn="mylineaNext.UnSchema"/>
			<arrayAppendJsZZZ arrayinput="${mylineaNext.UnSchema}" valueinput="${myLineNext}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />
	
			<!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.Schema}" ilevel="1"/> -->
					
		</otherwise>
	</fl:choose>	
	<fl:let>myReturnControl::=true</fl:let>
	<fl:let>myReturnString::="alles ok"</fl:let>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />
	<ac:var name="returnControl.SchemaChanged" value="${myReturnControl.SchemaChanged}" />
	<ac:var name="returnString.Schema" value="${myReturnString.Schema}" />		
	<arrayCopyJsZZZ arrayinput="${mylineaNext.UnSchema}" arrayreturn="linea.UnSchema" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>

<target name="-FglSchemaController_Controller">
	<fl:let>sScript::='-FglSchemaController_Controller: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
	<!-- Merke: Orientier dich bei der Vergabe der Schema Namen an den DOS - Befehlen -->
	<!-- Bisher umgesetzt: vmd, copy -->
	<!-- TODO umzusetzen: del, zip -->

	<fl:let>myStringCurrentSchema::="${stringCurrent.Schema}"</fl:let>
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="myLineaCurrent.UnSchema" sflagcontrol="" />	
	<!--<arrayDebugJsZZZ arrayinput="${myLineaCurrent.UnSchema}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	
	
	<!-- #### Rufe nun die Funktion auf, die das vorherige Schema verarbeiten soll. #### -->
	<!-- ###################################################### -->
	<ac:if>								
		<ac:equals arg1="${myStringCurrent.Schema}" arg2="vmd" />								
		<ac:then>
			<fl:echo>${sScript}AUFRUF DES VMD-CONTROLLERS FUER DEN VMD-FALL</fl:echo>
			<antcallback target="-FglVmdController_Main" return="returnString, returnControl,srcaTotal.filedir,srcaTotal.filename,destaTotal.filedir,destaTotal.filename">
				<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
			</antcallback>
			
			<fl:echo>${sScript}Ergebnis des VMD Controllers fuer den VMD-Fall: ${returnString}</fl:echo>
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->

			<ac:if>
				<ac:equals arg1="${returnControl}" arg2="false" />
				<ac:then>
					<fl:echo>${sScript}VMD Controller beendet mit false. Keine weitere Verarbeitung.</fl:echo>
				</ac:then>
				<ac:else>
					<fl:echo>${sScript}Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
					
					<!-- Beim VMD-Kopiern ein Flag mitgeben, das erst bewirkt, dass der HOSTNAME als Suffix hinter den Dateinamen kommt -->					
					<antcallback target="-FGLCopyLocal_Main" return="returnString, returnControl">
						<param name="controlString" value="append_hostname"/>	
						<!-- Scheinbar kann man als Parameter auch arrays direkt uebergeben, nur Arrays zurückgeben ist dann halt etwas schwieriger -->
						<param name="mySrcaTotal.filedir" value="${srcaTotal.filedir}"/>	
						<param name="mySrcaTotal.filename" value="${srcaTotal.filename}"/>	
						<param name="myDestaTotal.filedir" value="${destaTotal.filedir}"/>	
						<param name="myDestaTotal.filename" value="${destaTotal.filename}"/>	
					</antcallback>      
					<fl:echo>${sScript}Ergebnis des Kopierens: ${returnString}</fl:echo>			
				</ac:else> <!-- Controller erfolgreich -->
			</ac:if><!-- Ergebnis des VMD Controllers -->																
		</ac:then>
	 </ac:if>	
	<!-- ###################################################### -->
		<ac:if>								
		<ac:equals arg1="${myStringCurrent.Schema}" arg2="copy" />								
		<ac:then>
			<fl:echo>${sScript}AUFRUF DES VMD-CONTROLLERS FUER DEN COPY-FALL</fl:echo>
			<antcallback target="-FglVmdController_Main" return="returnString, returnControl,srcaTotal.filedir,srcaTotal.filename,destaTotal.filedir,destaTotal.filename">
				<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
			</antcallback>
			
			<fl:echo>${sScript}Ergebnis des VMD Controllers fuer den COPY-FALL: ${returnString}</fl:echo>
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->

			<ac:if>
				<ac:equals arg1="${returnControl}" arg2="false" />
				<ac:then>
					<fl:echo>${sScript}VMD Controller beendet mit false. Keine weitere Verarbeitung.</fl:echo>
				</ac:then>
				<ac:else>
					<fl:echo>${sScript}Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
					
					<!-- Beim COPY-Kopiern kein Flag mitgeben, das bewirkt, dass der Dateiname verändert wird -->					
					<antcallback target="-FGLCopyLocal_Main" return="returnString, returnControl">
						<param name="controlString" value=""/>	
						<!-- Scheinbar kann man als Parameter auch arrays direkt uebergeben, nur Arrays zurückgeben ist dann halt etwas schwieriger -->
						<param name="mySrcaTotal.filedir" value="${srcaTotal.filedir}"/>	
						<param name="mySrcaTotal.filename" value="${srcaTotal.filename}"/>	
						<param name="myDestaTotal.filedir" value="${destaTotal.filedir}"/>	
						<param name="myDestaTotal.filename" value="${destaTotal.filename}"/>	
					</antcallback>      
					<fl:echo>${sScript}Ergebnis des Kopierens: ${returnString}</fl:echo>			
				</ac:else> <!-- Controller erfolgreich -->
			</ac:if><!-- Ergebnis des VMD Controllers -->																
		</ac:then>
	 </ac:if>	
	 <!-- ###################################################### -->
		<ac:if>								
		<ac:equals arg1="${myStringCurrent.Schema}" arg2="del" />								
		<ac:then>
			<fl:echo>${sScript}AUFRUF DES CONTROLLERS FUER DEN DEL-FALL</fl:echo>			
			<antcallback target="-FglDelController_Main" return="returnControlString, returnControl,return.saTotal.filedir,return.saTotal.filename">
				<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
			</antcallback>
			
			<fl:echo>${sScript}Ergebnis des Controllers fuer den DEL-FALL: ${returnControlString}</fl:echo>
			<arrayDebugJsZZZ arrayinput="${return.saTotal.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays	-->
			<arrayDebugJsZZZ arrayinput="${return.saTotal.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays	-->
			<arrayCopyJsZZZ arrayinput="${return.saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${return.saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />
			<ac:if>
				<ac:equals arg1="${returnControl}" arg2="false" />
				<ac:then>
					<fl:echo>${sScript}DEL Controller beendet mit false. Keine weitere Verarbeitung.</fl:echo>
				</ac:then>
				<ac:else>
					<fl:echo>${sScript}DEL Controller beendet mit true. Fahre fort.</fl:echo>
					
					<!-- Starte das Loeschen der durch die Arrays beschriebenen Dateien -->					
					<antcallback target="-FGLDelLocal_Main" return="returnControlString, returnControl">
						<param name="controlString" value=""/>	
						<!-- Scheinbar kann man als Parameter auch arrays direkt uebergeben, nur Arrays zurückgeben ist dann halt etwas schwieriger -->
						<param name="saTotal.filedir" value="${mysaTotal.filedir}"/>	
						<param name="saTotal.filename" value="${mysaTotal.filename}"/>							
					</antcallback>      
					<fl:echo>${sScript}Ergebnis des Loeschens: ${returnControlString}</fl:echo>			
				</ac:else> <!-- Controller erfolgreich -->
			</ac:if><!-- Ergebnis des VMD Controllers -->																
		</ac:then>
	 </ac:if>	
	<!-- ###################################################### -->	
	<fl:let>myReturnControl::=${returnControl}</fl:let>
	<!--<fl:let>myReturnControlString::=${returnControlString}</fl:let>-->
	<ac:var name="myReturnControlString" value="${returnControlString}"/>
		
		
		</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>			
		
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${myReturnControlString}" />
	<!--<arrayCopyJsZZZ arrayinput="${mylineaNext.Schema}" arrayreturn="linea.Schema" sflagcontrol="" />--><!-- So gibt man einen Arraywertzurueck -->
</target>

<!-- ######################################################################### -->
<!-- ######################################################################### -->
<target name="-FglDelController_Main">  
	<fl:let>sScript::='-FglDelController_Main: '</fl:let>	
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="myLineaNext.UnSchema" sflagcontrol="" />	
	<!--<arrayDebugJsZZZ arrayinput="${myLineaNext.UnSchema}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->

	<!-- Arrays für alle Dateien, die es dann später zu loeschen gilt -->
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filedir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filename"/>
	
	<arrayElementCountJsZZZ arrayinput="${myLineaNext.UnSchema}" ireturn="myArraySize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<fl:choose>
	<fl:when  test="${myArraySize}>=1"><!-- Sind Einträge im Array vorhanden. -->

		<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${myArraySize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>
		
		<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
		<ac:if>
			<equals arg1="0" arg2="${iubound}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
			<ac:then><!-- iubound = 0 Fall -->			
				<echo>##################${sScript}NUR 1 EINTRAG in diesem Schemalauf</echo> 
				<arrayGetJsZZZ arrayinput="${myLineaNext.UnSchema}" index="0" arrayget="myLineTrimmed" sflagcontrol=""/>
				<fl:echo>${sScript}zu verarbeitende Zeile (ohne Schema):'${myLineTrimmed}'</fl:echo>
			
				<!-- Hier in einem antcallback alles aufrufen, was in der Schleife auch passiert -->
				<antcallback target="-FglDelController_LineController" return="returnString, returnControl,return.saTotal.filedir,return.saTotal.filename">
					<param name="lineCurrent" value="${myLineTrimmed}"/>
					<param name="saTotal.filedir" value="${mysaTotal.filedir}" />
					<param name="saTotal.filename" value="${mysaTotal.filename}" />					
				</antcallback>
				<!--<arrayDebugJsZZZ arrayinput="${return.saTotal.filedir}" ilevel="1"/>-->
				<!--<arrayDebugJsZZZ arrayinput="${return.saTotal.filename}" ilevel="1"/>-->
				<arrayCopyJsZZZ arrayinput="${return.saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->			
			</ac:then><!-- iubound = 0 Fall -->
			<ac:else><!-- iubound > 0 Fall -->	
			
				<!-- Ermittle die Anzahl, der Dateien -->	
				<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
				<!-- Den ubound des Arrays um +1 erhöhen, um die Anzahl zu bekommen. -->
				<var name="op1" value="${iubound}"/>
				<var name="op2" value="1"/>
				<var name="op" value="+"/>
				<math result="iAnzahl" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>						
				<echo>######################${sScript} ${iAnzahl} EINTRAEGE in diesem Schemalauf</echo> 
				<ac:for param="icounter" end="${iubound}">			
				<sequential>
					<echo>##################${sScript}icounter ist @{icounter}</echo> 
					<arrayGetJsZZZ arrayinput="${myLineaNext.UnSchema}" index="@{icounter}" arrayget="myLineTrimmed"/>
					<fl:echo>${sScript}zu verarbeitende Zeile (ohne Schema) @{icounter} :'${myLineTrimmed}'</fl:echo>
				
					<!-- Hier die hier in ein antcallback auslagern und für jede Zeile aufrufen. -->
					<antcallback target="-FglDelController_LineController" return="returnString, returnControl,return.saTotal.filedir,return.saTotal.filename">
						<param name="lineCurrent" value="${myLineTrimmed}"/>
						<param name="saTotal.filedir" value="${mysaTotal.filedir}" />
						<param name="saTotal.filename" value="${mysaTotal.filename}" />						
					</antcallback>
					
					<arrayCopyJsZZZ arrayinput="${return.saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->					
					<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>-->
					<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>-->
					</sequential>
				</ac:for>
			</ac:else><!-- iubound > 0 Fall -->
		</ac:if><!-- ubound = 0 tatsaechlich notwendige Abfrage -->
			
		<!-- TODO: Hier tatsaechlich den Rueckgabewert vom Kopiererfolg abhaengig machen -->
		<fl:let>myReturnControl ::= true</fl:let>
		<fl:let>myReturnString ::= "${sScript}Alles ok"</fl:let>
	</fl:when><!-- Existiert die Konfigurationsdatei für das lokale Ausführen -->
	<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
		<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		<fl:let>myReturnControl ::= false</fl:let>
		<fl:let>myReturnString ::= "${sScript}Array für del - Schema Zeilen ist leer"</fl:let>
	</otherwise>
	</fl:choose>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filedir}" arrayreturn="return.srcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filename}" arrayreturn="return.srcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>
<target name="-FglDelController_LineController"> 
	<fl:let>sScript::='-FglDelController_LineController: '</fl:let>
	<!--       Singletyp: Man kann eine Datei, inklusive Pfad angeben del://verzeichnisX\y.txt
	     TODO: Singletyp, mehrere Dateipfade mit Semikolon getrennt del://verzeichnisX\y.txt;verzeichnis\z.txt;verzeichnisB\x.txt
		 
		 
		 TODO: Matrixtyp: Verzeichnis mit mehreren Dateien, oder ohne Dateien, d.h. alle
		       del://verzeichnisX=y.txt;z.txt;x.txt-->	 
	<!-- Durch dieses Target kann ein antcallback in einer Schleife eingebaut werden, der dann sowohl für den ubound=0 als auch für den ubound > 0 Fall aufgerufen werden kann. -->
	<fl:let>myLineUnschemed::="${lineCurrent}"</fl:let><!-- darin ist kein Schema mehr enthalten -->
	<!--<fl:echo>${sScript}EINGANGSARRAY: saTotal.filedir</fl:echo>-->
	<!--<arrayDebugJsZZZ arrayinput="${saTotal.filedir}" ilevel="1"/>-->
	<!--<fl:echo>${sScript}EINGANGSARRAY: saTotal.filename</fl:echo>-->
	<!--<arrayDebugJsZZZ arrayinput="${saTotal.filename}" ilevel="1"/>-->
	<arrayCopyJsZZZ arrayinput="${saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />	
				
	<!-- TODO: Idee: in der Initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->	
	<!-- IDEE für die Zukunft: Lösche durchaus in einer Zeile mehrere Dateien in einem Verzeichnis
	           del://verzeichnis=a.txt,b.txt,c.txt
               Das funktioniert auch mit mehreren Dateien in mehreren Verzeichnissen.
			   del://verzeichnis1,verzeichnis2=a.txt,b.txt			
			   Das funktioniert auch mit mehrerern Dateien
			   del://verzeichnisX\y.txt,verzeichnisZ\xyz.txt
			   -->
			   
			   
	<!-- TODO GOON, noch KAPUTT: Rufe antcallback FglDelLocal_FileByMatrix auf
	                             Darin wird aus einer Ziele je ein Array für die Verzeichnisse und ein Array für die Dateistrings erzeugt. 
								 Dabei wird es beliebig kompliziert, je nachdem wie die Konfigurationszeile gebaut ist
								 a) Gleichheitszeichen, kein Gleichheitszeichen.
								 b) Ein oder mehrer Verzeichnisse, ein oder mehrerer Dateien. Hierzu muss sogar erst noch geprüft werden, 
								    ob es sich um einen Datei- oder um einen Verzeichnispfad handelt. ...-->
									
									
			   
	
	<!-- Start ... -->
	<!-- Pruefe, ob in der Zeile ein Gleichheitszeichen ist. Dies steuert auf oberster Ebenen den zu behandelnden Fall -->				
	<!-- Schreibe das in eine Flaka Variable -->			
	<fl:let>myLeftPart::=split('${myLineUnschemed}','=')[0]</fl:let>
	<fl:let>myRightPart::=split('${myLineUnschemed}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
	<fl:echo>${sScript}Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
	<fl:echo>${sScript}Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
		
	<fl:when test="null('${myLeftPart}')">
		<echo>${sScript}Linker Teil der Steuerungsanweisung existiert nicht (Verzeichnis oder Dateinamen): ${myLineTrimmed}</echo>
		<fl:fail message="${sScript}Linker Teil der Steuerungsanweisung existiert nicht: ${myLineTrimmed}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	
	<!-- TODO: Pruefen, ob die Zeile mit einem Schema beginnt. Falls ja ==> Fehler werfen. -->
	
	<!-- TODO noch kaputt -->
	<!--### Aufruf des Controllers der verschiedenen Fälle ####################-->
	<isSetZZZ valueinput="${myRightPart}" valuereturn="myIsSetValue" isset="myValueIsSet" /><!-- anwenden der oben definierten scriptdef funktion -->
	<isBooleanZZZ valueinput="${myValueIsSet}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<ac:if>
	 <equals arg1="${myBooleanValue}" arg2="true" />     
      <ac:then>
		<echo>${sScript}myRightPart ist gesetzt = '${myRightPart}'</echo>

		<antcallback target="-FGLDelLocal_AnalyseMatrix" return="returnControl, returna.filedir, returna.filename">
			<param name="analyze" value="${myAnalyze}"/>
			<param name="leftPart" value="${myLeftPart}"/>
			<param name="rightPart" value="${myRightPart}"/>												
		</antcallback>		
	  </ac:then>
	  <ac:else>
		<echo>${sScript}Nur linker Teil der Steuerungsanweisung existiert (Dateinamen... ohne Schema): ${myLineTrimmed}</echo>						
		<antcallback target="-FglDelLocal_AnalyseSingle" return="returnControl, returnString, returna.filedir, returna.filename">
			<param name="singlePart" value="${myLeftPart}"/>													
		</antcallback>
	  </ac:else>
	 </ac:if>
	 <!--<echo>######${sScript}zurueckgegebene und entegegengenommene Arrays aus -FglDelLocal_AnalyseSingle:</echo>-->
	 <!--<arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/>-->
	 <!--<arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/>-->
	 
	 <fl:let>myReturnControl::="${returnControl}"</fl:let>		
	<fl:choose>
		<fl:when test="${myReturnControl}==true">
			<fl:let>myReturnString::='${sScript}Alles o.k.| ${returnString}'</fl:let>
		</fl:when>	
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<fl:let>myReturnString::='${sScript}Ein Fehler muss aufgetreten sein. | ${returnString}'</fl:let>
		</otherwise>
	</fl:choose>	
			 		
	 <fl:echo>${sScript}Ergebnis von -FGLDelLocal_AnalyseMatrix bzw. -FglDelLocal_AnalyseSingle=${myReturnControl}</fl:echo>
	 <fl:echo>${sScript}returna.filedir=${returna.filedir}</fl:echo>
	 <fl:echo>${sScript}returna.filename=${returna.filename}</fl:echo>
	 <arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="mysaFiledir" sflagcontrol="" />
	 <arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="mysaFilename" sflagcontrol="" />

	<!-- Hänge die zurückgelieferten Arrays an die schon existierenden an -->	
	<isArrayEmptyJsZZZ arrayinput="${mysaFilename}" returnboolean="myArrayIsEmpty" sflagcontrol="" />
	<fl:echo>${sScript}myArrayIsEmpty=${myArrayIsEmpty}</fl:echo>
	<ac:if>
		<and>
			<equals arg1="${myReturnControl}" arg2="true"/>
			<not>				
				<equals arg1="${myArrayIsEmpty}" arg2="true"/>
			</not>
			<!-- Auch ohne Dateien, sollte das Verzeichnis geloescht werden.
			<not>
				<equals arg1="${mysaFilename}" arg2="true"/>
			</not>-->
	
		</and>
		
		
		
		<ac:then>		
			<fl:echo>${sScript}Ergebnis: ${returnControl}, haenge Array an.</fl:echo>
			<arrayAppendArrayJsZZZ arrayinput="${mysaTotal.filedir}" array2append="${mysaFiledir}" arrayReturn="myArrayTotal1"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal1}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />						
			<arrayAppendArrayJsZZZ arrayinput="${mysaTotal.filename}" array2append="${mysaFilename}" arrayReturn="myArrayTotal2"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal2}" arrayreturn="mysaTotal.filename" sflagcontrol="" />
			
			<!--<fl:echo>${sScript}Ergebnis mit angehaengtem Array:</fl:echo>-->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>-->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>-->
		</ac:then>
		<ac:else>
			<fl:echo>${sScript}Ergebnis: ${returnControl} => kein Arraywert anzuhaengen.</fl:echo>
		</ac:else>
	</ac:if>		
	<!-- ... Ende -->
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filedir}" arrayreturn="return.saTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywert zurueck -->
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filename}" arrayreturn="return.saTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywert zurueck -->		
</target>

<target name="-FglDelLocal_AnalyseSingle">
	<fl:let>sScript::='-FglDelLocal_AnalyseSingle: '</fl:let>	
	<!-- MERKE: Hier wird keine Array reingegeben, sondern nur ein Array rausgegeben. -->
	<fl:let>mySinglePart ::= "${singlePart}"</fl:let>
	
	<!-- Bereite die Rueckgabewerte vor -->
	<arrayInitJsZZZ isize="0" arrayreturn="mysaFiledir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mysaFilename"/>	
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filedir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filename"/>
	
	<!-- TODO GOON noch kaputt: Teile die Werte der Dateien mit Kommata auf und arbeite die Dateien in einer Schleife ab. 
	                            Falls es Verzeichniswerte mit Komata gibt, ist das hier die falsche Funktion. Verwende ... Matrix ...-->
	
	<!-- ### Übernimm nur die Dateien, die existieren, alles andere macht beim Loeschen keinen Sinn -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test="'${mySinglePart}'.tofile.exists == true ">
			<echo>${sScript}Datei/Verzeichnis existiert: ${mySinglePart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${mySinglePart}" property="myisdirectoryPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<!--<echo>Teil: isdirectory=${myisdirectoryPart}</echo>-->														
			<fl:when test="${myisdirectoryPart} == true">
					<!-- A) Teil - Verzeichnis-Fall: -->
					<echo>${sScript}Teil: Ist Verzeichnis, damit sollten alle Dateien im Verzeichnis geloescht werden.</echo>
					<arrayAppendJsZZZ arrayinput="${mysaFiledir}" valueinput="${mySinglePart}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />								
					<arrayAppendJsZZZ arrayinput="${mysaFilename}" valueinput="**.**" arrayreturn="mysaTotal.filename" sflagcontrol="" />								
					<fl:let>myReturnControl::=true</fl:let>
					<fl:let>myReturnString::='${sScript}Alles o.k.'</fl:let>
			</fl:when>
			<fl:when test="${myisdirectoryPart} != true">			
					<!-- B) Linker Teil - Dateipfad-Fall:-->
					<echo>${sScript}Teil: Ist KEIN Verzeichnis</echo>
					
					<!-- Ermittle aus dem Pfad den Verzeichnis und den Dateiteil -->
					<getFilenameFromPathJsZZZ pathstring="${mySinglePart}" returnfilename="myFilename" returncontrol="mytempReturnControl" returnacontrolstring="myaReturnControl" sflagcontrol="" />
					<echo>${sScript}Der Dateiname ist: '${myFilename}'</echo>
					<arrayAppendJsZZZ arrayinput="${mysaFilename}" valueinput="${myFilename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />

					<fl:let>myDirectoryPath::=''</fl:let>
					<stringLeftBackStringZZZ text="${mySinglePart}" matchstring="${myFilename}" returnstring="myDirectoryPath" />
					<echo>${sScript}Der Pfad ist: '${myDirectoryPath}'</echo>					
					<arrayAppendJsZZZ arrayinput="${mysaFiledir}" valueinput="${myDirectoryPath}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />								
															
					<fl:let>myReturnControl::=${mytempReturnControl}</fl:let>									
					<fl:choose>
						<fl:when test="${myReturnControl}==true">
							<fl:let>myReturnString::='${sScript}Alles o.k.'</fl:let>
						</fl:when>	
						<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
							<fl:let>myReturnString::='${sScript}Ein Fehler muss aufgetreten sein.'</fl:let>
						</otherwise>
					</fl:choose>										
			</fl:when>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>${sScript}Datei/Verzeichnis existiert NICHT (damit nicht relevant fuer Loeschung): ${mySinglePart}</echo>	
			
			<!-- Eingabearray gleich Ausgabearray, trotzdem wieder zurückgeben. -->
			<fl:let>myReturnControl::=true</fl:let>
			<fl:let>myReturnString::="${sScript}: Datei/Verzeichnis existiert NICHT. Trotzdem alles o.k."</fl:let>
		</otherwise>
	</fl:choose>
	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />	
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filedir}" arrayreturn="returna.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->				
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filename}" arrayreturn="returna.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->				
</target>

<!-- ######################################################################### -->
<target name="-FglVmdController_Main"> 
	<fl:let>sScript::='-FglVmdController_Main: '</fl:let>
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />	

	<!-- Arrays für alle Dateien, die es dann später zu kopieren gilt -->
	<!-- Todo: diese dann auch im Schema "copy" verwenden -->
	<arrayInitJsZZZ isize="0" arrayreturn="mySrcaTotal.filename"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mySrcaTotal.filedir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="myDestaTotal.filename"/>
	<arrayInitJsZZZ isize="0" arrayreturn="myDestaTotal.filedir"/>
			
	<arrayElementCountJsZZZ arrayinput="${mylineaNext.UnSchema}" ireturn="myArraySize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<fl:choose>
	<fl:when  test="${myArraySize}>=1"><!-- Sind Einträge im Array vorhanden. -->

		<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${myArraySize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<echo>Errechneter ubound Wert des Arrays: ${iubound}</echo>
		
		<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
		<ac:if>
			<equals arg1="0" arg2="${iubound}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
			<ac:then><!-- iubound = 0 Fall -->			
				<echo>NUR 1 EINTRAG in diesem Schemalauf</echo> 
				<arrayGetJsZZZ arrayinput="${lineaCurrent.UnSchema}" index="0" arrayget="myLineTrimmed" sflagcontrol=""/>
				<fl:echo>zu verarbeitende Zeile:'${myLineTrimmed}'</fl:echo>
			
				<!-- Hier in einem antcallback alles aufrufen, was in der Schleife auch passiert -->
				<antcallback target="-FglVmdController_LineController" return="returnString, returnControl,return.srcaTotal.filedir,return.srcaTotal.filename,return.destaTotal.filedir,return.destaTotal.filename">
					<param name="lineCurrent" value="${myLineTrimmed}"/>
					<param name="srcaTotal.filedir" value="${mySrcaTotal.filedir}" />
					<param name="srcaTotal.filename" value="${mySrcaTotal.filename}" />
					<param name="destaTotal.filedir" value="${myDestaTotal.filedir}" />
					<param name="destaTotal.filename" value="${myDestaTotal.filename}" />
				</antcallback>
				<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filename}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.destaTotal.filedir}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.destaTotal.filename}" arrayreturn="myDestaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->					
			</ac:then><!-- iubound = 0 Fall -->
			<ac:else><!-- iubound > 0 Fall -->	
				<echo>${iubound} EINTRAEGE in diesem Schemalauf</echo>
				<ac:for param="icounter" end="${iubound}">			
				<sequential>
					<echo>icounter is @{icounter}</echo> 
					<arrayGetJsZZZ arrayinput="${lineaCurrent.UnSchema}" index="@{icounter}" arrayget="myLineTrimmed" sflagcontrol=""/>
					<fl:echo>zu verarbeitende Zeile:'${myLineTrimmed}'</fl:echo>
				
					<!-- Hier die hier in ein antcallback auslagern und für jede Zeile aufrufen. -->
					<antcallback target="-FglVmdController_LineController" return="returnString, returnControl,return.srcaTotal.filedir,return.srcaTotal.filename,return.destaTotal.filedir,return.destaTotal.filename">
						<param name="lineCurrent" value="${myLineTrimmed}"/>
						<param name="srcaTotal.filedir" value="${mySrcaTotal.filedir}" />
						<param name="srcaTotal.filename" value="${mySrcaTotal.filename}" />
						<param name="destaTotal.filedir" value="${myDestaTotal.filedir}" />
						<param name="destaTotal.filename" value="${myDestaTotal.filename}" />
					</antcallback>
					<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filename}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.destaTotal.filedir}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.destaTotal.filename}" arrayreturn="myDestaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->					
					</sequential>
				</ac:for>
			</ac:else><!-- iubound > 0 Fall -->
		</ac:if><!-- ubound = 0 tatsaechlich notwendige Abfrage -->
		<!-- TODO: Hier tatsaechlich den Rueckgabewert vom Kopiererfolg abhaengig machen -->
		<fl:let>myReturnControl ::= true</fl:let>
		<fl:let>myReturnString ::= "alles ok"</fl:let>
	</fl:when><!-- Existiert die Konfigurationsdatei für das lokale Ausführen -->
	<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
		<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		<fl:let>myReturnControl ::= false</fl:let>
		<fl:let>myReturnString ::= "Array für vmd - Schema Zeilen ist leer"</fl:let>
	</otherwise>
	</fl:choose>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="srcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filename}" arrayreturn="srcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filedir}" arrayreturn="destaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>
<target name="-FglVmdController_LineController"> 
	<!-- Durch dieses Target kann ein antcallback in einer Schleife eingebaut werden, der dann sowohl für den ubound=0 als auch für den ubound > 0 Fall aufgerufen werden kann. -->
	<fl:let>myLineTrimmed ::= "${lineCurrent}"</fl:let>
	<arrayCopyJsZZZ arrayinput="${srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${srcaTotal.filename}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${destaTotal.filedir}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${destaTotal.filename}" arrayreturn="myDestaTotal.filename" sflagcontrol="" />	
		
	<!-- Schreibe das in eine Flaka - Variable -->		
	<fl:let>myLeftPart::=split('${myLineTrimmed}','=')[0]</fl:let>
	<fl:let>myRightPart::=split('${myLineTrimmed}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
	<fl:echo>Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
	<fl:echo>Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
																	
	<!-- TODO: Idee: in der Initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
	<fl:when test="null('${myRightPart}')">
		<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): ${myLineTrimmed}</echo>
		<fl:fail message="Rechter Teil der Steuerungsanweisung existiert nicht: ${myLineTrimmed}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
										
		<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
		<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
		<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
		<fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
	</fl:when>
	<fl:when test="null('${myLeftPart}')">
		<echo>Linker Teil der Steuerungsanweisung existiert nicht (von...): ${myLineTrimmed}</echo>
		<fl:fail message="Linker Teil der Steuerungsanweisung existiert nicht: ${myLineTrimmed}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																						
		<!-- Merke: Das wäre beim Kopieren einer Datei von einem feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
		<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
		<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
		<fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
	</fl:when>
					
	<!-- TODO noch kaputt: IDEE: Normiere hier den möglichen Dateipfad nach Windows Style -->
	<!-- Wie oben bei der Ermittlung der Projektdatei, die in der Batch definiert wurde.
			Das Problem hier ist, das eine Property gefüllt wird und sich diese Property nie im Wert ändert -->
			<!--<path id="pathTempLeft">
					<pathelement location="${myLeftPart}"/>
					</path>
					<pathconvert targetos="windows" property="part.path.temp.left" refid="pathTempLeft">
					</pathconvert>
					<echo>Normierter Pfad (Windows Style)= ${part.path.temp.left}</echo>
							
					<path id="pathTempRight">
					<pathelement location="${myRightPart}"/>
					</path>
					<pathconvert targetos="windows" property="part.path.temp.right" refid="pathTempRight">
					</pathconvert>
					<echo>Normierter Pfad (Windows Style)= ${part.path.temp.right}</echo> -->
						
						
	<!-- ### Ermittle hier den Fall. Schreibe den Wert in diese Variable und fülle damit ein Array -->
	<fl:let>myCase ::= "undefined"</fl:let>																										
	<antcallback target="-FGLCopyLocal_Analyze" return="returnAnalyse, returnString">
		<param name="leftPart" value="${myLeftPart}"/>
		<param name="rightPart" value="${myRightPart}"/>
	</antcallback>
								
	<fl:echo>Ergebnis der Analyse: ${returnString}</fl:echo>
	<fl:let>myAnalyze::="${returnString}"</fl:let>
																
	<!--### Aufruf des Controllers der verschiedenen Fälle ####################-->									
	<antcallback target="-FGLCopyLocal_Control" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
		<param name="analyze" value="${myAnalyze}"/>
		<param name="leftPart" value="${myLeftPart}"/>
		<param name="rightPart" value="${myRightPart}"/>												
	</antcallback>
	<fl:let>myReturnControl::="${returnControl}"</fl:let>											
	<fl:echo>myReturnControl=${myReturnControl}</fl:echo>
	<fl:echo>returnSrca.filedir=${returnSrca.filedir}</fl:echo>
	<fl:echo>returnSrca.filename=${returnSrca.filename}</fl:echo>
	<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />
								
															
	<!-- Hänge die zurückgelieferten Arrays an die schon existierenden an -->																	
	<ac:if>
		<equals arg1="${returnControl}" arg2="true"/>
		<ac:then>
			<fl:echo>Ergebnis von -FGLCopyLocal_Control: ${returnControl}, haenge Array an.</fl:echo>
			<arrayAppendArrayJsZZZ arrayinput="${mySrcaTotal.filedir}" array2append="${mySrca.filedir}" arrayReturn="myArrayTotal"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />

			<arrayAppendArrayJsZZZ arrayinput="${mySrcaTotal.filename}" array2append="${mySrca.filename}" arrayReturn="myArrayTotal"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" />

			<arrayAppendArrayJsZZZ arrayinput="${myDestaTotal.filedir}" array2append="${myDesta.filedir}" arrayReturn="myArrayTotal"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" />
								
			<arrayAppendArrayJsZZZ arrayinput="${myDestaTotal.filename}" array2append="${myDesta.filename}" arrayReturn="myArrayTotal"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="myDestaTotal.filename" sflagcontrol="" />
		</ac:then>
		<ac:else>
				<fl:echo>Ergebnis von -FGLCopyLocal_Control: ${returnControl} => kein Arraywert anzuhaengen.</fl:echo>
		</ac:else>
	</ac:if>	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="return.srcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filename}" arrayreturn="return.srcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filedir}" arrayreturn="return.destaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="return.destaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
</target>

<!-- ######################################################################### -->
<target name="-FGLCopyLocal_Main"><!-- Parameter controlString: append_hostname, .... -->
	<fl:let>sScript::='-FGLCopyLocal_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<fl:let>myControlString::='${controlString}'</fl:let> 					
	<arrayElementCountJsZZZ arrayinput="${myDestaTotal.filename}" ireturn="iSize.SrcaTotal.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<!--<echo>Anzahl der Dateien: ${iSize.SrcaTotal.filename}</echo>
	<echo>ControlString: ${myControlString}</echo>-->
	<ac:if>
		<equals arg1="0" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
		<ac:then>							
			<fl:let>myReturnString::="Keine Dateien im Array => keine Verarbeitung"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
		<ac:else>	
			<!-- Für VMD Dateien ist es möglich, dass die gleiche VM auf veschiedenen Rechnern läuft -->
			<!-- Darum sicherheitshalber und zum Abgleich jede Datei noch mit einem Postfix _RECHNERNAME ausstatten -->
			<!-- Führe aus Sicherheitsgründen zuerst diesen Kopiervorgang aus, danach den Kopiervorgang für die Datei ohne Postfix. -->				
			<!--### 1. Lauf Kopiere die Dateien (incl. NAMENSERWEITERUNG) der beiden Arrays  ##################### -->

			<!-- 1. Rechne das Dateinamen aus, ergaenzt um das Postfix -->
			<!-- 1a. Dateiendung entfernen -->
			<arrayLeftBackStringJsZZZ arrayinput="${myDestaTotal.filename}" sinput=".txt" arrayreturn="myDestaTotalReduced.filename" sflagcontrol="" />

			<!-- 1b. Hostnamen und Endung ausrechnen -->
			<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
					dies passiert hier durch flaka´s install-property handler task -->
			<fl:install-property-handler />
			<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
            <ac:if>			
				<equals arg1="'append_hostname'" arg2="'${myControlString}'"/><!-- der Hostname wird im Fall des 'vmd://' Schemas angehängt -->
				<ac:then>						
					<!--<fl:echo>Erweitere den Dateinamen um HOSTSUFFIX</fl:echo>-->
					<fl:let>sHostSuffix ::= "_${env.COMPUTERNAME}.txt"</fl:let><!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 			
				</ac:then>
				<ac:else>
					<fl:let>sHostSuffix ::= ".txt"</fl:let>
				</ac:else>
			</ac:if>
			
		
			<!-- Hänge an alle Einträge des arrays den _HOSTNAME + Endung String an -->
			<arrayPlusStringJsZZZ arrayinput="${myDestaTotalReduced.filename}" sinput="${sHostSuffix}" arrayreturn="myDestaTotalExtended.filename" sflagcontrol="" />
	
			<antcallback target="-FGLCopyLocal_Copy" return="returnControl,returnString">					
				<param name="srca.filename" value="${mySrcaTotal.filename}"/>
				<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
				<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
				<param name="desta.filename" value="${myDestaTotalExtended.filename}"/>					
			</antcallback>
			<fl:let>myReturnControl ::="${returnControl}"</fl:let>
			<fl:let>myReturnString ::="${returnString}"</fl:let>
		
		
			<!--### Automatischer 2. Lauf, wenn auf einem HOSTrechner gestartet wird: ????? #####################-->
			<!-- NEIN 20151005 : So kommt es zu Problemen, weil sich der Inhalt dieser Datei von HostRechner zu HostRechner unterscheidet.
								 Eine Alternative Lösung muss her:
								 Z.B. Erstelle ein Sammeldokument .html, in dem in einzelnen DIVs 
								 der Inhalt der hostspezifischen Clientdatei eingefügt wird. -->
			<!--  
			<antcallback target="-FGLCopyLocal_Copy" return="returnControl,returnString">					
				<param name="srca.filename" value="${mySrcaTotal.filename}"/>
				<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
				<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
				<param name="desta.filename" value="${myDestaTotal.filename}"/>					
			</antcallback>	
			<fl:let>myReturnControl ::="${returnControl}"</fl:let>
			<fl:let>myReturnString ::="${returnString}"</fl:let>
			-->
		</ac:else>
	</ac:if><!-- Anzahl der Dateien pruefen -->

	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myReturnString}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /> --><!-- Merke: So gibt man einen Arraywertzurueck -->
</target>

<target name="-FGLCopyLocal_Copy">
			<fl:let>sScript::='-FGLCopyLocal_Copy: '</fl:let>
			<fl:let>sTrace::=""</fl:let>
			<!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->

			<fl:let>mySrcaTotal.filedir::="${srca.filedir}"</fl:let>
			<fl:let>mySrcaTotal.filename::="${srca.filename}"</fl:let>
			<fl:let>myDestaTotal.filedir::="${desta.filedir}"</fl:let>
			<fl:let>myDestaTotal.filename::="${desta.filename}"</fl:let>

			<arrayElementCountJsZZZ arrayinput="${mySrcaTotal.filename}" ireturn="iSize.SrcaTotal.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
			<echo>Anzahl der Dateien: ${iSize.SrcaTotal.filename}</echo>
			<ac:if>
				<equals arg1="0" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
				<ac:then>
					<echo>Keine Dateien im Array => keine Verarbeitung</echo>
				</ac:then>
				<ac:else>					
					<!-- Leite das Kopieren ein -->
					<ac:if>				
					<equals arg1="1" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich ein Fallunterscheidung einbauen, da in ac:for (des aufzurufenden copy Targets) nicht beide Parameter 0 (also gleich) sein dürfen. -->
					<ac:then>

						<!-- ###### KOPIERE NUR EINEN WERT ############## -->
						<arrayGetJsZZZ arrayinput="${mySrcaTotal.filedir}" index="0" arrayget="mySrc.sFiledir" sflagcontrol=""/>	
						<arrayGetJsZZZ arrayinput="${mySrcaTotal.filename}" index="0" arrayget="mySrc.sFilename" sflagcontrol=""/>	
						<arrayGetJsZZZ arrayinput="${myDestaTotal.filedir}" index="0" arrayget="myDest.sFiledir" sflagcontrol=""/>	
						<arrayGetJsZZZ arrayinput="${myDestaTotal.filename}" index="0" arrayget="myDest.sFilename" sflagcontrol=""/>
					
						<!--<propertyregex property="mytemp01" input="${mySrc.sFiledir}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen. Merke: Property ist nicht veränderbar, darum für jeden Aufruf eine extra Variable verwenden. -->
						<!--<echo>Normierter Verzeichniseintrag: ${mytemp}</echo>-->
						<!--<fl:let>mySrc.sFiledirNormed::='${mytemp01}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
						<!--<echo>Normierter Verzeichniseintrag: ${mysFiledirNormed}</echo>-->
						
						<!--<propertyregex property="mytemp02" input="${myDest.sFiledir}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen. Merke: Property ist nicht veränderbar, darum für jeden Aufruf eine extra Variable verwenden. -->
						<!--<echo>Normierter Verzeichniseintrag: ${mytemp}</echo>-->
						<!--<fl:let>myDest.sFiledirNormed::='${mytemp02}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
						<!--<echo>Normierter Verzeichniseintrag: ${mysFiledirNormed}</echo>-->
						
						<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
						<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">
							<param name="stringInput" value="${mySrc.sFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							<param name="intNumber" value="1" />
						</antcallback>													
						<echo>${sScript}Normierter Verzeichniseintrag -returnString: ${returnString}</echo>
						<fl:let>mySrc.sFiledirNormed::='${returnString}'</fl:let><!-- wichtig: Call by value erzwingen -->
						<echo>${sScript}Normierter Verzeichniseintrag -src: ${mySrc.sFiledirNormed}</echo>
						
						<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
						<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">
							<param name="stringInput" value="${myDest.sFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							<param name="intNumber" value="1" />
						</antcallback>													
						<echo>${sScript}Normierter Verzeichniseintrag -returnString: ${returnString}</echo>
						<fl:let>myDest.sFiledirNormed::='${returnString}'</fl:let><!-- wichtig: Call by value erzwingen -->
						<echo>${sScript}Normierter Verzeichniseintrag -dest: ${myDest.sFiledirNormed}</echo>
						
											
					
						<antcallback target="-FGLCopyLocal_CopyFileSingle" return="returnControl,returnString">					
								<param name="src.sFiledir" value="${mySrc.sFiledirNormed}"/>
								<param name="src.sFilename" value="${mySrcaTotal.filename}"/>								
								<param name="dest.sFiledir" value="${myDest.sFiledirNormed}"/>
								<param name="dest.sFilename" value="${myDestaTotal.filename}"/>					
						</antcallback>	
						<fl:let>myReturnControl ::="${returnControl}"</fl:let>
						<fl:let>myReturnString ::="${returnString}"</fl:let>
					</ac:then>
					<ac:else> 
					<antcallback target="-FGLCopyLocal_CopyFileByFile" return="returnControl,returnString">					
								<param name="srca.filename" value="${mySrcaTotal.filename}"/>
								<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
								<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
								<param name="desta.filename" value="${myDestaTotal.filename}"/>					
						</antcallback>
						<fl:let>myReturnControl ::="${returnControl}"</fl:let>
						<fl:let>myReturnString ::="${returnString}"</fl:let>
					</ac:else>
					</ac:if> 
				</ac:else>
			</ac:if>
			
			<!-- Rueckgabewerte -->
			<ac:var name="returnControl" value="${myReturnControl}" />
			<ac:var name="returnString" value="${myReturnString}" />			
</target>
<target name="-FGLCopyLocal_CopyFileByFile">
	<fl:let>mySrca.filedir ::= "${srca.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${srca.filename}"</fl:let>
	<fl:let>myDesta.filedir ::= "${desta.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${desta.filename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> -->
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Prüfen: Alle Arrays sollen gleich lang sein.-->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filedir}" ireturn="iSize.Srca.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filename}" ireturn="iSize.Srca.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filedir}" ireturn="iSize.Desta.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filename}" ireturn="iSize.Desta.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<ac:if>
		<and>
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Srca.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filedir}" />
		</and>
		<ac:then>		
				<fl:echo message="Alle Arrays haben gleich viel Elemente: ${iSize.Srca.filedir} " />				
		</ac:then>
		<ac:else>
				<fl:fail message="Unterschiedliche Anzahl an Elementen in den Arrays: iSize.Srca.filedir=${iSize.Srca.filedir} | iSize.Srca.filename=${iSize.Srca.filename} | iSize.Desta.filedir=${iSize.Desta.filedir} | iSize.Desta.filename=${iSize.Desta.filename}  "/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:else>
	</ac:if>
	
	<!-- Merke es gibt ein antcontrib Target 'Pathtofileset' dies hier vielleicht anwenden ? -->
	
	<!-- Schleife über alle Arraypositionen-->
	<!-- TODO IDEE: Ermittle den letzten wert des arrays -->

	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${iSize.Srca.filename}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>Errechneter ubound Wert des Arrays: ${iubound}</echo>
	
	<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
	<ac:for param="icounter" end="${iubound}">			
		<sequential>
			<echo>icounter is @{icounter}</echo> 
			<arrayGetJsZZZ arrayinput="${mySrca.filedir}" index="@{icounter}" arrayget="mySrc.filedir" sflagcontrol=""/>	
			<arrayGetJsZZZ arrayinput="${mySrca.filename}" index="@{icounter}" arrayget="mySrc.filename" sflagcontrol=""/>	
			<arrayGetJsZZZ arrayinput="${myDesta.filedir}" index="@{icounter}" arrayget="myDest.filedir" sflagcontrol=""/>	
			<arrayGetJsZZZ arrayinput="${myDesta.filename}" index="@{icounter}" arrayget="myDest.filename" sflagcontrol=""/>	
				
			<!-- 4. Der eigentliche Kopiervorgang -->
			<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
			<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
			<echo>Pushing File ${mySrc.filedir}\${mySrc.filename} to Destination: ${myDest.filedir}\${myDest.filename} </echo>
														
			<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
			<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
						  TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
			<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
			<!-- 	Relative Pfade verwenden:
			<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
			<fileset dir="//${mySrc.filedir}">		 -->
			
			<!-- absolute Pfade verwenden: -->
			<copy todir="${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
				<fileset dir="${mySrc.filedir}">		
				<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
				<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
				<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
																
					<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
					<include name="${mySrc.filename}" />				
				</fileset>
				<globmapper from="${mySrc.filename}" to="${myDest.filename}"/>
			</copy>
		</sequential>
		</ac:for>		

	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnString" value="CopyFileByFile: Alles ok." />
</target>
<target name="-FGLCopyLocal_CopyFileSingle">
	<fl:let>mySrc.sFiledir::="${src.sFiledir}"</fl:let>
	<fl:let>mySrc.sFilename::="${src.sFilename}"</fl:let>
	<fl:let>myDest.sFiledir::="${dest.sFiledir}"</fl:let>
	<fl:let>myDest.sFilename::="${dest.sFilename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> -->
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			
	<!-- 4. Der eigentliche Kopiervorgang -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing File ${mySrc.sFiledir}\${mySrc.sFilename} to Destination: ${myDest.sFiledir}\${myDest.sFilename} </echo>
													
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
	<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
				  TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
	<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
	<!-- 	Relative Pfade verwenden:
	<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
	<fileset dir="//${mySrc.filedir}">		 -->
	
	<!-- absolute Pfade verwenden: -->
	<copy todir="${myDest.sFiledir}" overwrite="false"  preservelastmodified="true"> 
		<fileset dir="${mySrc.sFiledir}">		
		<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
		<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
														
			<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
			<include name="${mySrc.sFilename}" />				
		</fileset>
		<globmapper from="${mySrc.sFilename}" to="${myDest.sFilename}"/>
	</copy>
	
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnString" value="CopySingleFile: Alles ok." />
</target>

<target name="-FGLCopyLocal_Analyze">
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	<fl:let>myCaseTotal ::= ""</fl:let>

	<!-- Merke: Die Analyse der beiden Teile links/rechts ist gleich. Daher dies in ein target ausgelagert, das dann jeweils aufgerufen wird. -->	
	<antcallback target="-FGLCopyLocal_AnalyzePart" return="returnControl,returnString">					
			<param name="sPartToAnalyze" value="${myLeftPart}"/>											
	</antcallback>	
	<fl:let>myCaseLeft ::= "${returnString}"</fl:let>	

	<isBooleanZZZ valueinput="${returnControl}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test="${myValueIsBoolean}==true">
			<fl:choose>
				<fl:when test="${myBooleanValue}==true">
					<echo>Analyze des linken Teils war erfolgreich. Starte Analyze des rechten Teils.</echo>
					<antcallback target="-FGLCopyLocal_AnalyzePart" return="returnControl,returnString">					
						<param name="sPartToAnalyze" value="${myRightPart}"/>											
					</antcallback>
					<fl:let>myCaseRight ::= "${returnString}"</fl:let>
					<fl:let>myCaseTotal ::= "${myCaseLeft}${myCaseRight}"</fl:let>
				</fl:when>	
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<echo>Analyze des linken Teils war NICHT erfolgreich. Spare mir die Auswertung des rechten Teils.</echo>
				</otherwise>
			</fl:choose>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>Auswertung vom linken Teil mit Fehler. Spare mir die Auswertung des rechten Teils.</echo>
		</otherwise>
	</fl:choose>
			
	<echo>Soweit ermittelter Fall: ${myCaseTotal}</echo>

	<!-- Rueckgabebwerte -->
	<ac:var name="returnAnalyze" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myCaseTotal}" />	
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->				
</target>
<target name="-FGLCopyLocal_AnalyzePart">
	<fl:let>myPart::="${sPartToAnalyze}"</fl:let>
	
	<!-- Prüfe, ob Datei vom Linken Teil existiert -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test=" '${myPart}'.tofile.exists == true ">
			<echo>Datei/Verzeichnis existiert: ${myPart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${myPart}" property="myisdirectoryPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<echo>Teil: isdirectory=${myisdirectoryPart}</echo>
														
			<fl:when test="${myisdirectoryPart} == true">
					<!-- A) Teil - Verzeichnis-Fall: -->
					<echo>Teil: ist Verzeichnis</echo>
					<fl:let>myCase::="D"</fl:let>	<!-- D=directory-->																						 
			</fl:when>
			<fl:when test="${myisdirectoryPart} != true">			
					<!-- B) Linker Teil - Dateipfad-Fall:-->
					<echo>Teil: ist KEIN Verzeichnis</echo>
					<fl:let>myCase::="F"</fl:let><!-- F=file-->
			</fl:when>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>Datei/Verzeichnis existiert NICHT: ${myPart}</echo>
										   <!-- Merke: kleines d , d.h. Verzeichnis existiert nicht => Datei existiert auch nicht. -->
			                               <!--        Kleines f, d.h. Datei existiert nicht, Verzeichnis aber. -->
			<!-- <fl:fail message="Datei/Verzeichnis existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
			<isFilenameRelevantVMD text="${myPart}" property="myisfilenamePart" />			
			<isBooleanZZZ valueinput="${myisfilenamePart}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
			<fl:choose>
 			<fl:when test="${myValueIsBoolean}==true">
				<!-- <echo>When:  Ein boolean Wert wurde gefunden.</echo> -->
				<fl:choose>
				<fl:when test="${myBooleanValue}==true">
					<echo>NICHT EXISTIERENDER EINTRAG GILT ALS DATEINAME: ${myPart}</echo>
					<fl:let>myCase::="f"</fl:let>
				</fl:when>	
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<echo>NICHT EXISTIERENDER EINTRAG GILT ALS VERZEICHNIS: ${myPart}</echo>
					<fl:let>myCase::="d"</fl:let>
				</otherwise>
				</fl:choose>
			</fl:when>
			<otherwise>
				<echo>Ergebnis von isFilenameRelevantVMD (= ${myValueIsBoolean} ) nicht interpretierbar: ${myPart}</echo>
				<fl:let>myCase::="X"</fl:let>
			</otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->	
			</fl:choose>
		</otherwise>
	</fl:choose>
	
	<echo>Teilanalyze Fall: ${myCase}</echo>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnString" value="${myCase}" />	
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->		
</target>
<target name="-FGLCopyLocal_Control">
	<fl:let>myAnalyze::="${analyze}"</fl:let>
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	
	<!--### Zu Anfang erst einmal alle Rückgabeparameter mit Leerstring deklarieren, damit selbst im "false-Fall" keine $Variablennamen zurückgegeben werden. ### -->
	<arrayInitJsZZZ isize="0" arrayreturn="mySrca.filedir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayInitJsZZZ isize="0" arrayreturn="mySrca.filename"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayInitJsZZZ isize="0" arrayreturn="myDesta.filedir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayInitJsZZZ isize="0" arrayreturn="myDesta.filename"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->

	
	<!--### START: Aufruf der verschiedenen Fälle ####################-->
	<!-- F=file, D=directory,X=not defined, f=file not found, d=directory not found.
   	      Es geht nicht nur um die Konfiguration, sondern auch darum, dass die Dateien / Verzeichnisse existieren -->
	
	<!-- Je nach Fall ein anderes Target aufrufen. Dadurch ist der Code modularer --> 	
	<!-- Jeweils ein Array erstellen 1) mit den Werten des Ausgangsdateipfads, 2) mit den Werten des Zieldateipfads -->										
	<ac:if>
		<ac:equals arg1="${myAnalyze}" arg2="dd"/>										
		<ac:then>
			<echo>Fall: Verzeichnis links nicht existent, Verzeichnis rechts nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	<ac:elseif>
		<!-- TODO noch Kaputt: Instring abprüfen auf X -->
		<ac:equals arg1="${myAnalyze}" arg2="XX"/>										
		<ac:then>
			<echo>Fall: Linker Ausdruck nicht interpretierbar, rechter Ausdruck nicht interpretierbar</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>		
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="ff"/>										
		<ac:then>
			<echo>Fall: Datei links nicht existent, rechts Datei nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="dD"/>										
		<ac:then>
			<echo>Fall: Verzeichnis links nicht existent, rechts Verzeichnis existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="fD"/>										
		<ac:then>
			<echo>Fall: Datei links NICHT existent, rechts Verzeichnis existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="Dd"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis existent, rechts Verzeichnis NICHT existent</echo>
			<!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->
			
			<!-- TODO noch Kaputt: Kopiere alle Dateien des Verzeichnisses links in das Verzeichnis nach rechts. -->
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
	<ac:or>
		<ac:equals arg1="${myAnalyze}" arg2="DF"/>										
		<ac:equals arg1="${myAnalyze}" arg2="Df"/>										
	</ac:or>
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts existierende/nicht existierende Datei</echo>
			<!-- Kopiere die rechts benannte Datei aus dem links angegebenen Verzeichnis nach rechts -->
			<antcallback target="-FGLCopyLocal_Control_DF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Control_DF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControl::="${returnControl}"</fl:let>	
			<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FD"/>
			<ac:equals arg1="${myAnalyze}" arg2="Fd"/><!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Verzeichnis</echo>
			<antcallback target="-FGLCopyLocal_Control_FD" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Control_FD Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControl::="${returnControl}"</fl:let>	
			<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />			
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="DD"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts Verzeichnis</echo>
			<!-- TODO GOON 20150923: Kopiere alle Dateien aus dem einen Verzeichnis in das andere -->
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>		
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FF"/>
			<ac:equals arg1="${myAnalyze}" arg2="Ff"/><!-- kleines f = nicht existierende Datei -->
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Datei (oder noch nicht existent)</echo>

			<antcallback target="-FGLCopyLocal_Control_FF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Control_FF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControl ::= "${returnControl}"</fl:let>
			<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />
		</ac:then>
	</ac:elseif>									
	<ac:else>
		<fl:fail message="Ungueltiges Analyseergebnis: ${myAnalyze}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
	</ac:else>											
	</ac:if>	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${myDesta.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
</target>

<target name="-FGLCopyLocal_Control_FD">
	<!-- Fall: Kopiere die benannte Datei von links nach rechts in das benannte Verzeichnis. -->	
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_FD</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	<!--  "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	
	<!-- <fl:echo>FD-FALL: BIS HIERHER O.K.!!! -FGLCopyLocal_Control_FD</fl:echo> -->
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
	
	<fl:let>myReturnControl::="${returnControl}"</fl:let>
	<fl:let>mySrca.filedir::="${returna.filedir}"</fl:let><!-- klappt das mit fl:let so? oder sollte man doch besser das ganze Array kopieren? -->	
	<fl:let>mySrca.filename::="${returna.filename}"</fl:let>
	<!-- <arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
	<!-- <arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="mySrca.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->		
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<ac:if>
		<ac:equals arg1="${myReturnControl}" arg2="false"/>										
		<ac:then>
			<echo>Linker Fall=false => Ueberspringe rechten Fall</echo>
		</ac:then>
		<ac:else>
			<echo>Behandle rechten Fall: Uebernimm dabei die Datei Angabe vom linken Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_D_Part" return="returnControl, returna.filedir">
				<param name="sPart" value="${myRightPart}"/>
				<param name="saFilename" value="${mySrca.filename}"/><!-- TODO GOON : Parameter hinzugefügt 20150921, weil er in der Funktion verwendet wurde. Sinnvoll? -->
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			
			<fl:let>returnControl ::= "${returnControl}"</fl:let>
			<fl:let>myDesta.filedir ::= "${returna.filedir}"</fl:let><!-- klappt das mit fl:let so? oder sollte man doch besser das ganze Array kopieren? -->	
			<fl:let>myDesta.filename ::= "${mySrca.filename}"</fl:let><!-- WICHTIG: HIER WIRD DER QUELLDATEINAME ALS ZIELDATEINAME UEBERNOMMEN -->
			<!-- <arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
			<!-- <arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="myDesta.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->		
						
			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->				
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->			
		</ac:else>
	</ac:if>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" /><!-- WICHTIG: Uebernimm die Dateien von links --><!-- So gibt man einen Arraywertzurueck -->		
</target>

<target name="-FGLCopyLocal_Control_DF">
	<!-- Fall: Kopiere die recht benannte Datei vom Verzeichnis links nach rechts an den benannten Dateinamen. -->	
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_DF</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	<echo>Behandle rechten Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
		<param name="sPart" value="${myRightPart}"/>
	</antcallback>
	<fl:let>myReturnControl::="${returnControl}"</fl:let>
	
	<!--<fl:let>myDesta.filedir::="${returna.filedir}"</fl:let>--><!-- klappt das mit dem fl:let so, oder sollte man doch das array kopieren? -->
	<!--<fl:let>myDesta.filename::="${returna.filename}"</fl:let>-->
	<arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" /><!-- So nimmt man einen Arraywert entgegen. -->	
	<arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="myDesta.filename" sflagcontrol="" /><!-- So nimmt man einen Arraywert entgegen. -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	
	<ac:if>
		<ac:equals arg1="${returnControl}" arg2="false"/>										
		<ac:then>
			<echo>Rechter Fall=false => Ueberspringe linken Fall</echo>
		</ac:then>
		<ac:else>
			<echo>Behandle linken Fall: Uebernimm dabei die Datei Angabe vom rechten Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_D_Part" return="returnControl, returna.filedir">
				<param name="sPart" value="${myLeftPart}"/>	
				<param name="saFilename" value="${myDesta.filename}"/><!-- Das dient nur dazu die Anzahl der Dateien zu ermitteln, um so x-mal einen Verzeichniseintrag zu erstellen --><!-- TODO GOON : Parameter hinzugefügt 20150921, weil er in der Funktion verwendet wurde. Sinnvoll? -->				
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<fl:let>mySrca.filedir::="${returna.filedir}"</fl:let><!-- klappt das mit dem fl:let so, oder sollte man doch das array kopieren? -->
			<fl:let>mySrca.filename::="${myDesta.filename}"</fl:let><!-- WICHTIG: HIER WIRD DER ZIELDATEINAME ALS QUELLDATEINAME UEBERNOMMEN -->
			<fl:let>myReturnControl::="${returnControl}"</fl:let>

			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->				
		</ac:else>
	</ac:if>
		
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />		
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
</target>

<target name="-FGLCopyLocal_Control_FF">
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_FF</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	<!--  "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	
	<!-- <fl:echo>FF-FALL: BIS HIERHER O.K.!!! -FGLCopyLocal_Control_FF</fl:echo> -->
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
	
	<arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="mySrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<fl:let>myReturnControl::=${returnControl}</fl:let>
	<ac:if>
		<ac:equals arg1="${myReturnControl}" arg2="false"/>										
		<ac:then>
			<echo>Linker Fall=false => Ueberspringe rechten Fall</echo>
		</ac:then>
		<ac:else>			
			<echo>Behandle rechten Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
				<param name="sPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<!-- <arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			
			<arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
			<arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="myDesta.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	

			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
			<fl:let>myReturnControl::=true</fl:let>
		</ac:else>
	</ac:if>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	

</target>

<target name="-FGLCopyLocal_Control_F_Part">
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myPart::="${sPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_F_Part</fl:echo>
	<fl:echo>fuer: ${myPart}</fl:echo>
	
	
	<!-- Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->
	<!-- <echo>src.filedir = #{split('aabcc','b')[0]}</echo> -->
	<!-- Z.B.: Hiermit holt man ggfs. den Laufwerksnamen, oder auch das letzte Element -->
	<!-- <echo>src.filedir = #{split('${myLeftPart}','\\\\')[0]}</echo> -->
	<fl:let>sfileadir::=split('${myPart}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																	

												
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>								
	<echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<fl:let>xtractedvalue::=split('${myPart}','\\\\')[${index}]; 
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	<echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!-- Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftStringZZZ' uebergeben. -->
	<fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo> 
	<fl:let>xtractedvalueTemp::=#{"format('\\%s', xtractedvalue)"}	</fl:let>
	<stringLeftStringZZZ text="${myPart}" matchstring="${xtractedvalueTemp}" returnstring="myPath" />
	<echo>Der Pfad ist: ${myPath}</echo>
	
	<!-- 4. Packe die Werte in ein Array -->
	<arrayInitJsZZZ isize="0" arrayreturn="fileadir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt. -->
	<arrayAppendJsZZZ arrayinput="${fileadir}" valueinput="${myPath}" arrayreturn="myFileadir" sflagcontrol="" />
	<!-- <arrayDebugJsZZZ arrayinput="${myFileadir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

	<arrayInitJsZZZ isize="0" arrayreturn="fileaname"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayAppendJsZZZ arrayinput="${fileaname}" valueinput="${xtractedvalue}" arrayreturn="myFileaname" sflagcontrol="" />
	<!-- <arrayDebugJsZZZ arrayinput="${myFileaname}" ilevel="1"/ --><!-- Ausgabe des neuen Arrays -->	
	
		
	<!-- Rückagebwerteckagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="true" />
	<arrayCopyJsZZZ arrayinput="${myFileadir}" arrayreturn="returna.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${myFileaname}" arrayreturn="returna.filename" sflagcontrol="" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>

<target name="-FGLCopyLocal_Control_D_Part">
	<!-- Fall: Hole den Verzeichnisnamen aus dem rechten Teil und verwende die ermittelten Dateinamen aus dem linken Teil. -->	
	<fl:let>myPart::="${sPart}"</fl:let>
	<fl:let>myAFilename::="${saFilename}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_D_Part</fl:echo>
	<fl:echo>fuer: ${myPart}</fl:echo>
	<fl:echo>fuer: ${myAFilename}</fl:echo>
		
	<!-- Packe die Verzeichniswerte in ein Array. UND ZWAR so haeufig wie Dateien vorhanden sind. -->
	<!-- 1. Ermittle Anzahl der Dateien, das ist der einzige Grund warum myAFilename übergeben wird. -->
	<arrayElementCountJsZZZ arrayinput="${myAFilename}" ireturn="iSize"/>
	<echo>ArrayGroesse der Dateien: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
	
	<!-- 2. Fuellen des neuen Arrays in einer Schleife -->
	<ac:for param="icounter" end="${iSize}">
		<sequential>
			<arrayInitJsZZZ isize="0" arrayreturn="myAFiledir"/> <!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
			<arrayAppendJsZZZ arrayinput="${myAFiledir}" valueinput="${myPart}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myAFiledir" sflagcontrol="" />
		</sequential>
	</ac:for>
	<!-- <arrayDebugJsZZZ arrayinput="${myAFiledir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Rückgabewerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="true" />	
	<arrayCopyJsZZZ arrayinput="${myAFiledir}" arrayreturn="returna.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>

<!-- ## Loeschanalyse/control Targets ########################################## -->
<target name="-FGLDelLocal_Main"><!-- Parameter controlString: Noch nix -->
	<fl:let>sScript::='-FGLDelLocal_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
	
	<fl:let>myControlString::='${controlString}'</fl:let> 	
	<echo>ControlString: ${myControlString}</echo>	
	<arrayCopyJsZZZ arrayinput="${saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />	
	
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	
	
	<fl:let>bGoon::=true</fl:let>
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	
	<ac:if>
		<not>			
			<equals arg1="true" arg2="${bGoon}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->				
		</not>		
		<ac:then>							
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>	
		<ac:else>	
			<!-- Merke:
				Für VMD Dateien ist es möglich, dass die gleiche VM auf veschiedenen Rechnern läuft.
				Darum sicherheitshalber und zum Abgleich jede Datei noch mit einem Postfix _RECHNERNAME ausstatten 
				DAS GIBT ES HIER NICHT. -->		
			
			<!--### Lösche die Dateien, beschrieben durch die beiden Arrays  ##################### -->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
			<antcallback target="-FGLDelLocal_Delete" return="returnControl,returnControlString">					
				<param name="saTotal.filedir" value="${mysaTotal.filedir}"/>
				<param name="saTotal.filename" value="${mysaTotal.filename}"/>				
			</antcallback>
			<fl:let>myReturnControl::="${returnControl}"</fl:let>
			<!--<fl:let>myReturnControlString::="${returnControlString}"</fl:let>	-->
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
		</ac:else>
	</ac:if><!-- Anzahl der Dateien pruefen -->

		</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>		
		
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${myReturnControlString}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /> --><!-- Merke: So gibt man einen Arraywertzurueck -->
</target>
<target name="-FGLDelLocal_Delete">
	<fl:let>sScript::='-FGLDelLocal_Delete: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
    <arrayCopyJsZZZ arrayinput="${saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />	

		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	
	<fl:let>bGoon::=true</fl:let>
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.filedir}" ireturn="mysaTotal.filedir.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<!--<echo>Anzahl der Eintraege im Verzeichnisarray: ${mysaTotal.filedir.iSize}</echo>-->
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.filename}" ireturn="mysaTotal.filename.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<!--<echo>Anzahl der Eintraege im Dateiarray: ${mysaTotal.filename.iSize}</echo>-->	
	<ac:if>
		<or>
			<equals arg1="0" arg2="${mysaTotal.filedir.iSize}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->		
			<equals arg1="0" arg2="${mysaTotal.filename.iSize}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->		
		</or>		
		<ac:then>							
			<fl:let>myReturnString::="Keine Dateien in einem der Arrays => keine Verarbeitung"</fl:let>			
			<fl:let>bGoon::=false</fl:let>
		</ac:then>
	</ac:if>
	
	<ac:if>		
		<and>
			<not>
				<equals arg1="${mysaTotal.filedir.iSize}" arg2="${mysaTotal.filename.iSize}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
			</not>		
			<equals arg1="true" arg2="${bGoon}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->		
		</and>		
		<ac:then>							
			<fl:let>myReturnString::="Anzahl der Eintraege in den Arrays unterschiedlich => keine Verarbeitung"</fl:let>
			<fl:let>bGoon::=false</fl:let>
		</ac:then>
	</ac:if>
			
	<!-- Leite das Kopieren ein -->
	<ac:if>
		<equals arg1="true" arg2="${bGoon}"/>
			<ac:then>
				<ac:if>
					<equals arg1="1" arg2="${mysaTotal.filename.iSize}"/><!-- Merke: man muss doch tatsächlich ein Fallunterscheidung einbauen, da in ac:for (des aufzurufenden copy Targets) nicht beide Parameter 0 (also gleich) sein dürfen. -->			
					<ac:then>	
						<!-- ###### LOESCHE NUR EINEN WERT ############## -->
						<!--<fl:let>mysFiledir::=''</fl:let>-->
						<arrayGetJsZZZ arrayinput="${mysaTotal.filedir}" index="0" arrayget="mysFiledir" sflagcontrol=""/>	
						<!--<echo>Eintrag 0 im Verzeichnisarray: ${mysFiledir}</echo>-->											
						<arrayGetJsZZZ arrayinput="${mysaTotal.filename}" index="0" arrayget="mysFilename" sflagcontrol=""/>										
						<!--<echo>Eintrag 0 im Dateiarray: ${mysFilename}</echo>-->
						
						<!--<propertyregex property="mytemp" input="${mysFiledir}" regexp="\\" replace="\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur verdoppeln reicht nicht -->
						<!--<propertyregex property="mytemp" input="${mysFiledir}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
						
						<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
						<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
							<param name="stringInput" value="${mysFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							<param name="intNumber" value="1" />
						</antcallback>
						
						<!--<fl:let>mysFiledirNormed::='${mytemp}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
						<fl:let>mysFiledirNormed::='${returnString}'</fl:let>
						<echo>${sScript}Normierter Verzeichniseintrag: ${mysFiledirNormed}</echo>
						
						<!-- SITUATION: Kopiert man mysFilename in eine andere Variable, geht scheinbar die Referenz verloren.
                                  ABER: Warum passiert das nur beim sFiledir?
							    LÖSUNG: Die einfachen Backslashe verhindern die Übertragung als Parameter für den antcallback. Man muss den Wert in Hochkommata setzen.-->				
						
						<antcallback target="-FGLDelLocal_DeleteFileSingle" return="returnControl,returnControlString">					
							<param name="sFiledir" value="${mysFiledirNormed}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->							
							<param name="sFilename" value="${mysFilename}"/>						
						</antcallback>	
						<fl:let>myReturnControl::="${returnControl}"</fl:let>						
						<!--<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>-->
						<ac:var name="myReturnControlString" value="${returnControlString}"/>						
						<ac:if>
							<equals arg1="${myReturnControl}" arg2="false" />
							<ac:then>		
									<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - '${myReturnControlString}'" />				
									<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
							</ac:then>
							<ac:else>						
							</ac:else>
						</ac:if>
					</ac:then>
					<ac:else> 
						<!-- 20160221: TODO GOON NOCH KAPUTT -->					
						<antcallback target="-FGLDelLocal_DeleteFileByFile" return="returnControl,returnControlString">					
							<param name="saTotal.sFiledir" value="${mysaTotal.filedir}"/>
							<param name="saTotal.sFilename" value="${mysaTotal.filename}"/>														
						</antcallback>
						<fl:let>myReturnControl::="${returnControl}"</fl:let>						
						<!--<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>-->
						<ac:var name="myReturnControlString" value="${returnControlString}"/>						
						<ac:if>
							<equals arg1="${myReturnControl}" arg2="false" />
							<ac:then>		
									<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFilebyFile festgestellt - '${myReturnControlString}'" />				
									<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
							</ac:then>
							<ac:else>						
							</ac:else>
						</ac:if>
					</ac:else>
				</ac:if> 
		</ac:then>
	</ac:if>
	
	
	</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>		
	
			
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${myReturnControlString}" />			
</target>
<target name="-FGLDelLocal_DeleteFileSingle"> 
	<fl:let>sScript::='-FGLDelLocal_DeleteFileSingle: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<!-- Durch dieses gekapselte Target kann in antcallback in einer Schleife eingebaut werden, der dann sowohl für den ubound=0 als auch für den ubound > 0 Fall aufgerufen werden kann. -->
	<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
	<ac:var name="myReturnControl" value="true" unset="true"/>
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
	
	<!-- Uebernahme von Einzelwerten -->
	<fl:let>myDir::='${sFiledir}'</fl:let><!-- Warum geht hier die Referenz verloren? Das muss mit den Backslashes zu tun haben. Ausserdem muss der Wert mit Backslashes in Hochkommata übertragen werden, quasi eine Möglichkeit es als byValue zu übertragen. -->
	<fl:let>myFile::='${sFilename}'</fl:let>
	
	<!-- Uebernahme von Array Werten -->
	<!--<arrayCopyJsZZZ arrayinput="${srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />-->

	<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>

	<fl:when test="null('${myFile}')">
		<echo>Uebergabeparameter ist Null (myFile)</echo>
		<fl:fail message="Uebergabeparameter ist Null (myFile)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	<fl:when test="'${myFile}'==''">
		<echo>Uebergabeparameter ist Leerwert (myFile)</echo>
		<fl:fail message="Uebergabeparameter ist Leerwert (myFile)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	
	<fl:when test="null('${myDir}')">
		<echo>Uebergabeparameter ist Null (myDir)</echo>
		<fl:fail message="Uebergabeparameter ist Null (myDir)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	<fl:when test="'${myDir}'==''">
		<echo>Uebergabeparameter ist Leerwert (myDir)</echo>
		<fl:fail message="Uebergabeparameter ist Leerwert (myDir)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>	
	<!--<fl:echo>Uebergabeparameter sind (myDir = myFile):  ${myDir} = ${myFile}</fl:echo>-->
																
	<!-- ### Lösche anhand des Verzeichnis- und Dateinamens -->
	<!-- TODO Fange Fehler ab, wenn eine Datei / ein Verzeichnis nicht (mehr) vorhanden ist -->
	<!-- TODO GOON noch kaputt: Den Fall abfangen, falls eine Datei nicht gelöscht werden kann, wg. Rechte, in anderem Programm geöffnet, etc. -->
	<!-- TODO GGON noch kaputt: Prüfe, ob der Backslash am Emde steht, ergänze ihn falls notwendig -->
	<echo>Deleting File ${myDir}${myFile}</echo>
											
    <!-- Dokumentation: -->											
	<!-- 	Relative Pfade verwenden, auch beim Löschen?:
	<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
	<fileset dir="//${mySrc.filedir}">		 -->
	
	<!-- Von mir verwendetere Ausdruck zum Löschen von Verzeichnissen, nur wenn sie leer sind.
	<delete includeemptydirs="true">
		<fileset dir="onlyifempty" excludes="**/*" />
	</delete>       -->
	
	<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
	<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
					
	<!-- absolute Pfade verwenden: -->
	<!-- Das eigentliche Löschen beim Test temporaer raus, sonst muss man sich immer wieder neu die Testdateien hinlegen 
	<delete includeEmptyDirs="true"> -->
		<fileset dir="${myDir}" includes="${myFile}" defaultexcludes="false"><!-- z.B. *.svn Dateien gehoeren zu den Defautlexcludes, d.h. wuerden nicht geloescht. -->		
														
			<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
			<include name="${myFile}" />				
		</fileset>	
		
		<!-- Lösche das Ausgangsverzeichnis, wenn es leer ist (was durch includeEmptyDirs='true' gesteuert wird. -->
		<fileset dir="${myDir}" excludes="**/*" defaultexcludes="false" /><!-- z.B. *.svn Dateien gehoeren zu den Defautlexcludes, d.h. wuerden nicht geloescht. -->							
		<!-- Das eigentliche Löschen beim Test temporaer raus, sonst muss man sich immer wieder neu die Testdateien hinlegen 
	</delete>-->
	
		<!-- Problem: Damit wird aber nicht der ganze Pfad gelöscht, falls er nur aus leeren Verzeichnissen besteht. -->
		<!-- Lösungsansatz: Mache eine Funktion, mit der man einen String in ein Array zerlegen kann.
		                    Dieses Array dann in einer Schleife durchgehen -->
		<!-- ABER: Delete Target erlaubt keine anderen Scriptdefs innerhalb. 
		                 Daher 1) ein neues/eigenes  delete Targets für Verzeichnisse verwenden 
						    und 2) das Array ausserhalb dieses neuentargets aufbauen und dieses neue Target in der Schleife ausführen -->
		<!--<echo>Exploding directory path to array: ${myDir}</echo>-->
		<arrayInitJsZZZ isize="0" arrayreturn="myReturnArray"/>	<!-- Das Testarray wieder neu initialisieren -->
		<fl:let>sDelimiter::='\\'</fl:let><!-- escapter Backslash -->
		<stringExplodeJsZZZ inputstring="${myDir}" inputdelimiter="${sDelimiter}" returnarraystring="myReturnArray" returncontrol="myReturnControl"/>
		<arrayCopyJsZZZ arrayinput="${myReturnArray}" arrayreturn="myArray" sflagcontrol="" />
		<!--<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>-->
	
		<!-- Trimme das Array, dadurch wird ein leeres Element, z.B. erzeugt durch einen abschliessenden Backslash entfernt -->
		<arrayStringTrimJsZZZ inputarraystring="${myArray}" inputcontrolstring="trim" returnarraystring="myReturnArray2" returncontrol="myReturnControl2"/>
		<ac:if>
			<equals arg1="true" arg2="${myReturnControl2}"/>
			<ac:then>			
				<!--<echo>${sScript}Array wurde getrimmt. myReturnControl2=${myReturnControl2}</echo>-->
				<arrayCopyJsZZZ arrayinput="${myReturnArray2}" arrayreturn="myArray" sflagcontrol="" />
				<!--<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>	-->						
			</ac:then>
			<ac:else>
				<!--<echo>${sScript}Nichts aus dem Array weggetrimmt. myReturnControl2=${myReturnControl2}</echo>-->
			</ac:else>			
		</ac:if>
			
	
		<!-- Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<arrayElementCountJsZZZ arrayinput="${myArray}" ireturn="myArray.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->			
		
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${myArray.iSize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<!--<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>-->
	
		<!-- Baue aus dem Array immer wieder neu den absoluten Verzeichnispfad, aber immer wieder um eine obere Indexposition weniger -->
		<!-- Verwende dazu eine Schleife und inputindexhigh wird darin immer um 1 reduziert. -->
		<!-- <ac:for param="i" end="1" begin="1"> --><!-- nettes Attribut: beginn -->
		<!-- <ac:for param="icounter" end="${iubound}" keepgoing="true">	--><!-- keepgoing sorgt dafuer, dass die Schleife selbst nicht abgebrochen wird. Der Fehler würde anschliessend geworfen. -->
		<ac:for param="icounter" end="${iubound}" >
		<sequential>
			<!--<echo>${sScript}icounter=@{icounter}</echo>-->
						
			<var name="op1" value="${iubound}"/>
			<var name="op2" value="@{icounter}"/>
			<var name="op" value="-"/>
			<math result="iIndexTemp" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
			<!--<echo>${sScript}Errechnete Obergrenze des Arrays fuer diesen Lauf: ${iIndexTemp}</echo>-->
			
			<arrayStringImplodeJsZZZ inputarraystring="${myArray}" inputdelimiter="\\" inputindexlow="-1" inputindexhigh="${iIndexTemp}" returnstring="myReturnStringSub" returncontrol="myReturnControlSub"/>
			<!--<echo>${sScript}Verzeichnis ${myReturnStringSub}</echo>-->
						
			<!-- TODO GOON noch kaput: Im Fehlerfall die sequential - Anweisung abbrechen. -->
			<fl:let>myReturnControl::="${returnControlSub}"</fl:let>

			<!-- Root nicht versuchen zu löschen -->			
		<isFileRootJsZZZ inputfilepath="${myReturnStringSub}" returnboolean="myReturnValue2" returncontrol="myReturnControl2" returncontrolstring="myReturnControlString2"/>
		<!--<echo message="myReturnValue2 = ${myReturnValue2}" />-->
		<ac:if>
			<and>
				<equals arg1="true" arg2="${myReturnValue2}"/>
				<equals arg1="true" arg2="${myReturnControl2}"/>
			</and>
			<ac:then>			
				<echo>${sScript}Root erreicht. Keine weitere Verarbeitung.</echo>								
			</ac:then>
			<ac:elseif>
				<and>
				<equals arg1="false" arg2="${myReturnValue2}"/>
				<equals arg1="true" arg2="${myReturnControl2}"/>
			</and>
			<ac:then>							
				<echo>${sScript}Root noch nicht erreicht. Weitere Verarbeitung moeglich.</echo>
				
				<fl:let>myDir::="${myReturnStringSub}"</fl:let>
				<!-- Das eigentliche Löschen beim Test temporaer raus, sonst muss man sich immer wieder neu die Testdateien hinlegen 
				<delete includeEmptyDirs="true"> -->
				<!-- Lösche das Verzeichnis, wenn es leer ist (was durch includeEmptyDirs='true' gesteuert wird. -->
				<!--<fileset dir="${myDir}" excludes="**/*" defaultexcludes="false" />--><!-- z.B. *.svn Dateien gehoeren zu den Defautlexcludes, d.h. wuerden nicht geloescht. -->				
			    <!-- Das eigentliche Löschen beim Test temporaer raus, sonst muss man sich immer wieder neu die Testdateien hinlegen 
				</delete>			-->
			</ac:then>
			</ac:elseif>
			<ac:else>
			    <!-- Fehlerfall -->
				<echo>${sScript}Fehler geworfen: ${myReturnControlString2}</echo>	
				<fail message="${myReturnControlString2}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->
			</ac:else>			
		</ac:if>
			
		</sequential>
		</ac:for>		

		</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
	<!-- ############### -->
	<!--<echo>${sScript} gibt zurueck: ${myReturnControlString}</echo>-->
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="'${myReturnControlString}'" />
	<!--<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="return.srcaTotal.filedir" sflagcontrol="" />--><!-- So gibt man einen Arraywertzurueck -->	
</target>
<target name="-FGLDelLocal_DeleteFileByFile">
	<fl:let>sScript::='-FGLDelLocal_DeleteFileByFile: '</fl:let>	
	<fl:let>sTrace::=""</fl:let>
	<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
	
	<!--<echo>${sScript}Uebergebene Eingangs-Arrays:</echo>-->
	<arrayCopyJsZZZ arrayinput="${saTotal.sFiledir}" arrayreturn="mysaTotal.sFiledir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.sFilename}" arrayreturn="mysaTotal.sFilename" sflagcontrol="" />
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.sFiledir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays -->	
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.sFilename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays -->	
	
	
	<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
			
	<!-- Prüfen: Alle Arrays sollen gleich lang sein.-->
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.sFiledir}" ireturn="mysaTotal.sFiledir.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.sFilename}" ireturn="mysaTotal.sFilename.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->	
	<ac:if>
		<equals arg1="${mysaTotal.sFiledir.iSize}" arg2="${mysaTotal.sFilename.iSize}" />
		<ac:then>		
				<fl:echo message="${sScript}Alle Arrays haben gleich viel Elemente: ${mysaTotal.sFilename.iSize} " />				
		</ac:then>
		<ac:else>
				<fl:fail message="${sScript}Unterschiedliche Anzahl an Elementen in den Arrays: mysaTotal.sFiledir.iSize=${mysaTotal.sFiledir.iSize} | mysaTotal.sFilename.iSize=${mysaTotal.sFilename.iSize}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:else>
	</ac:if>
	
	<!-- Merke es gibt ein antcontrib Target 'Pathtofileset' dies hier vielleicht anwenden ? -->
	
	<!-- Schleife über alle Arraypositionen-->
	<!-- TODO IDEE: Ermittle den letzten wert des arrays -->

	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mysaTotal.sFilename.iSize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<!--<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>-->
	
	<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
	<ac:for param="icounter" end="${iubound}">			
		<sequential>
			<echo>${sScript}icounter is @{icounter}</echo> 
			<arrayGetJsZZZ arrayinput="${mysaTotal.sFiledir}" index="@{icounter}" arrayget="sFiledir" sflagcontrol="raw"/>	
			<arrayGetJsZZZ arrayinput="${mysaTotal.sFilename}" index="@{icounter}" arrayget="sFilename" sflagcontrol=""/>	
			<fl:let>mysFiledir::='${sFiledir}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<!--<echo message="${sScript}@{icounter}ter:'mysFiledir' raw='${mysFiledir}'" />-->

			<!-- Aufruf des Single-File Kopiervorgang -->			
			<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
			<!-- Lösungsansatz 20160202: den 'raw' Verzeichnisstring an die stringEscapeBackslash Funktion übergeben. -->
			<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
				<param name="stringInput" value="${mysFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
				<param name="intNumber" value="1" />					
			</antcallback>			
			<fl:let>mysFiledirEscaped::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<!--<echo>${sScript}Backslash-escapeter Verzeichniseintrag: ${mysFiledirEscaped}</echo>-->
			<fl:let>mysFilename::='${sFilename}'</fl:let>
			
			<antcallback target="-FGLDelLocal_DeleteFileSingle" return="returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->							
				<param name="sFilename" value="${mysFilename}"/>						
			</antcallback>	
						
			<!-- 20160222 TODO GOON noch kaput: Im Fehlerfall die sequential - Anweisung abbrechen. -->			
			<ac:var name="myReturnControl" value="${returnControl}"/>
			<!--<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>-->
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
			<ac:if>
				<equals arg1="${myReturnControl}" arg2="false" />
				<ac:then>		
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>						
				</ac:else>
			</ac:if>
		</sequential>
		</ac:for>		

		</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<ac:var name="myReturnControlString" value="'${baz}'"/>
			<ac:var name="myReturnControl" value="false"/>
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>		
	
	<!--<echo>${sScript} gibt zurueck: ${myReturnControlString}</echo>-->
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
</target>
<!-- ### HILFSTARGETS ########################################################## -->
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-computeFilenameVMD">
		<!-- Ermittle den Dateinamen für VMD-Datei, unabhaengig davon ob auf Client oder Hostmaschine. -->
		<fl:let>myOsUsed::="${osUsed}"</fl:let>
		<fl:let>myPathClientUsed::="${pathClientUsed}"</fl:let>
	
	<!-- Auf dem Host und auf einem VMWare Clientrechner unterscheiden sich die Dateien in ihrer Namensstruktur.
	     Daher erst prüfen, ob man auf einem Client- oder auf einem Hostrechner ist. -->
		 	<!-- Die Datei auf einem Host-Rechner im Verzeichnis c:\1fgl\client -->
	<!-- TODO: Im test-Verzeichnis (also dem gleichen Verzeichnis wie diese test_ * .bat Datei) eine Rechnerspezifische Konfiguration hinterlegen.) -->		
	<antcallback target="-isHostVMD" return="returnControl,returnBoolean">
				<param name="dirPathClient" value="${myPathClientUsed}"/>				
	</antcallback>
	<echo message="Ergebnis'isHostVMD' = ${returnBoolean}" />	 
	<ac:if>
		<ac:equals arg1="${returnBoolean}" arg2="true" />
		<ac:then>
			<fl:echo>Hostrechner identifiziert.</fl:echo>
			
			<!-- Nach Fgl soll das Kürzel des Betriebssystems kommen, also z.B. FglWin7UGAKI-SRV_Installationen.txt -->
			<!-- Merke: Gross-/Kleinschreibung ist fuer den Dateinamen wichtig -->
			<antcallback target="-computeFilenameHostVMD" return="returnFilename">
				<param name="osUsed" value="${myOsUsed}"/>					
			</antcallback>	
			<fl:let>myFilename::="${returnFilename}"</fl:let>
		</ac:then>
		<ac:else>
			<fl:echo>Ggfs VMware Client auf Host identifiziert.</fl:echo>
			<!-- Prüfe, um sicherzugehen auch das mit einem Target ab. -->
			<!-- TODO GOON: Hole den Hostnamen aus einer rechnerspezifischen Konfiguration -->
			<antcallback target="-isClientVMD" return="returnControl,returnBoolean">
					<param name="dirPathClient" value="${myPathClientUsed}"/>				
					<param name="hostUsed" value="${myHostUsed}"/>				
			</antcallback>
			<ac:if>
				<ac:equals arg1="${returnBoolean}" arg2="true" />
				<ac:then>
					<fl:echo>VMware Client auf Host Rechner bestätigt.</fl:echo>
				 
					<!-- TODO GOON: Den Hostnamen in der Konfigurationsdatei hinterlegen -->
					<antcallback target="-computeFilenameClientHostNamedVMD" return="returnFilename">
						<param name="osUsed" value="${myOsUsed}"/>					
						<param name="hostUsed" value="${myHostUsed}"/>	
					</antcallback>				 
					<fl:let>myFilename::="${returnFilename}"</fl:let>
				</ac:then>
				<ac:else>
					<fl:echo>VMware Client auf Host Rechner NICHT bestätigt.</fl:echo>
					<fl:fail message="UNGEPLANTER VORZEITIGER SICHERHEITSABBRUCH: Konfiguration pruefen."/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
				</ac:else>
			</ac:if>			
		</ac:else>
	</ac:if><!-- Pruefung auf isHost -->

			<!-- Rueckgabebwerte -->			
		<ac:var name="returnFilename" value="${myFilename}" />
		<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
	</target>
 
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-computeFilenameHostVMD">
		<!-- Ermittle den Dateinamen für die Host-VMD-Datei -->
		<fl:let>myOsUsed::="${osUsed}"</fl:let>
		
		<fl:install-property-handler />
		<property environment="env" /><!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
		
		<!-- Nach Fgl soll das Kürzel des Betriebssystems kommen, also z.B. FglWin7_UGAKI-SRV_Installationen.txt -->
		<!-- Merke: Gross-/Kleinschreibung ist fuer den Dateinamen wichtig -->
		<fl:let>myFilename::="FGL${myOsUsed}_${env.COMPUTERNAME}_Installationen.txt"</fl:let><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  

		<!-- Rueckgabebwerte -->			
		<ac:var name="returnFilename" value="${myFilename}" />
		<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
	</target>
	
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-computeFilenameClientHostNamedVMD">
		<!-- Ermittle den Dateinamen für die Host-VMD-Datei -->
		<fl:let>myOsUsed::="${osUsed}"</fl:let>
		<fl:let>myHostUsed::="${hostUsed}"</fl:let>
		
		<fl:install-property-handler />
		<property environment="env" /><!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
		
		<!-- Nach Fgl soll das Kürzel des Betriebssystems kommen, also z.B. FglWin7_UGAKI-SRV_Installationen.txt -->
		<!-- Merke: Gross-/Kleinschreibung ist fuer den Dateinamen wichtig -->
		<fl:let>myFilename::="VM_FGL${myOsUsed}_${env.COMPUTERNAME}_${myHostUsed}.txt"</fl:let><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
 
		<!-- Rueckgabebwerte -->			
		<ac:var name="returnFilename" value="${myFilename}" />
		<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
	</target>
	
<!-- ######## Hilfstargets ############################################################################--> 
<target name ="-isGreaterThanZZZ" depends="-initMacrodef">
	<fl:let>sScript::='-isGreaterThanZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<!-- das isgreaterthan von antcontrib funktioniert nicht, darum diese Lösung -->
		
	<fl:let>myInputValue01::="${inputvalue01}"</fl:let>
	<fl:let>myInputValue02::="${inputvalue02}"</fl:let><!-- wichtig: In Hochkommata setzen. So wird ein call by value sichergestellt und die Referenzen gehen nicht verloren.-->
	<fl:let>returnBoolean::=false</fl:let>
		
	<!-- Wichtig: Das Makro muss in den Zeilen vorher definiert worden sein -->
	<greaterthanMacroZZZ arg1="${myInputValue01}" arg2="${myInputValue02}" resultprop="myReturnValue" />   
	<!--<echo>${sScript}${myReturnValue}</echo>-->
	<ac:if>
		<ac:equals arg1="${myReturnValue}" arg2="1" />
		<ac:then>
			<fl:let>myReturnBoolean::=true</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myReturnBoolean::=false</fl:let>
		</ac:else>		
	</ac:if>
		 		
	<!-- Rueckgabebwerte -->			
	<ac:var name="returnBoolean" value="${myReturnBoolean}" />
	<fl:let>returnControl::=true</fl:let>
	<fl:let>returnTrace::="${sScript}Alles o.k. | ${sTrace}"</fl:let>
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>


<!-- ######## Hilfstargets ############################################################################--> 
<target name ="-isLessThanZZZ" depends="-initMacrodef">
	<fl:let>sScript::='-isLessThanZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<!-- das isgreaterthan von antcontrib funktioniert nicht, darum diese Lösung -->
		
	<fl:let>myInputValue01::="${inputvalue01}"</fl:let>
	<fl:let>myInputValue02::="${inputvalue02}"</fl:let><!-- wichtig: In Hochkommata setzen. So wird ein call by value sichergestellt und die Referenzen gehen nicht verloren.-->
	<fl:let>returnBoolean::=false</fl:let>
		
	<!-- Wichtig: Das Makro muss in den Zeilen vorher definiert worden sein -->
	<lessthanMacroZZZ arg1="${myInputValue01}" arg2="${myInputValue02}" resultprop="myReturnValue" />   
	<echo>${sScript}${myReturnValue}</echo> 
	<ac:if>
		<ac:equals arg1="${myReturnValue}" arg2="1" />
		<ac:then>
			<fl:let>myReturnBoolean::=true</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myReturnBoolean::=false</fl:let>
		</ac:else>		
	</ac:if>
		 		
	<!-- Rueckgabebwerte -->			
	<ac:var name="returnBoolean" value="${myReturnBoolean}" />
	<fl:let>returnControl::=true</fl:let>
	<fl:let>returnTrace::="${sScript}Alles o.k. | ${sTrace}"</fl:let>
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>
	 	
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-stringEscapeBackslashZZZ">
	<fl:let>sScript::='-stringEscapeBackslashZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<!-- Escape den Backslash. Dies in ein Hilfstarget packen, das propertyRegex mit einer Property statt Variablen arbeitet.
							   Properties aendern aber nicht ihren Wert innerhalb eines Targets, was unguenstig fuer Schleifen ist.		-->	
	<!-- Steuerungsflag: 'encoded' -->

<!-- Scheint ein Fehler in antcontrib zu sein. Vielleicht auch alternative Lösung durch FLAKA ....
	<project xmlns:fl="antlib:it.haefelinger.flaka">

  <property name="digitA" value="42"/>
  <property name="digitB" value="23"/>
  <property name="wordA"  value="abcd"/>
  <property name="wordB"  value="efgh"/>

  <!- compare of digits ->
  <fl:when test=" '${digitA}' > '${digitB}' ">
    <echo>${digitA} gt ${digitB}</echo>
  </fl:when>

  <!- example with string compare in switch ->
  <fl:switch value="${wordA}">
    <cmp gt="${wordB}">
      <echo>${wordA} gt ${wordB}</echo>
    </cmp>
    <cmp lt="${wordB}">
    <echo>${wordA} lt ${wordB}</echo>
    </cmp>
  </fl:switch>

</project>-->
	<fl:let>mysFlagControl::="${stringInputControl}"</fl:let>
	<fl:let>mysString::="${stringInput}"</fl:let>
	<fl:let>myiNumber::="${intNumber}"</fl:let><!-- wichtig: in Hochkommata setzen. Nur so wird der Wert gerettet, weil call by value-->
	<fl:let>returnControl::=false</fl:let>
						
	<!--<echo message="${sScript}myiNumber=${myiNumber}" />-->
	<ac:if>
		<ac:equals arg1="${myiNumber}" arg2="0" />
		<ac:then>
			<!-- mache nix -->
			<fl:let>mysString::="${stringInput}"</fl:let>			
		</ac:then>
		<ac:elseif>
			<ac:equals arg1="${myiNumber}" arg2="1" />
			<ac:then>
				<echo message="${sScript}0:'mysString'=${mysString}" />
			
				<!--ac:for erwartet immer ungleiche Parameterwerte. D.h. Schleife ueber ein Element geht nicht. Darum hier separat aufrufen. --> 
				<!-- Hier: 1-mal Das eigentliche Escapen aufrufen. Man beachte die voranstehenden doppelten Minuszeichen. -->
				<antcallback target="--stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
						<param name="stringInput" value="${mysString}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
						<param name="stringInputControl" value="${mysFlagControl}" />
				</antcallback>
				
				<!--<fl:let>mysStringNormed::='${returnString}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
				<!--<echo>${sScript}Normierter Verzeichniseintrag: ${mysStringNormed}</echo>-->
				<fl:let>mysString::='${returnString}'</fl:let>
				
			</ac:then>
		</ac:elseif>
		<ac:else>
		    <!-- Merke: AntContib islessthan funktioniert nicht als condition in ac:if (weil Bug), darum meine eigene Methode nutzen -->
			<antcallback target="-isLessThanZZZ" return="returnBoolean,returnControl,returnTrace">
				<param name="inputvalue01" value="${myiNumber}"/>					
				<param name="inputvalue02" value="0"/>	
			</antcallback>				 
			<!--<echo>${sScript}returnBoolean=${returnBoolean}</echo>-->
			<!--<echo>${sScript}returnControl=${returnControl}</echo>-->
			<!--<echo>${sScript}returnTrace=${returnTrace}</echo>-->
			<fl:let>myLessThanZero::=${returnBoolean}</fl:let>
			<ac:if>
				<ac:equals arg1="${myLessThanZero}" arg2="true" />
				<ac:then>
					<fl:fail message="${sScript}Die Anzahl der Escape - Backslash kleiner 0. Unerwarteter Parameter"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>
					<!-- 3. Reduziere die Anzahl um -1 -->	
					<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
					<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
					<var name="op1" value="${myiNumber}"/>
					<var name="op2" value="1"/>
					<var name="op" value="-"/>
					<math result="myiNumberIndexed" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
					<!--<echo>${sScript}Errechneter ubound Wert: ${myiNumberIndexed}</echo>-->
					
					
					<ac:for param="icounter" end="${myiNumberIndexed}">			
						<sequential>
							<!--<echo>${sScript}icounter ist @{icounter}</echo>-->
							<echo message="${sScript}1:'mysString'=${mysString}" />
							
							<!-- Hier: x mal Das eigentliche Escapen aufrufen. Man beachte die voranstehenden doppelten Minuszeichen. -->
							<antcallback target="--stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
									<param name="stringInput" value="${mysString}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							</antcallback>
							
							<!--<fl:let>mysStringNormed::='${returnString}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
							<!--<echo>${sScript}Normierter Verzeichniseintrag: ${mysStringNormed}</echo>-->
							<fl:let>mysString::='${returnString}'</fl:let>
							
						</sequential>
					</ac:for>		
				</ac:else>		
			</ac:if>									
		</ac:else>
	</ac:if><!-- Gleichheitszeichen -->
	
	<!-- Rueckgabewerte -->
	<ac:var name="returnString" value="${mysString}" />
	<!--<echo message="${sScript}'returnString'=${returnString}" />-->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnTrace" value="${sScript} Alles ok.|${sTrace}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
</target>

<target name="--stringEscapeBackslashZZZ">
	<fl:let>sScript::='--stringEscapeBackslashZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<!-- Escape den Backslash. Dies in ein Hilfstarget gepackt, da propertyRegex mit einer Property statt Variablen arbeitet.
							   Properties aendern aber nicht ihren Wert innerhalb eines Targets, was unguenstig fuer Schleifen ist.		-->
    <!-- Steuerungsflag: 'encoded' -->
    <fl:let>mysFlagControl::="${stringInputControl}"</fl:let>							   
	<fl:let>mysString::="${stringInput}"</fl:let>
	<fl:let>returnControl::=false</fl:let>
	<fl:let>returnString::="${stringInput}"</fl:let>	

	<!-- Ggfs. ist der String durch JavaScript encoded worden, dies macht z.B. arrayAppend vom mir automatisch.
	hier also erst einmal unencoden -->	
	<stringUnencodeJsZZZ inputstring="${mysString}" returnstring="mysStringUnencoded" returncontrol="bControl" />
	<echo message="${sScript}bcontrol | mysStringUnecoded = ${bControl} | ${mysStringUnencoded}" />
	
	<!-- Das eigentliche Escapen des Backslashs -->	
	<!-- Aufruf des propertyregex Targets: Hier zum vervierfachen der Backslashe -->	
	<!-- Merke: It is important to note that when doing a "replace" operation, if the input string does not match the regular expression, then the property is not set. You can change this behavior by supplying the "defaultValue" attribute. This attribute should contain the value to set the property to in this case. -->
	            <!-- d.h. nutze 'defaultValue', sonst bleibt der Rueckgabewert leer, wenn durch die RegEx-Operation nichts gefunden wird. -->
	<propertyregex property="mytemp" input="${mysStringUnencoded}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" defaultValue="${mysString}"/><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
	<!--<echo message="${sScript}mytemp = ${mytemp}" />-->
		
	<!-- Ggfs. je nachdem wie bcontrol aussieht (s. stringUnencodeJsZZZ) den String wieder in seine Encoded Form versetzten -->
	<!-- Das ueber einen sFlagControl Parameter steuerbar machen. -->
	<if>
		<and>
			<equals arg1="${mysFlagControl}" arg2="encoded" />
			<equals arg1="${bControl}" arg2="true" />
		</and>
		<then>
			<echo message="${sScript}Encoded wiederherstellen" />
			<stringEncodeJsZZZ inputstring="${mysString}" returnstring="mysStringEncoded" returncontrol="bcontrol" />
			<fl:let>mysString::="${mysStringEncoded}"</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben-->
		</then>
		<else>
			<echo message="${sScript}Unencoded lassen" />
			
			<!-- wegen der vielen Zwischenschritte reicht auch das vervierfachen nicht.-->
	<!-- Aufruf des propertyregex Targets: Hier zum erneuten vervierfachen der Backslashe -->	
	<!-- Merke: It is important to note that when doing a "replace" operation, if the input string does not match the regular expression, then the property is not set. You can change this behavior by supplying the "defaultValue" attribute. This attribute should contain the value to set the property to in this case. 
	            d.h. nutze 'defaultValue', sonst bleibt der Rueckgabewert leer, wenn durch die RegEx-Operation nichts gefunden wird. -->
	<!--<propertyregex property="mytemp02" input="${mytemp}" regexp="\\" replace="\\\\\\\" global="true" />--><!-- das waere wieder verdoppeln -->
	<propertyregex property="mytemp02" input="${mytemp}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" defaultValue="${mytemp}"/><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
	<!--<echo message="${sScript}mytemp02 = ${mytemp02}" />-->
	<fl:let>mysString::='${mytemp02}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<!--<echo message="${sScript}'mysString'=${mysString}" />-->
	
			
			<!-- mache nix hinsichtlich codierung -->
		</else>
	</if>
		
	<!-- Rueckgabewerte -->
	<ac:var name="returnString" value="${mysString}" />
	<!--<echo message="${sScript}'returnString'=${returnString}" />-->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnTrace" value="${sScript}Alles ok.|${sTrace}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywert zurueck -->			
</target>
	
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-isHostVMD">
		<!-- Ermittle den Dateinamen für die Host-VMD-Datei -->
		<fl:let>myPathClientUsed::="${dirPathClient}"</fl:let>
		<fl:let>returnBoolean::=false</fl:let>			
		<fl:let>returnControl::=false</fl:let>
				
		<!-- Den Dateinamen tatsächlich berechnen -->
		<!-- <fl:install-property-handler /> Das ist in Untertargets nicht erlaubt!!! -->
		<!-- <property environment="env" />  Das ist in Untertargets nicht erlaubt!!! --><!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->		
		<echo>VMD_OS= ${env.VMD_OS}</echo>
		<fl:let>osUsed::='${env.VMD_OS}'</fl:let>
		<antcallback target="-computeFilenameHostVMD" return="returnFilename">
					<param name="osUsed" value="${osUsed}"/>					
		</antcallback>
		<echo message="errechneter Dateiname = ${returnFilename}" />
				
		<!-- TODO Goon : Prüfen, ob diese Datei im Clientverzeichnis existiert -->
		<!-- TODO GON: Die Konfigurationsdatei für das Projekt muss entweder eingelesen werden, oder der Parameter muss von aussen übergeben werden. 
		     project.vmd.dirPathClientFgl=c:/1fgl/client -->
		<fl:let>vmdClientFilePath ::= "${myPathClientUsed}\\${returnFilename}"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
		<echo>Pruefe Existenz der Datei: ${vmdClientFilePath}</echo>
  
		<fl:choose>
			<fl:when test=" '${vmdClientFilePath}'.tofile.exists == true ">
			<echo>Client Verzeichnis Host-VMD-Datei existiert: ${vmdClientFilePath}</echo>
			<fl:let>returnBoolean::=true</fl:let>
		</fl:when>
		<otherwise>
			<echo>Client Verzeichnis Host-VMD-Datei existiert NICHT: ${vmdClientFilePath}</echo>
			<fl:let>returnBoolean::=false</fl:let>
		</otherwise>
	</fl:choose>
    <fl:let>returnControl::=true</fl:let>		
		
		
		
		<!-- Rueckgabebwerte -->			
		<ac:var name="returnControl" value="${returnControl}" />
		<ac:var name="returnBoolean" value="${returnBoolean}" />
		<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
	</target>
	
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-isClientVMD">
		<!-- Ermittle den Dateinamen für die Host-VMD-Datei -->
		<fl:let>myPathClientUsed::="${dirPathClient}"</fl:let>
		<fl:let>myHostUsed::="${hostUsed}"</fl:let>
		<fl:let>returnBoolean::=false</fl:let>			
		<fl:let>returnControl::=false</fl:let>
				
		
				
		<!-- Den Dateinamen tatsächlich berechnen -->
		<!-- <fl:install-property-handler /> Das ist in Untertargets nicht erlaubt!!! -->
		<!-- <property environment="env" />  Das ist in Untertargets nicht erlaubt!!! --><!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->		
		
		<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${mysaTotal.sFilename.iSize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>
	
		
		<echo>VMD_OS= ${env.VMD_OS}</echo>
		<fl:let>osUsed::='${env.VMD_OS}'</fl:let>
		<antcallback target="-computeFilenameClientHostNamedVMD" return="returnFilename">
					<param name="osUsed" value="${osUsed}"/>					
					<param name="hostUsed" value="${myHostUsed}"/>	
		</antcallback>
		<echo message="errechneter Dateiname = ${returnFilename}" />
				
		<!-- TODO Goon : Prüfen, ob diese Datei im Clientverzeichnis existiert -->
		<!-- TODO GON: Die Konfigurationsdatei für das Projekt muss entweder eingelesen werden, oder der Parameter muss von aussen übergeben werden. 
		     project.vmd.dirPathClientFgl=c:/1fgl/client -->
		<fl:let>vmdClientFilePath ::= "${myPathClientUsed}\\${returnFilename}"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
		<echo>Pruefe Existenz der Datei: ${vmdClientFilePath}</echo>
  
		<fl:choose>
			<fl:when test=" '${vmdClientFilePath}'.tofile.exists == true ">
			<echo>Client Verzeichnis Host-VMD-Datei existiert: ${vmdClientFilePath}</echo>
			<fl:let>returnBoolean::=true</fl:let>
		</fl:when>
		<otherwise>
			<echo>Client Verzeichnis Host-VMD-Datei existiert NICHT: ${vmdClientFilePath}</echo>
			<fl:let>returnBoolean::=false</fl:let>
		</otherwise>
	</fl:choose>
    <fl:let>returnControl::=true</fl:let>		
		
		
		
		<!-- Rueckgabebwerte -->			
		<ac:var name="returnControl" value="${returnControl}" />
		<ac:var name="returnBoolean" value="${returnBoolean}" />
		<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
	</target>

</project>