<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir="."
   xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="../lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/../lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
   
  <!-- Ausgangsverzeichnis: Das Repository -->
  <property name="dest.dirRepositoryVmdPath" value="c:/1fgl/repository/Projekt_VMD" />  
  <property name="dest.dirRepositoryVmdLib" value="lib" />
  <property name="dest.dirRepositoryVmdBin" value="bin" />
  <property name="dest.dirRepositoryVmdSrc" value="src" />
  <property name="dest.dirRepositoryVmdMisc" value="misc" />
  <property name="dest.dirRepositoryVmdTest" value="test" />
  <property name="dest.dirRepositoryVmdArchive" value="vmd" />
  
  <!-- ######### CLIENT ############################################################################## -->
  <!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
  <!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
  <!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
  <property name="src.dirFglClient" value="client" /> 
  <property name="src.dirFglPath" value="C:/1fgl"/>
  <property name="src.dirFglClientPath" value="${src.dirFglPath}/${src.dirFglClient}" /> 

  <!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
  	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />
    <property name="src.dirFglClientFileName" value = "Fgl${env.COMPUTERNAME}_Installationen.txt"/><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>src.dirFglClientFilePath ::= '${src.dirFglClientFilePath}/${src.dirFglClientFileName}'</fl:let>
	<echo>Wert von src.dirFglClientFilePath=${src.dirFglClientFilePath}</echo>
	</target>
  
  <!-- ################################################################################# -->
   <target name="compile" depends="declaration, init,FglRepositoryBackup,FglCopyClient2archive,FglCopyGeneral">
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  
  <target name="init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
       
<target name="FglRepositoryBackup">
	<!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
	<property name ="dest.dirRepositoryVmdBackupPath" value="${dest.dirRepositoryVmdPath}Backups" />
  
	<echo>Creating Backup:</echo>
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade -->
	<mkdir dir="//${dest.dirRepositoryVmdPath}"/>
	<mkdir dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" />
	<mkdir dir="//${dest.dirRepositoryVmdBackupPath}"/>

	<echo>a) VmdRepository Archive:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind. -->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}"
	/>
</target>
	
	
<target name="FglCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing Files to Repository:</echo>
	<echo>a) VMD File:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
	     <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${src.dirFglClientFileName}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
		 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- Beispiel für ein antcallback, in dem aus einer Schleife ein Wert zurückgeliefert wird. -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="FglCopyGeneral">
	<!-- Schiebe die angegebenen Dateien von a nach b.
         Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist.-->
	
	<!-- 1. Rechne den Dateinamen aus -->
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	
	 <!-- Todo: Eigentlich müssen oben erst die conf - Parameter definiert werden und daraus werden dann die dest/src Parameter ggfs. geholt -->
	<property name="conf.dirRepositoryVmdPath" value="${dest.dirRepositoryVmdPath}" /> 
	<property name="conf.dirRepositoryVmdBin" value="${dest.dirRepositoryVmdBin}" />
	
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />

	<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
    <property name="conf.copyGeneralFileName" value = "Fgl${env.COMPUTERNAME}_copy_general.properties"/>
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>conf.copyGeneralFilePath ::= '${conf.dirRepositoryVmdPath}/${conf.dirRepositoryVmdBin}/${conf.copyGeneralFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte -->		
	<echo>Copy files general, by property file:</echo>
	<echo>${conf.copyGeneralFilePath}</echo>
	
	<!-- 2a. Prüfe, ob die Datei überhaupt existiert -->
	<fl:choose>
		<when test=" '${conf.copyGeneralFilePath}'.tofile.exists == true ">
			<echo>Datei existiert: ${conf.copyGeneralFilePath}</echo>

			
			
			<!-- 2. Lies den Inhalt der Datei als Properties-Datei ein. -->	
<!-- 			<loadproperties>
				<file file="${conf.copyGeneralFilePath}"/>
			</loadproperties> 
			<echo>test1 hat den Wert: ${test1}</echo> -->
			
			
				<!-- 2a. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
			<loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" />
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
			
			<!-- Test: Gib den Inhalt der Datei aus -->
			<echo>Dateiinhalt als Ganzes:</echo>
			<echo>${myfile}</echo>
	
			<!-- Test: TODO GOON : Gib den Inhalt der Datei zeilenweise aus -->
			<echo>######################################</echo>
			<echo>Dateiinhalt Zeile für Zeile:</echo>		

			<!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
			<for param="line">
				<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. sichtbarkeit-->
					<file file="${conf.copyGeneralFilePath}" />
				</tokens>
				<sequential>
					<var name="line.length" unset="true" />
					<length string="@{line}" property="line.length" />
					<if>
						<equals arg1="${line.length}" arg2="0" />
						<then>
							<echo>Zeile: 
							</echo>
						</then>
						<else>
							<fl:when test="true">
								<fl:echo>###### HALLO immer true fall ########</fl:echo>									
							</fl:when>
							<fl:when test="false">
								<fl:echo>OHJE, immer false fall</fl:echo>									
							</fl:when>
							
							<echo>Zeile: @{line}</echo>
							
						     <!-- Tryout: splitte die Zeile mit Flaka - Splitt funktion (steht in der Doku unter EL). -->
							 <!-- Schreibe das in eine Flaka - Variable -->							 							 
							 <!-- simple echo -->
							<fl:echo>linker Teil der Zeile => #{split('@{line}','=')[0]}</fl:echo><!-- beachte, dass mit dem #{ ... } die Funktion aufgerufen wird, so dass ihr Ergebnis in den String eingefügt werden kann.-->
							<fl:echo>rechter Teil der Zeile => #{split('@{line}','=')[1]}</fl:echo>
	
							 <!-- <echo>Linker Teil: list('a','b')[0]}</echo> -->
							 <!-- mal ne variable füllen -->
							 <fl:let>myLeftPart ::= split('@{line}','=')[0]</fl:let>		
							 <fl:let>myRightPart ::= split('@{line}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->
							 
							 <fl:echo>linke Variable => ${myLeftPart}</fl:echo>
							 <fl:echo>rechte Variable => ${myRightPart}</fl:echo>
														 							
							 <fl:when test="matches('${myLeftPart}','test1')">
								<fl:echo>HALLO ERSTER TEST</fl:echo>	
								<fl:echo>Typ der rechten Variable: #{typeof('${myRightPart}')}</fl:echo>								
							</fl:when>
							
							 <fl:when test="matches('${myLeftPart}','test4')">
								<fl:echo>HALLO VIERTER TEST</fl:echo>	
								<fl:echo>Typ der rechten Variable: #{typeof('${myRightPart}')}</fl:echo><!-- Immer String. Wenn die Variable nicht gefüllt ist, dann ist der Wert halt der String ${myRightPart} selbst -->
							</fl:when>
							<fl:when test="null('${myRightPart}')">
								<fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
								<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
								<fl:echo>rechte Variable ist übernommen: ${myRightPart}</fl:echo>
							</fl:when>
							 
							
							
							<fl:when test="empty '${myRightPart}'">
								<fl:echo>rechte Variable ist EMPTY, nimm den linken Teil.</fl:echo>
								<fl:let> myRightPart ::= ${myLeftPart}</fl:let>
								<fl:echo>rechte Variable ist übernommen: ${myRightPart}</fl:echo>
							</fl:when>
							
							
						</else>
					</if>
				</sequential>
			</for>
			
			
			

	<!-- 3. Der eigentliche Kopiervorgang -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
			
		</when>
		<otherwise>
				<echo>Datei existiert NICHT: ${conf.copyGeneralFilePath}</echo>
				<fl:fail message="Datei existiert NICHT: ${conf.copyGeneralFilePath}"/>
		</otherwise>
	</fl:choose>

</target>



</project>