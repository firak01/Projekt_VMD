<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">
   <!-- damit definiert man für antcontrib einen eigenen Namespace -->
   <!-- damit definiert man für FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
    <!-- ######## Scriptdefs ############################################################################--> 		
	<!-- ############################################################-->
	<scriptdef name="arrayAppendJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="valueinput" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("valueinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert: '" + objectArray[x]+ "'");
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				}
			}
						
			//3. Erweitere das Array
			icountGlobal++;
			//print("Wert anhängen an position " + icountGlobal + ": '" + myValue + "'");
			
			//TODO An dieser Stelle bei der Erweiterung arrays anzuhängen: Prüfen, ob das ein Einzelwert oder ein Array ist.
			myArrayReturn[icountGlobal]=myValue;
																						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayAppendArrayJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="array2append" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myArray2append = attributes.get("array2append");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
			
			var objectArray2append = myArray2append.split(',');  //Merke: Versuche so ein Array zu machen.							
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
						
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					};
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugebende Array
			icount=-1; 
			var icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert: '" + objectArray[x]+ "'");
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				};
			};
						
			//3. Erweitere das Array, UM ALLE ANDEREN ARRAYWERTE
			for(z in objectArray2append){
				icountGlobal++;
				print("Wert anhängen an position " + icountGlobal + ": '" + objectArray2append[z]+ "'");
				myArrayReturn[icountGlobal]=objectArray2append[z];
			};			
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayCopyJsZZZ" language="javascript">
		<!-- Hiermit man ein Array in eine anderes neues Array.
             Beispielsweise sinnvoll, wenn von einer Funktion ein neues Array zurückgegeben wird,
             man aber noch mit dem alten 'Variablennamen' weiterarbeiten möchte.			 -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			
			//Kopiervorgang, noch ohne irgendwelche FlagControl Erweiterungen.			
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
				myArrayReturn[icount]=objectArray[x];
			};
															
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################ -->
	<scriptdef name="arrayDebugJsZZZ" language="javascript">
		<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
			   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
			   - der Inhalt
			   - die Größe des Arrays			-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="arrayinput" />
		<attribute name="ilevel" />	
		<![CDATA[										 								
			var myArray = attributes.get("arrayinput");					
			var myLevel = attributes.get("ilevel");					
			if(myLevel<=0){
				
			}else{
			
			<!-- Typausgabe -->
			print("typeof myarray = " + typeof(myArray));
					
			
			var iSize=0;
			if(Array.isArray(myArray)){
				print("Array uebergeben bekommen");
				iSize = myArray.length;
				print("Arraygroesse="+iSize);
				
				//TODO: Die gleichen Ausgaben wie im KEIN ARRAY Fall.
				//- Werte
			}else{
				print("kein Array uebergeben bekommen.");
				
				var icount=0;					
				if(typeof(myArray)=="object"){
					print("Object uebergeben bekommen.");
					
					if(myLevel>=2){
					//das listet alle Methoden des objekts auf.... scheint ein String zu sein....
					//print("ALLE METHODEN DES OBJEKTS:");
					//for(x in myArray){
					//	print(x);		
					//};	
					
					print("#################################");
					print("ALLE METHODEN UND CODEINHALT DES OBJEKTS:");
					for(xx in myArray){
						print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
						print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
					};
					};//myLevel>=2;
					
					print("#################################");
					print("myArray ist jetzt leider ein String ='"+ myArray +"'");
					//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
					
					print("splitte diesen String nach Komma.");
					var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
					for(x in objectArray){
						print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					};
					
					//var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
					//for(x2 in objectArray02){
					//	print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
					//};
					
					//var objectArrayString = myArray.toString();
					//var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
					//for(z in objectArray03){
					//	print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					//};
					
					print("#################################");
					print("Versuch die Werte auszugeben: ");	
					//Merke: Voraussetzung ist:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 for(yy in objectArray){
							print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
						};
					}else{
						//print("kein Objekt");
					};
			};
			};//myLevel <= 0;
		]]>
	</scriptdef>
	
	 <!-- ############################################################ -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="ireturn" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iReturn = -1;
										
			//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
			var icount=0;
			var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
			if(typeof(objectArray)=="object"){
			for(x in objectArray){
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				}else{
					icount++;
				};				
			}							
			}else{
				iReturn=0;
			}
			
			iReturn = icount;
			
			project.setProperty(attributes.get("ireturn"), iReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################ -->	
	<scriptdef name="arrayGetJsZZZ" language="javascript">
		<!-- Hiermit holt man den Wert an einer Indexposition (beginnend mit 0)
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="index" />
		<attribute name="arrayget" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iIndex = attributes.get("index");
			var objReturn="<#!!FGLUNDEFINED!!#>";
			main:{
				if(iIndex <= -1) break main;
				
				//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
				var icount=-1;
				var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				if(typeof(objectArray)=="object"){
				for(x in objectArray){
					//print("x="+x);
					//print("objectArray[x]="+objectArray[x]);
					
					//Undefinierte, d.h. nur initialisierte Arrays abfangen
					//Sie haben die Groesse 0 und an erster Stelle das <#!!FGLUNDEFINED!!#>
					if(objectArray.length<=1 && objectArray[x]=="<#!!FGLUNDEFINED!!#>"){						
						break main;
					}else{
						icount++;
						if(icount==iIndex){
							objReturn = objectArray[x];
							break main;
						}				
					}; //end if
					}; //end for
				}; //end if(typeof(objectArray)=="object")				
			}; //end main:
			project.setProperty(attributes.get("arrayget"), objReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->		
	<scriptdef name="arrayInitJsZZZ" language="javascript">
		<!-- Hiermit faked man die Erstellung eines Arrays.
			 Da scheinbar kein "call by reference" gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="isize" />
		<attribute name="arrayreturn" />		
		<![CDATA[										 
			var mySize = attributes.get("isize");	
			//print("iSize = '" + mySize + "'");
			
			//Prüfen, ob mySize eine Zahl ist. 
			//Merke: Ist z.B. die Flaka - Variable nicht oder leer deklariert, kommt hier der Variablenname '${irgendwas}' an.
			//           Das bewirkt, dass dieses '${irgendwas}' als erstes Element in´s Array kommt und das Array sofort die Größe 1 hat, was in dem Fall nicht beabsichtigt ist.
			if(isNumber(mySize)){
				//print("eine Zahl");
				var myArrayReturn = new Array(); //Merke: Egal was man hier als Groesse angiebt [irgendwas] wird als Wert übernommen genauso wie leiglich: irgendwas
				
				if(mySize==0){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
				}
				if(mySize>=1){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					for(icount=0; icount<=mySize-1; icount++){
						myArrayReturn[icount]="<#!!FGLEMPTY!!#>";
					}												
				}								
			}else{
				//print("KEINE Zahl");
				var myArrayReturn = new Array();

				//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
				myArrayReturn="<#!!FGLUNDEFINED!!#>";
			}
						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->	
	<scriptdef name="arrayLeftBackStringJsZZZ" language="javascript">
		<!-- Hiermit schneodet man von den Werten eines Arrays einen Stringwert ab. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="sinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'before' von vorne bzw. 'behind' von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("sinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			//   UND erweitere jeden Arrayeintrag um den gewünschten String.
			//   TODO: sFlagControl auswerten, zum unterscheiden ob der String vorangestellt oder angehängt wird.
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					print("Wert wird kopiert und abgeschnitten: '" + objectArray[x]+ "' leftback von '" + myValue + "'");
					myArrayReturn[icount]=getStrLeftBackStr(objectArray[x], myValue);
				}else{
					//nix
				}
			}
						
													
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			
			//äquivalent zu JSZ - Kernel
			//@LeftBack equivalent, !!! casesensitive
			function getStrLeftBackStr(sourceStr, keyStr){
				arr = sourceStr.split(keyStr)
				arr.pop();
				return (keyStr==null | keyStr=='') ? '' : arr.join(keyStr)
			}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->	
	<scriptdef name="arrayPlusStringJsZZZ" language="javascript">
		<!-- Hiermit häng man an die Werte eines Arrays einen Stringwert an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="sinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'before' von vorne bzw. 'behind' von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("sinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			//   UND erweitere jeden Arrayeintrag um den gewünschten String.
			//   TODO: sFlagControl auswerten, zum unterscheiden ob der String vorangestellt oder angehängt wird.
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					print("Wert wird kopiert und erweitert: '" + objectArray[x]+ "' plus '" + myValue + "'");
					myArrayReturn[icount]=objectArray[x] + myValue;
				}else{
					//nix
				}
			}
						
													
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
 	<!-- ############################################################ -->		
	<scriptdef name="isBooleanZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie boolean interpretiert werden kann. -->
		<!-- Es werden Ausdrücke wie null, eins nicht in boolean umgesetzt.
		
		    In boolean umgesetzt werden:
			- Strings 0, 1 
			- Strings true, false
			
			TODO: 
			- Zahlen 0, 1
		-->
			
			
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isboolean" />
		<![CDATA[		   		  
		   var bBooleanValue = null;
		   var bIsBoolean = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   //print("myValueInput='"+myValueInput+"'");		   			
			if(isNumber(myValueInput)){
				//print("boolean liegt als Zahl vor: " + myValueInput);	
				if (myValueInput=='1') {			   
					bBooleanValue = true;
					bIsBoolean = true;
				}else if(myValueInput=='0'){
					bBooleanValue = false;
					bIsBoolean = true;
				}else{
					bBooleanValue = null;
					bIsBoolean = false;
				};
			}else{			
				//print("boolean liegt als String vor: " + myValueInput);	
				if (myValueInput=='true') {			   
				   bBooleanValue = true;
				   bIsBoolean = true;
				}else if(myValueInput=='false') {
					bBooleanValue = false;
					bIsBoolean = true;				
				}else{					
					bIsBoolean = false;
				};			
			}
						
			project.setProperty(attributes.get("valuereturn"), bBooleanValue);
			project.setProperty(attributes.get("isboolean"), bIsBoolean);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			//TODO: Diese Funktion in JSZ-Kernel Bibliotheken packen. 
			//TODO: In einer entsprechenden Scriptdef Funktion nutzen.
			function convertBoolToInt()
			{
				var testBool = true;
				result = (testBool)?1:0;
				alert(result);
			}
		 ]]>
	</scriptdef>
	
	<!-- ############################################################ -->		
	<scriptdef name="isDirectoryZZZ" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist Package notwendig
		   importClass(java.io.File);                               //Bei BasisJava darf Package nicht vorneweg stehen.
		   var text = attributes.get("text");
		   print ("start isDirectoryZZZ for: '" + text +"'");
		   //var fd = new java.io.File(text);
		   var fd = new File(text);
		   var berg = false;
		   if(fd.exists()){
		   if (fd.isDirectory()) {
			   print(fd.getPath()+" => js true");
		       berg = true;
			} else {
				print(fd.getPath()+" =>js false");
				berg = false;
			}
			}else{
					print(fd.getPath()+" =>js not existing!");
			}
			project.setProperty(attributes.get("property"), berg);
		 ]]>
	</scriptdef>
	
	<!-- ############################################################ -->		
	<scriptdef name="isFilenameRelevantVMD" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   //Überprüft, ob der eingegebenen Dateiname ein vom VMD zu verarbeitender Dateiname ist.
		   //Daraus wird dann ermittelt, ob es sich bei dem Konfigurationseintrag um ein Verzeichnis oder um einen Dateinamen handeln muss.
		   var text = attributes.get("text");
		   var berg=false;
		   print("Starte isFilenameRelevantVMD '" + text + "'");

		   //TODO: So soll man den Dateinamen aus einem String bekommen, per JavaScript.
		   //      Dies ggfs. in JSZ-Kernel uebernehmen
		   //var filename = fullPath.replace(/^.*[\\\/]/, '')
		   
		   //Hier wird aber eine schon vorhandene JAZ-Kernel Methode verwendet.
		   importPackage(Packages.basic.zBasic.util.file);
		   
		   //var test = java.lang.System.getProperty("java.class.path");
		   //println("classpath="+test);
		   
		   var sEnding = FileEasyZZZ.getNameEnd(text);
		   print("Per JAZ-Kernel ermittelte Dateiendung (aus '" + text + "'): '" + sEnding +"'");
		   
		   //Hier die für VMD relevanten Dateiendungen erfassen.
		   if(sEnding=="txt"){		   
			berg =true;
		   }
		   if(berg==true){	
			print("Dateiendung '" + sEnding +"' ist fuer das VMD Projekt relevant.");
			}else{
			print("Dateiendung '" + sEnding +"' ist fuer das VMD Projekt NICHT relevant.");
			}
		   project.setProperty(attributes.get("property"), berg);				
		 ]]>
	</scriptdef>
	
	 <!-- ########################################################### -->
	 <scriptdef name="stringLeftStringZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
	 
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
       //print("matchstring="+match);
	  
	   //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
	   var matchToEncode=match;
	   var matchEncoded = encodeMyHtml(matchToEncode);
	   //print("encoded matchstring=" + matchEncoded);
	   
	    var textToEncode=text;
		var textEncoded = encodeMyHtml(textToEncode);
	   //print("encoded textstring=" + textEncoded);
       sReturn = getStrLeftStr(textEncoded, matchEncoded);
	   
	   sReturn = unescape(sReturn);
	   //print("sReturn="+sReturn);
	   
       project.setProperty(attributes.get("returnstring"), sReturn);
	   
	   //aus JSZ - Kernel 
	   function getStrLeftStr(sourceStr, keyStr){
		return (sourceStr.indexOf(keyStr) == -1 | keyStr=='') ? '' : sourceStr.split(keyStr)[0];
		}
		
		//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
  </scriptdef>
	
	<!-- ############################################################ -->
	<scriptdef name="stringSubStringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		 ]]>
	</scriptdef>

	   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="-declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
  	
	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
  	
  
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur -->
  <property name="dest.dirRepositoryVmdLib" value="lib" />
  <property name="dest.dirRepositoryVmdBat" value="bat" />
  <property name="dest.dirRepositoryVmdSrc" value="src" />
  <property name="dest.dirRepositoryVmdMisc" value="misc" />
  <property name="dest.dirRepositoryVmdTest" value="test" />
  <property name="dest.dirRepositoryVmdArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  
  <!-- Hier wird der ggfs. übergebene Projektdateiname durch eine Hostspezifische Erweiterung uebersteuert. -->
  <!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
  <fl:let>vmdLocalFile ::= "project_${env.COMPUTERNAME}_vmd.properties"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
  <!-- <echo>Name der lokalen Steuerungsdatei waere: ${vmdLocalFile}</echo> -->
	
	<!-- Hole den Pfad aus der $vmd - Property, die in der Batch uebergeben wurde -->
	<!-- Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->	
	<fl:let>vmdUsed ::= '${vmd}'</fl:let><!-- Merke: Die Pfadangebn in der Batch sind mit Slash und nicht mit Backslash -->
   
	<!-- Konvertiere den Pfad in Windows-Format -->
	<path id="pathToConfigFile">
      <pathelement location="${vmdUsed}"/>
    </path>
    <pathconvert targetos="windows" property="project.path.fileconfig" refid="pathToConfigFile">
    </pathconvert>
    <echo>Normierter Pfad (Windows Style)= ${project.path.fileconfig}</echo>
	
	<fl:let>vmdUsed::='${project.path.fileconfig}'</fl:let>
	<fl:let>sfileadir ::= split('${vmdUsed}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die Groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																													
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>					
	 <echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<!-- <fl:let>xtractedvalue ::= split('${vmd}','/')[${index}];  -->
	<fl:let>xtractedvalue ::= split('${vmdUsed}','\\\\')[${index}];  
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	 <echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!-- Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftStringZZZ' uebergeben. -->
	<!-- <fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo>  -->
	<fl:let>xtractedvalueTemp ::= #{"format('\\%s', xtractedvalue)"}	</fl:let>
	<!-- <fl:let>xtractedvalueTemp ::= #{"format('/%s', xtractedvalue)"}</fl:let> -->
	<stringLeftStringZZZ text="${vmdUsed}" matchstring="${xtractedvalueTemp}" returnstring="myPath" />
	<echo>Der Pfad ist: '${myPath}'</echo>

  <fl:let>vmdLocalFilePath ::= "${myPath}\\project_${env.COMPUTERNAME}_vmd.properties"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
  <echo>Pruefe Existenz lokaler Uebersteuerungs-Projektdatei: ${vmdLocalFilePath}</echo>
  
  <fl:choose>
		<fl:when test=" '${vmdLocalFilePath}'.tofile.exists == true ">
			<echo>Lokale Projektdatei existiert: ${vmdLocalFilePath}</echo>
			<fl:let>vmdUsed ::= '${vmdLocalFilePath}'</fl:let>
		</fl:when>
		<otherwise>
			<echo>Lokale Projektdatei existiert NICHT: ${vmdLocalFilePath}</echo>
			<fl:let>vmdUsed ::= '${vmd}'</fl:let>
		</otherwise>
	</fl:choose>
			
  <echo>Verwende Projektdatei: ${vmdUsed}</echo>
  <property name="projekt.configPathVmd" value="${vmdUsed}" />

	<echo>Verwendet Projektkonfiguration: ${projekt.configPathVmd}</echo>
	<loadproperties>
		<file file="${projekt.configPathVmd}"/>
    </loadproperties> 	 
	<echo>test1 hat den Wert: ${test1}</echo>
	<echo>OPERATION_MODE_VMD hat den Wert: ${OPERATION_MODE_VMD}</echo> 
	<property name="project.vmd.operation_mode" value="${OPERATION_MODE_VMD}" />  
	
	<echo>conf.dirRepositoryPath_VMD hat den Wert: ${conf.dirRepositoryPath_VMD}</echo>
	<property name="dest.dirRepositoryVmdPath" value="${conf.dirRepositoryPath_VMD}" />  
 
  <!-- TODO GOON: Prüfe die Controldateien auf Existenz. -->
  
  <!-- TODO : Prüfe die Controldatei auf Validität. -->
  	
	<!-- TODO GOON: Mache ein Target -FglCopyRepository_Main 
	                            packe darin die Property - Definitionen, die dafür wichtig sind
								Rufe -FglRepositoryBackup und -FglCopyClient2archive darin auf, über antcallback.
	-->
	                           
  	
  <!-- ######### CLIENT ############################################################################## -->
  <!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
  <!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
  <!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
  <property name="src.dirFglClient" value="client" /> 
  <property name="src.dirFglPath" value="C:/1fgl"/>
  <property name="src.dirFglClientPath" value="${src.dirFglPath}/${src.dirFglClient}" /> 

  <!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
  	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}" />
    <property name="src.dirFglClientFileName" value = "Fgl${env.COMPUTERNAME}_Installationen.txt"/><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>src.dirFglClientFilePath ::= '${src.dirFglClientFilePath}/${src.dirFglClientFileName}'</fl:let>
	<echo>Wert von src.dirFglClientFilePath=${src.dirFglClientFilePath}</echo>
	</target>
  
  <!-- ################################################################################# -->
   <target name="compile" depends="-declaration, -init,-FglRepositoryBackup,-FglCopyClient2archive,-FglCopyLocal_Main">
   <!-- Die einzelnen internen Targets / Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
   
	<!-- WIRD NICHT BENÖTIGT -->
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>

<!-- ################################################################################# -->       
<target name="-FglRepositoryBackup">
	<!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
	<property name ="dest.dirRepositoryVmdBackupPath" value="${dest.dirRepositoryVmdPath}Backups" />
  
	<echo>Creating Backup:</echo>
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade -->
	<mkdir dir="//${dest.dirRepositoryVmdPath}"/>
	<mkdir dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" />
	<mkdir dir="//${dest.dirRepositoryVmdBackupPath}"/>

	<echo>a) VmdRepository Archive:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind. -->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}"
	/>
</target>
		
<target name="-FglCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing Files to Repository:</echo>
	<echo>a) VMD File:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
	     <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${src.dirFglClientFileName}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
		 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="-FglCopyLocal_Main">
	<echo>######################################</echo>
	
	<!-- Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	
	 <!-- Todo: Eigentlich müssen oben (in Decalration) erst die conf - Parameter definiert werden und daraus werden dann die dest/src Parameter ggfs. geholt -->
	<property name="conf.dirRepositoryVmdPath" value="${dest.dirRepositoryVmdPath}" /> 
	<property name="conf.dirRepositoryVmdBat" value="${dest.dirRepositoryVmdBat}" />	
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />

	<!-- Falls der Test - Modus angestellt ist, verwende die Test-Konfigurationsdatei und rechne den Dateinamen nicht aus.-->
	<ac:if>
		<ac:equals arg1="${project.vmd.operation_mode}" arg2="test" />
		<ac:then>
			<fl:echo>testmodus</fl:echo> 
			
			<property name="conf.copyLocalFileName" value = "test_vmd.properties"/>
		</ac:then>		
		<ac:else>													
			<fl:echo>echtmodus</fl:echo>
			
			<!-- 1. Rechne den Dateinamen aus -->
			<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
				  dies passiert hier durch flaka´s install-property handler task -->
				<fl:install-property-handler />
				<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	
				<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
				<property name="conf.copyLocalFileName" value = "Fgl${env.COMPUTERNAME}_copy_local.properties"/>
		</ac:else>
	</ac:if><!-- Testmodus oder nicht -->
	
	
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryVmdPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
	<echo>Copy files general, by property file:</echo>
	<echo>${conf.copyLocalFilePath}</echo>
	
	<!-- 2a. Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<fl:when test=" '${conf.copyLocalFilePath}'.tofile.exists == true ">
			<echo>Datei existiert: ${conf.copyLocalFilePath}</echo>

			<!-- Arrays für alle Dateien, die es dann später zu kopieren gilt -->
			<arrayInitJsZZZ isize="0" arrayreturn="mySrcaTotal.filename"/>
			<arrayInitJsZZZ isize="0" arrayreturn="mySrcaTotal.filedir"/>
			<arrayInitJsZZZ isize="0" arrayreturn="myDestaTotal.filename"/>
			<arrayInitJsZZZ isize="0" arrayreturn="myDestaTotal.filedir"/>
	
		
			<!-- 2. Lies den Inhalt der Datei als Properties-Datei ein. -->	
			<!--<loadproperties>
				<file file="${conf.copyGeneralFilePath}"/>
			</loadproperties> 
			<echo>test1 hat den Wert: ${test1}</echo> -->
			
			
			<!-- 2a. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
			
			<!-- Test: Gib den Inhalt der Datei aus -->
			<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
			<!-- <echo>${myfile}</echo> -->
	
	
			<!--2b. Werte den Inhalt der Datei zeilenweise aus -->
			<!-- Beispiel für eine Schleife in ant, und wie man mit sequentials und dem @ Parameter darin arbeiten kann.  -->			
			<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
			<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
				<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
					<file file="${conf.copyLocalFilePath}" />
				</tokens>
				<sequential>
					<fl:let>myCase ::= "neue Zeile"</fl:let><!-- für jede Zeile wird der mögliche Verarbeitungsfall neu ermittelt -->
					<var name="line.length" unset="true" />
					<length string="@{line}" property="line.length" />
					<ac:if>
						<ac:equals arg1="${line.length}" arg2="0" />
						<ac:then>
							<!-- <fl:echo>Leerzeile...</fl:echo> -->
						</ac:then>
						<ac:else>													
							<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->							
							<stringSubStringZZZ text="@{line}" start="0" end="1" property="subtext" /><!-- anwenden der oben definierten scriptdef funktion substring -->
							<!-- <fl:echo message="subtext = ${subtext}" />	 -->						
							<ac:if>
								<ac:equals arg1="${subtext}" arg2="#" />
								<ac:then>
									<!-- <fl:echo>Kommentarzeile, wird uebersprungen...</fl:echo> -->
								</ac:then>
								<ac:else>
									<fl:echo>Zeile: @{line}</fl:echo>
									<!-- <echo>Steuerungszeile, wird ausgewertet...</echo> -->
									
									<!-- 2c. Splitte die Zeile mit Flaka - Splitt funktion (steht in der Flaka Doku unter EL). -->							 				 							
									<!-- <fl:echo>linker Teil der Zeile => #{split('@{line}','=')[0]}</fl:echo> --><!-- beachte, dass mit dem #{ ... } die Funktion aufgerufen wird, so dass ihr Ergebnis in den String eingefügt werden kann.-->
									<!-- <fl:echo>rechter Teil der Zeile => #{split('@{line}','=')[1]}</fl:echo> -->
	
									<!-- Schreibe das in eine Flaka - Variable -->		
									<fl:let>myLeftPart ::= split('@{line}','=')[0]</fl:let>		
									<fl:let>myRightPart ::= split('@{line}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
									<fl:echo>Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
									<fl:echo>Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
														 							
									<!-- TODO: Idee: in der initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
									<fl:when test="null('${myRightPart}')">
										<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): @{line}</echo>
										<fl:fail message="Rechter Teil der Steuerungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
										<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
										<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
											 <fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										     <fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>
									<fl:when test="null('${myLeftPart}')">
										<echo>Linker Teil der Steuerungsanweisung existiert nicht (von...): @{line}</echo>
										<fl:fail message="Linker Teil der Steuerungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
										<!-- Merke: Das wäre beim Kopieren einer Datei von einem feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
										<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
											 <fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										     <fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>
									
									<!-- TODO noch kaputt: IDEE: Normiere hier den möglichen Dateipfad nach Windows Style -->
									<!-- Wie oben bei der Ermittlung der Projektdatei, die in der Batch definiert wurde.
									     Das Problem hier ist, das eine Property gefüllt wird und sich diese Property nie im Wert ändert -->
									<!--<path id="pathTempLeft">
									  <pathelement location="${myLeftPart}"/>
									</path>
									<pathconvert targetos="windows" property="part.path.temp.left" refid="pathTempLeft">
									</pathconvert>
									<echo>Normierter Pfad (Windows Style)= ${part.path.temp.left}</echo>
									
									<path id="pathTempRight">
									  <pathelement location="${myRightPart}"/>
									</path>
									<pathconvert targetos="windows" property="part.path.temp.right" refid="pathTempRight">
									</pathconvert>
									<echo>Normierter Pfad (Windows Style)= ${part.path.temp.right}</echo> -->
									
									
									<!-- ### Ermittle hier den Fall. Schreibe den Wert in diese Variable und fülle damit ein Array -->
									<fl:let>myCase ::= "undefined"</fl:let>																										
									<antcallback target="-FGLCopyLocal_Analyze" return="returnAnalyse, returnString">
										<param name="leftPart" value="${myLeftPart}"/>
										<param name="rightPart" value="${myRightPart}"/>
										<!-- <param name="leftPart" value="${part.path.temp.left}"/>
										<param name="rightPart" value="${part.path.temp.right}"/> -->
									</antcallback>
											
									<fl:echo>Ergebnis der Analyse: ${returnString}</fl:echo>
									<fl:let>myAnalyze ::= "${returnString}"</fl:let>
									
                                    <!--### Aufruf des Controllers der verschiedenen Fälle ####################-->									
									<antcallback target="-FGLCopyLocal_Control" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
												<param name="analyze" value="${myAnalyze}"/>
												<param name="leftPart" value="${myLeftPart}"/>
												<param name="rightPart" value="${myRightPart}"/>
											<!-- 	<param name="leftPart" value="${part.path.temp.left}"/>
												<param name="rightPart" value="${part.path.temp.right}"/>	 -->											
									</antcallback>
									<fl:let>mySrca.filedir ::= "${returnSrca.filedir}"</fl:let>
									<fl:let>mySrca.filename ::= "${returnSrca.filename}"</fl:let>
									<fl:let>myDesta.filedir ::= "${returnDesta.filedir}"</fl:let>
									<fl:let>myDesta.filename ::= "${returnDesta.filename}"</fl:let>
									
									
									<!-- TODO GOON 20150719: Hänge die zurückgelieferten Arrays an die schon existierenden an -->																	
									<!-- myStringaLeftTotal
									     myStringaRightTotal
									-->
									<ac:if>
										<equals arg1="${returnControl}" arg2="true"/>
										<ac:then>
											<fl:echo>Ergebnis von -FGLCopyLocal_Control: ${returnControl}, haenge Array an.</fl:echo>
											<arrayAppendArrayJsZZZ arrayinput="${mySrcaTotal.filedir}" array2append="${mySrca.filedir}" arrayReturn="myArrayTotal"/>
											<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />
			
											<arrayAppendArrayJsZZZ arrayinput="${mySrcaTotal.filename}" array2append="${mySrca.filename}" arrayReturn="myArrayTotal"/>
											<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" />
			
											<arrayAppendArrayJsZZZ arrayinput="${myDestaTotal.filedir}" array2append="${myDesta.filedir}" arrayReturn="myArrayTotal"/>
											<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" />
												
											<arrayAppendArrayJsZZZ arrayinput="${myDestaTotal.filename}" array2append="${myDesta.filename}" arrayReturn="myArrayTotal"/>
											<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="myDestaTotal.filename" sflagcontrol="" />
										</ac:then>
										<ac:else>
											<fl:echo>Ergebnis von -FGLCopyLocal_Control: ${returnControl} => kein Arraywert anzuhaengen.</fl:echo>
										</ac:else>
									</ac:if>
						</ac:else>
					</ac:if>
					</ac:else>
					</ac:if>
				</sequential>
			</for>		
			
			
			<arrayElementCountJsZZZ arrayinput="${myDestaTotal.filename}" ireturn="iSize.SrcaTotal.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
			<echo>Anzahl der Dateien: ${iSize.SrcaTotal.filename}</echo>
			<ac:if>
				<equals arg1="0" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
				<ac:then>
					<echo>Keine Dateien im Array => keine Verarbeitung</echo>
				</ac:then>
				<ac:else>	
					<!-- Für VMD Dateien ist es möglich, dass die gleiche VM auf veschiedenen Rechnern läuft -->
					<!-- Darum sicherheitshalber und zum Abgleich jede Datei noch mit einem Postfix _RECHNERNAME ausstatten -->
					<!-- Führe aus Sicherheitsgründen zuerst diesen Kopiervorgang aus, danach den Kopiervorgang für die Datei ohne Postfix. -->				
					<!--### 1. Lauf Kopiere die Dateien (incl. NAMENSERWEITERUNG) der beiden Arrays  ##################### -->

					<!-- 1. Rechne das Dateinamen aus, ergaenzt um das Postfix -->
					<!-- 1a. Dateiendung entfernen -->
					<arrayLeftBackStringJsZZZ arrayinput="${myDestaTotal.filename}" sinput=".txt" arrayreturn="myDestaTotalReduced.filename" sflagcontrol="" />
		
					<!-- 1b. Hostnamen und Endung ausrechnen -->
					<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
							dies passiert hier durch flaka´s install-property handler task -->
					<fl:install-property-handler />
					<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->			
					<fl:let>sHostSuffix ::= "_${env.COMPUTERNAME}.txt"</fl:let><!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 			
					
					<!-- Hänge an alle einträge des arrays den _HOSTNAME + Endung String an -->
					<arrayPlusStringJsZZZ arrayinput="${myDestaTotalReduced.filename}" sinput="${sHostSuffix}" arrayreturn="myDestaTotalExtended.filename" sflagcontrol="" />
				
					<antcallback target="-FGLCopyLocal_Copy" return="returnCopy">					
							<param name="srca.filename" value="${mySrcaTotal.filename}"/>
							<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
							<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
							<param name="desta.filename" value="${myDestaTotalExtended.filename}"/>					
					</antcallback>
					
					
					<!--### 2. Lauf Kopiere die Dateien der beiden Arrays #####################-->
					<antcallback target="-FGLCopyLocal_Copy" return="returnCopy">					
							<param name="srca.filename" value="${mySrcaTotal.filename}"/>
							<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
							<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
							<param name="desta.filename" value="${myDestaTotal.filename}"/>					
					</antcallback>				
				</ac:else>
			</ac:if><!-- Anzahl der Dateien pruefen -->
		</fl:when><!-- Existiert die Konfigurationsdateie -->
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
				<echo>Konfigurations-Datei existiert NICHT: ${conf.copyLocalFilePath}</echo>
				<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</otherwise>
	</fl:choose>

</target>
<!-- ######################################################################### -->
<target name="-FGLCopyLocal_Copy">
<!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->

			<fl:let>mySrcaTotal.filedir ::= "${srca.filedir}"</fl:let>
			<fl:let>mySrcaTotal.filename ::= "${srca.filename}"</fl:let>
			<fl:let>myDestaTotal.filedir ::= "${desta.filedir}"</fl:let>
			<fl:let>myDestaTotal.filename ::= "${desta.filename}"</fl:let>

			<arrayElementCountJsZZZ arrayinput="${mySrcaTotal.filename}" ireturn="iSize.SrcaTotal.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
			<echo>Anzahl der Dateien: ${iSize.SrcaTotal.filename}</echo>
			<ac:if>
				<equals arg1="0" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
				<ac:then>
					<echo>Keine Dateien im Array => keine Verarbeitung</echo>
				</ac:then>
				<ac:else>					
					<!-- Leite das Kopieren ein -->
					<ac:if>				
					<equals arg1="1" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich ein Fallunterscheidung einbauen, da in ac:for (des aufzurufenden copy Targets) nicht beide Parameter 0 (also gleich) sein dürfen. -->
					<ac:then>			
						<antcallback target="-FGLCopyLocal_CopyFileSingle" return="returnCopy">					
								<param name="srca.filename" value="${mySrcaTotal.filename}"/>
								<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
								<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
								<param name="desta.filename" value="${myDestaTotal.filename}"/>					
						</antcallback>					
					</ac:then>
					<ac:else> 
					<antcallback target="-FGLCopyLocal_CopyFileByFile" return="returnCopy">					
								<param name="srca.filename" value="${mySrcaTotal.filename}"/>
								<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
								<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
								<param name="desta.filename" value="${myDestaTotal.filename}"/>					
						</antcallback>
					</ac:else>
					</ac:if> 
				</ac:else>
			</ac:if>



</target>
<target name="-FGLCopyLocal_CopyFileByFile">
	<fl:let>mySrca.filedir ::= "${srca.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${srca.filename}"</fl:let>
	<fl:let>myDesta.filedir ::= "${desta.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${desta.filename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> -->
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Prüfen: Alle Arrays sollen gleich lang sein.-->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filedir}" ireturn="iSize.Srca.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filename}" ireturn="iSize.Srca.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filedir}" ireturn="iSize.Desta.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filename}" ireturn="iSize.Desta.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<ac:if>
		<and>
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Srca.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filedir}" />
		</and>
		<ac:then>		
				<fl:echo message="Alle Arrays haben gleich viel Elemente: ${iSize.Srca.filedir} " />				
		</ac:then>
		<ac:else>
				<fl:fail message="Unterschiedliche Anzahl an Elementen in den Arrays: iSize.Srca.filedir={$iSize.Srca.filedir} | iSize.Srca.filename=${iSize.Srca.filename} | iSize.Desta.filedir=${iSize.Desta.filedir} | iSize.Desta.filename=${iSize.Desta.filename}  "/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:else>
	</ac:if>
	
	<!-- Merke es gibt ein antcontrib Target 'Pathtofileset' dies hier vielleicht anwenden ? -->
	
	<!-- Schleife über alle Arraypositionen-->
	<!-- TODO IDEE: Ermittle den letzten wert des arrays -->

	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${iSize.Srca.filename}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>Errechneter ubound Wert des Arrays: ${iubound}</echo>
	
	<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
	<ac:for param="icounter" end="${iubound}">			
		<sequential>
			<echo>icounter is @{icounter}</echo> 
			<arrayGetJsZZZ arrayinput="${mySrca.filedir}" index="@{icounter}" arrayget="mySrc.filedir"/>	
			<arrayGetJsZZZ arrayinput="${mySrca.filename}" index="@{icounter}" arrayget="mySrc.filename"/>	
			<arrayGetJsZZZ arrayinput="${myDesta.filedir}" index="@{icounter}" arrayget="myDest.filedir"/>	
			<arrayGetJsZZZ arrayinput="${myDesta.filename}" index="@{icounter}" arrayget="myDest.filename"/>	
				
			<!-- 4. Der eigentliche Kopiervorgang -->
			<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
			<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
			<echo>Pushing File ${mySrc.filedir}\${mySrc.filename} to Destination: ${myDest.filedir}\${myDest.filename} </echo>
														
			<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
			<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
						  TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
			<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
			<!-- 	Relative Pfade verwenden:
			<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
			<fileset dir="//${mySrc.filedir}">		 -->
			
			<!-- absolute Pfade verwenden: -->
			<copy todir="${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
				<fileset dir="${mySrc.filedir}">		
				<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
				<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
				<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
																
					<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
					<include name="${mySrc.filename}" />				
				</fileset>
				<globmapper from="${mySrc.filename}" to="${myDest.filename}"/>
			</copy>
		</sequential>
		</ac:for>			
</target>
<target name="-FGLCopyLocal_CopyFileSingle">
	<fl:let>mySrca.filedir ::= "${srca.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${srca.filename}"</fl:let>
	<fl:let>myDesta.filedir ::= "${desta.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${desta.filename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> -->
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
		

	<!-- ###### KOPIERE NUR EINEN WERT ############## -->
	<arrayGetJsZZZ arrayinput="${mySrca.filedir}" index="0" arrayget="mySrc.filedir"/>	
	<arrayGetJsZZZ arrayinput="${mySrca.filename}" index="0" arrayget="mySrc.filename"/>	
	<arrayGetJsZZZ arrayinput="${myDesta.filedir}" index="0" arrayget="myDest.filedir"/>	
	<arrayGetJsZZZ arrayinput="${myDesta.filename}" index="0" arrayget="myDest.filename"/>	
			
	<!-- 4. Der eigentliche Kopiervorgang -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing File ${mySrc.filedir}\${mySrc.filename} to Destination: ${myDest.filedir}\${myDest.filename} </echo>
													
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
	<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
				  TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
	<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
	<!-- 	Relative Pfade verwenden:
	<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
	<fileset dir="//${mySrc.filedir}">		 -->
	
	<!-- absolute Pfade verwenden: -->
	<copy todir="${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
		<fileset dir="${mySrc.filedir}">		
		<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
		<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
														
			<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
			<include name="${mySrc.filename}" />				
		</fileset>
		<globmapper from="${mySrc.filename}" to="${myDest.filename}"/>
	</copy>
	
</target>

<target name="-FGLCopyLocal_Analyze">
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	<fl:let>myCaseTotal ::= ""</fl:let>

	<!-- Meke: Die Analyse der beiden Teile links/rechts ist gleich. Daher dies in ein target ausgelagert, das dann jeweils aufgerufen wird. -->	
	<antcallback target="-FGLCopyLocal_AnalyzePart" return="returnControl,returnString">					
			<param name="sPartToAnalyze" value="${myLeftPart}"/>											
	</antcallback>	
	<fl:let>myCaseLeft ::= "${returnString}"</fl:let>	

	<isBooleanZZZ valueinput="${returnControl}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test="${myValueIsBoolean}==true">
			<fl:choose>
				<fl:when test="${myBooleanValue}==true">
					<echo>Analyze des linken Teils war erfolgreich. Starte Analyze des rechten Teils.</echo>
					<antcallback target="-FGLCopyLocal_AnalyzePart" return="returnControl,returnString">					
						<param name="sPartToAnalyze" value="${myRightPart}"/>											
					</antcallback>
					<fl:let>myCaseRight ::= "${returnString}"</fl:let>
					<fl:let>myCaseTotal ::= "${myCaseLeft}${myCaseRight}"</fl:let>
				</fl:when>	
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<echo>Analyze des linken Teils war NICHT erfolgreich. Spare mir die Auswertung des rechten Teils.</echo>
				</otherwise>
			</fl:choose>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>Auswertung vom linken Teil mit Fehler. Spare mir die Auswertung des rechten Teils.</echo>
		</otherwise>
	</fl:choose>
			
	<echo>Soweit ermittelter Fall: ${myCaseTotal}</echo>
	<fl:let>returnAnalyze ::= ${returnControl}</fl:let>
	<fl:let>returnString ::= "${myCaseTotal}"</fl:let>										
</target>
<target name="-FGLCopyLocal_AnalyzePart">
	<fl:let>myPart ::= "${sPartToAnalyze}"</fl:let>
	
	<!-- Prüfe, ob Datei vom Linken Teil existiert -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test=" '${myPart}'.tofile.exists == true ">
			<echo>Datei/Verzeichnis existiert: ${myPart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${myPart}" property="myisdirectoryPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<echo>Teil: isdirectory=${myisdirectoryPart}</echo>
														
			<fl:when test="${myisdirectoryPart} == true">
					<!-- A) Teil - Verzeichnis-Fall: -->
					<echo>Teil: ist Verzeichnis</echo>
					<fl:let>myCase ::= "D"</fl:let>	<!-- D=directory-->																						 
			</fl:when>
			<fl:when test="${myisdirectoryPart} != true">			
					<!-- B) Linker Teil - Dateipfad-Fall:-->
					<echo>Teil: ist KEIN Verzeichnis</echo>
					<fl:let>myCase ::= "F"</fl:let><!-- F=file-->
			</fl:when>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>Datei/Verzeichnis existiert NICHT: ${myPart}</echo>
										   <!-- Merke: kleines d , d.h. Verzeichnis existiert nicht => Datei existiert auch nicht. -->
			                               <!--        Kleines f, d.h. Datei existiert nicht, Verzeichnis aber. -->
			<!-- <fl:fail message="Datei/Verzeichnis existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
			<isFilenameRelevantVMD text="${myPart}" property="myisfilenamePart" />			
			<isBooleanZZZ valueinput="${myisfilenamePart}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
			<fl:choose>
 			<fl:when test="${myValueIsBoolean}==true">
				<!-- <echo>When:  Ein boolean Wert wurde gefunden.</echo> -->
				<fl:choose>
				<fl:when test="${myBooleanValue}==true">
					<echo>NICHT EXISTIERENDER EINTRAG GILT ALS DATEINAME: ${myPart}</echo>
					<fl:let>myCase ::= "f"</fl:let>
				</fl:when>	
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<echo>NICHT EXISTIERENDER EINTRAG GILT ALS VERZEICHNIS: ${myPart}</echo>
					<fl:let>myCase ::= "d"</fl:let>
				</otherwise>
				</fl:choose>
			</fl:when>
			<otherwise>
				<echo>Ergebnis von isFilenameRelevantVMD (= ${myValueIsBoolean} ) nicht interpretierbar: ${myPart}</echo>
				<fl:let>myCase ::= "X"</fl:let>
			</otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->	
			</fl:choose>
		</otherwise>
	</fl:choose>
	
	<echo>Teilanalyze Fall: ${myCase}</echo>
	<fl:let>returnControl ::= true</fl:let>
	<fl:let>returnString ::= "${myCase}"</fl:let>	
</target>
<target name="-FGLCopyLocal_Control">
	<fl:let>myAnalyze ::= "${analyze}"</fl:let>
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	
	<!--### START: Aufruf der verschiedenen Fälle ####################-->
	<!-- F=file, D=directory,X=not defined, f=file not found, d=directory not found.
   	      Es geht nicht nur um die Konfiguration, sondern auch darum, dass die Dateien / Verzeichnisse existieren -->
	
	<!-- Je nach Fall ein anderes Target aufrufen. Dadurch ist der Code modularer --> 	
	<!-- Jeweils ein Array erstellen 1) mit den Werten des Ausgangsdateipfads, 2) mit den Werten des Zieldateipfads -->										
	<ac:if>
		<ac:equals arg1="${myAnalyze}" arg2="dd"/>										
		<ac:then>
			<echo>Fall: Verzeichnis links nicht existent, Verzeichnis rechts nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	<ac:elseif>
		<!-- TODO noch Kaputt: Instring abprüfen auf X -->
		<ac:equals arg1="${myAnalyze}" arg2="XX"/>										
		<ac:then>
			<echo>Fall: Linker Ausdruck nicht interpretierbar, rechter Ausdruck nicht interpretierbar</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	</ac:elseif>		
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="ff"/>										
		<ac:then>
			<echo>Fall: Datei links nicht existent, rechts Datei nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="dD"/>										
		<ac:then>
			<echo>Fall: Verzeichnis links nicht existent, rechts Verzeichnis existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="fD"/>										
		<ac:then>
			<echo>Fall: Datei links NICHT existent, rechts Verzeichnis existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="Dd"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis existent, rechts Verzeichnis NICHT existent</echo>
			<!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->
			
			<!-- TODO noch Kaputt: Kopiere alle Dateien des Verzeichnisses links in das Verzeichnis nach rechts. -->
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
	<ac:or>
		<ac:equals arg1="${myAnalyze}" arg2="DF"/>										
		<ac:equals arg1="${myAnalyze}" arg2="Df"/>										
	</ac:or>
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts existierende/nicht existierende Datei</echo>
			<!-- Kopiere die rechts benannte Datei aus dem links angegebenen Verzeichnis nach rechts -->
			<antcallback target="-FGLCopyLocal_Control_DF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Controll_DF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControl ::= "${returnControl}"</fl:let>
			<fl:let>mySrca.filedir ::= "${returnSrca.filedir}"</fl:let>
			<fl:let>mySrca.filename ::= "${returnSrca.filename}"</fl:let>
			<fl:let>myDesta.filedir ::= "${returnDesta.filedir}"</fl:let>
			<fl:let>myDesta.filename ::= "${returnDesta.filename}"</fl:let>	
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FD"/>
			<ac:equals arg1="${myAnalyze}" arg2="Fd"/><!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Verzeichnis</echo>
			<antcallback target="-FGLCopyLocal_Control_FD" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Controll_FD Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControl ::= "${returnControl}"</fl:let>
			<fl:let>mySrca.filedir ::= "${returnSrca.filedir}"</fl:let>
			<fl:let>mySrca.filename ::= "${returnSrca.filename}"</fl:let>
			<fl:let>myDesta.filedir ::= "${returnDesta.filedir}"</fl:let>
			<fl:let>myDesta.filename ::= "${returnDesta.filename}"</fl:let>			
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="DD"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts Verzeichnis</echo>
			<!-- TODO: Kopiere alle Dateien aus dem einen Verzeichnis in das andere -->
			<fl:let>myReturnControl ::= false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>		
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FF"/>
			<ac:equals arg1="${myAnalyze}" arg2="Ff"/><!-- kleines f = nicht existierende Datei -->
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Datei (oder noch nicht existent)</echo>

			<antcallback target="-FGLCopyLocal_Control_FF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Controll_FF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControl ::= "${returnControl}"</fl:let>
			<fl:let>mySrca.filedir ::= "${returnSrca.filedir}"</fl:let>
			<fl:let>mySrca.filename ::= "${returnSrca.filename}"</fl:let>
			<fl:let>myDesta.filedir ::= "${returnDesta.filedir}"</fl:let>
			<fl:let>myDesta.filename ::= "${returnDesta.filename}"</fl:let>
		</ac:then>
	</ac:elseif>									
	<ac:else>
		<fl:fail message="Ungueltiges Analyseergebnis: ${myAnalyze}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
	</ac:else>											
	</ac:if>	
	<fl:let>returnControl ::= "${myReturnControl}"</fl:let>
	<fl:let>returnSrca.filedir ::= "${mySrca.filedir}"</fl:let>
	<fl:let>returnSrca.filename ::= "${mySrca.filename}"</fl:let>
	<fl:let>returnDesta.filedir ::= "${myDesta.filedir}"</fl:let>
	<fl:let>returnDesta.filename ::= "${myDesta.filename}"</fl:let>	
</target>

<target name="-FGLCopyLocal_Control_FD">
	<!-- Fall: Kopiere die benannte Datei von links nach rechts in das benannte Verzeichnis. -->	
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_FD</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	<!--  "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, return.filedir, return.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	<!-- <arrayDebugJsZZZ arrayinput="${return.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
	<!-- <arrayDebugJsZZZ arrayinput="${return.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<fl:let>mySrca.filedir ::= "${return.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${return.filename}"</fl:let>
	<fl:let>returnControl ::= "${returnControl}"</fl:let>
	<ac:if>
		<ac:equals arg1="${returnControl}" arg2="false"/>										
		<ac:then>
			<echo>Linker Fall=false => Ueberspringe rechten Fall</echo>
		</ac:then>
		<ac:else>
			<echo>Behandle rechten Fall: Uebernimm dabei die Datei Angabe vom linken Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_D_Part" return="returnControl, return.filedir">
				<param name="sPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<fl:let>myDesta.filedir ::= "${return.filedir}"</fl:let>
			<fl:let>returnControl ::= "${returnControl}"</fl:let>
			
			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
		</ac:else>
	</ac:if>
	<fl:let>returnSrca.filedir ::= "${mySrca.filedir}"</fl:let>
	<fl:let>returnSrca.filename ::= "${mySrca.filename}"</fl:let>
	<fl:let>returnDesta.filedir ::= "${myDesta.filedir}"</fl:let>
	<fl:let>returnDesta.filename ::= "${mySrca.filename}"</fl:let><!-- uebernimm die Dateien von links-->	
</target>

<target name="-FGLCopyLocal_Control_DF">
	<!-- Fall: Kopiere die recht benannte Datei vom Verzeichnis links nach rechts an den benannten Dateinamen. -->	
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_DF</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	<echo>Behandle rechten Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, return.filedir, return.filename">
		<param name="sPart" value="${myRightPart}"/>
	</antcallback>
	<fl:let>myDesta.filedir ::= "${return.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${return.filename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<fl:let>returnControl ::= "${returnControl}"</fl:let>
	
	<ac:if>
		<ac:equals arg1="${returnControl}" arg2="false"/>										
		<ac:then>
			<echo>Rechter Fall=false => Ueberspringe linken Fall</echo>
		</ac:then>
		<ac:else>
			<echo>Behandle linken Fall: Uebernimm dabei die Datei Angabe vom rechten Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_D_Part" return="returnControl, return.filedir">
				<param name="sPart" value="${myLeftPart}"/>				
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<fl:let>mySrca.filedir ::= "${return.filedir}"</fl:let>
			<fl:let>returnControl ::= "${returnControl}"</fl:let>
			
			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
		</ac:else>
	</ac:if>
	
	
	<!-- TODO GOON noch kaputt: Wie -FGLCopyLocal_Control_DF, aber erst den rechten Teil behandeln, dann den linken und dabei den Dateinamen nach links übernehmen -->
	<!-- <fl:let>returnControl ::= false</fl:let> -->
	
	
	<fl:let>returnSrca.filedir ::= "${mySrca.filedir}"</fl:let>
	<fl:let>returnSrca.filename ::= "${myDesta.filename}"</fl:let><!-- uebernimm die Werte -->
	<fl:let>returnDesta.filedir ::= "${myDesta.filedir}"</fl:let>
	<fl:let>returnDesta.filename ::= "${myDesta.filename}"</fl:let>	
</target>

<target name="-FGLCopyLocal_Control_FF">
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_FF</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	<!--  "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, return.filedir, return.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	<!-- <arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
	<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<fl:let>mySrca.filedir ::= "${return.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${return.filename}"</fl:let>
	<fl:let>returnControl ::= "${returnControl}</fl:let>
	<ac:if>
		<ac:equals arg1="${returnControl}" arg2="false"/>										
		<ac:then>
			<echo>Linker Fall=false => Ueberspringe rechten Fall</echo>
		</ac:then>
		<ac:else>			
			<echo>Behandle rechten Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, return.filedir, return.filename">
				<param name="sPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<fl:let>myDesta.filedir ::= "${return.filedir}"</fl:let>
			<fl:let>myDesta.filename ::= "${return.filename}"</fl:let>

			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
			<fl:let>returnControl ::= true</fl:let>
		</ac:else>
	</ac:if>
	<fl:let>returnSrca.filedir ::= "${mySrca.filedir}"</fl:let>
	<fl:let>returnSrca.filename ::= "${mySrca.filename}"</fl:let>
	<fl:let>returnDesta.filedir ::= "${myDesta.filedir}"</fl:let>
	<fl:let>returnDesta.filename ::= "${myDesta.filename}"</fl:let>	
</target>

<target name="-FGLCopyLocal_Control_F_Part">
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myPart ::= "${sPart}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_F_Part</fl:echo>
	<fl:echo>fuer: ${myPart}</fl:echo>
	
	
	<!-- Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->
	<!-- <echo>src.filedir = #{split('aabcc','b')[0]}</echo> -->
	<!-- Z.B.: Hiermit holt man ggfs. den Laufwerksnamen, oder auch das letzte Element -->
	<!-- <echo>src.filedir = #{split('${myLeftPart}','\\\\')[0]}</echo> -->
	<fl:let>sfileadir ::= split('${myPart}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																	

												
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>								
	<echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<fl:let>xtractedvalue ::= split('${myPart}','\\\\')[${index}]; 
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	<echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!-- Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftStringZZZ' uebergeben. -->
	<fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo> 
	<fl:let>xtractedvalueTemp ::= #{"format('\\%s', xtractedvalue)"}	</fl:let>
	<stringLeftStringZZZ text="${myPart}" matchstring="${xtractedvalueTemp}" returnstring="myPath" />
	<echo>Der Pfad ist: ${myPath}</echo>
	
	<!-- 4. Packe die Werte in ein Array -->
	<arrayInitJsZZZ isize="0" arrayreturn="myfileaname"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayAppendJsZZZ arrayinput="${myfileaname}" valueinput="${xtractedvalue}" arrayreturn="fileaname" sflagcontrol="" />
	<!-- <arrayDebugJsZZZ arrayinput="${fileaname}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<arrayInitJsZZZ isize="0" arrayreturn="myfileadir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt. -->
	<arrayAppendJsZZZ arrayinput="${myfileadir}" valueinput="${myPath}" arrayreturn="fileadir" sflagcontrol="" />
	<!-- <arrayDebugJsZZZ arrayinput="${fileadir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<fl:let>returnControl ::= true</fl:let>
	<fl:let>return.filedir ::= "${fileadir}"</fl:let>
	<fl:let>return.filename ::= "${fileaname}"</fl:let>
</target>

<target name="-FGLCopyLocal_Control_D_Part">
	<!-- Fall: Hole den Verzeichnisnamen aus dem rechten Teil und verwende die ermittelten Dateinamen aus dem linken Teil. -->	
	<fl:let>myPart ::= "${sPart}"</fl:let>
	<fl:let>myAFilename ::= "${saFilename}"</fl:let>
	<fl:echo>Start von FGLCopyLocal_Control_D_Part</fl:echo>
	<fl:echo>fuer: ${myPart}</fl:echo>
	<fl:echo>fuer: ${myAFilename}</fl:echo>
		
	<!-- Packe die Verzeichniswerte in ein Array. UND ZWAR so haeufig wie Dateien vorhanden sind. -->
	<!-- 1. Ermittle Anzahl der Dateien -->
	<arrayElementCountJsZZZ arrayinput="${myAFilename}" ireturn="iSize"/>
	<!-- <echo>ArrayGroesse der Dateien: ${iSize}</echo> --><!-- Auch diese Methode darf nur 0 zurückgeben. -->
	
	<!-- 2. Fullen des neuen Arrays in einer Schleife -->
	<ac:for param="icounter" end="${iSize}">
		<sequential>
			<arrayInitJsZZZ isize="0" arrayreturn="myAFiledir"/> <!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
			<arrayAppendJsZZZ arrayinput="${myAFiledir}" valueinput="${myPart}" arrayreturn="myArrayNew" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myAFiledir" sflagcontrol="" />
		</sequential>
	</ac:for>
	<!-- <arrayDebugJsZZZ arrayinput="${myAFiledir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Rückgabewerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<fl:let>returnControl ::= true</fl:let>
	<fl:let>return.filedir ::= "${myAFiledir}"</fl:let>
</target>

</project>