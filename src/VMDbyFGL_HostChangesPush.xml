<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">
   <!-- damit definiert man für antcontrib einen eigenen Namespace -->
   <!-- damit definiert man für FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
    <!-- ######## Scriptdefs ############################################################################--> 		
	<!-- ########################### -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<attribute name="arrayinput" />
		<attribute name="ireturn" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iReturn = -1;
										
			//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
			var icount=0;
			var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
			if(typeof(objectArray)=="object"){
			for(x in objectArray){
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				}else{
					icount++;
				};				
			}							
			}else{
				iReturn=0;
			}
			
			iReturn = icount;
			
			project.setProperty(attributes.get("ireturn"), iReturn);
		]]>
	</scriptdef>
	
	<!-- ######## Scriptdefs ############################################################################--> 		
 	<!-- ########################### -->		
	<scriptdef name="isBooleanZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie boolean interpretiert werden kann. -->
		<!-- Es werden Ausdrücke wie null, eins nicht in boolean umgesetzt.
		
		    In boolean umgesetzt werden:
			- Strings 0, 1 
			- Strings true, false
			
			TODO: 
			- Zahlen 0, 1
		-->
			
			
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isboolean" />
		<![CDATA[		   		  
		   var bBooleanValue = null;
		   var bIsBoolean = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   print("myValueInput='"+myValueInput+"'");		   			
			if(isNumber(myValueInput)){
				print("boolean liegt als Zahl vor.");	
				if (myValueInput=='1') {			   
					bBooleanValue = true;
					bIsBoolean = true;
				}else if(myValueInput=='0'){
					bBooleanValue = false;
					bIsBoolean = true;
				}else{
					bBooleanValue = null;
					bIsBoolean = false;
				};
			}else{			
				print("boolean liegt als String vor.");	
				if (myValueInput=='true') {			   
				   bBooleanValue = true;
				   bIsBoolean = true;
				}else if(myValueInput=='false') {
					bBooleanValue = false;
					bIsBoolean = true;				
				}else{					
					bIsBoolean = false;
				};			
			}
						
			project.setProperty(attributes.get("valuereturn"), bBooleanValue);
			project.setProperty(attributes.get("isboolean"), bIsBoolean);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			//TODO: Diese Funktion in JSZ-Kernel Bibliotheken packen. 
			//TODO: In einer entsprechenden Scriptdef Funktion nutzen.
			function convertBoolToInt()
			{
				var testBool = true;
				result = (testBool)?1:0;
				alert(result);
			}
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->		
	<scriptdef name="isDirectoryZZZ" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist Package notwendig
		   importClass(java.io.File);                               //Bei BasisJava darf Package nicht vorneweg stehen.
		   var text = attributes.get("text");		 
		   //var fd = new java.io.File(text);
		   var fd = new File(text);
		   var berg = false;
		   if (fd.isDirectory()) {
			   //print("js true");
		       berg = true;
			} else {
				//print("js false");
				berg = false;
			}
			project.setProperty(attributes.get("property"), berg);
		 ]]>
	</scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="substringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		 ]]>
	</scriptdef>

	   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="-declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
  	
	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
  	
  
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur -->
 <property name="dest.dirRepositoryVmdLib" value="lib" />
  <property name="dest.dirRepositoryVmdBat" value="bat" />
  <property name="dest.dirRepositoryVmdSrc" value="src" />
  <property name="dest.dirRepositoryVmdMisc" value="misc" />
  <property name="dest.dirRepositoryVmdTest" value="test" />
  <property name="dest.dirRepositoryVmdArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  <loadproperties>
  	<file file="${vmd}"/>
  	<!--<file file="${env.VMD}"/>-->
  </loadproperties> 
  <echo>test1 hat den Wert: ${test1}</echo>  	 
  <echo>conf.dirRepositoryVmdPath hat den Wert: ${conf.dirRepositoryVmdPath}</echo>
  <property name="dest.dirRepositoryVmdPath" value="c:/1fgl/repository/Projekt_VMD" />  
 
  <!-- TODO GOON: Prüfe die Controldateien auf Existenz und Validität. Setze bGOON Variablen, die dann in den Targets abgeprüft werden. -->
  	
  	
  <!-- ######### CLIENT ############################################################################## -->
  <!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
  <!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
  <!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
  <property name="src.dirFglClient" value="client" /> 
  <property name="src.dirFglPath" value="C:/1fgl"/>
  <property name="src.dirFglClientPath" value="${src.dirFglPath}/${src.dirFglClient}" /> 

  <!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
  	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}" />
    <property name="src.dirFglClientFileName" value = "Fgl${env.COMPUTERNAME}_Installationen.txt"/><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>src.dirFglClientFilePath ::= '${src.dirFglClientFilePath}/${src.dirFglClientFileName}'</fl:let>
	<echo>Wert von src.dirFglClientFilePath=${src.dirFglClientFilePath}</echo>
	</target>
  
  <!-- ################################################################################# -->
  <!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
   <target name="compile" depends="-declaration, -init,-FglRepositoryBackup,-FglCopyClient2archive,-FglCopyLocal_FillPropertyArrays">
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  
  <target name="-init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
       
<target name="-FglRepositoryBackup">
	<!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
	<property name ="dest.dirRepositoryVmdBackupPath" value="${dest.dirRepositoryVmdPath}Backups" />
  
	<echo>Creating Backup:</echo>
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade -->
	<mkdir dir="//${dest.dirRepositoryVmdPath}"/>
	<mkdir dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" />
	<mkdir dir="//${dest.dirRepositoryVmdBackupPath}"/>

	<echo>a) VmdRepository Archive:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind. -->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}"
	/>
</target>
	
	
<target name="-FglCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing Files to Repository:</echo>
	<echo>a) VMD File:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
	     <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${src.dirFglClientFileName}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
		 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- Beispiel für ein antcallback, in dem aus einer Schleife ein Wert zurückgeliefert wird. -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="-FglCopyLocal_FillPropertyArrays">
	<echo>######################################</echo>
	
	<!-- Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	
	<!-- 1. Rechne den Dateinamen aus -->
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	
	 <!-- Todo: Eigentlich müssen oben erst die conf - Parameter definiert werden und daraus werden dann die dest/src Parameter ggfs. geholt -->
	<property name="conf.dirRepositoryVmdPath" value="${dest.dirRepositoryVmdPath}" /> 
	<property name="conf.dirRepositoryVmdBat" value="${dest.dirRepositoryVmdBat}" />
	
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />

	<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
    <property name="conf.copyLocalFileName" value = "Fgl${env.COMPUTERNAME}_copy_local.properties"/>
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryVmdPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
	<echo>Copy files general, by property file:</echo>
	<echo>${conf.copyLocalFilePath}</echo>
	
	<!-- 2a. Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<fl:when test=" '${conf.copyLocalFilePath}'.tofile.exists == true ">
			<echo>Datei existiert: ${conf.copyLocalFilePath}</echo>

			<!-- 2. Lies den Inhalt der Datei als Properties-Datei ein. -->	
			<!--<loadproperties>
				<file file="${conf.copyGeneralFilePath}"/>
			</loadproperties> 
			<echo>test1 hat den Wert: ${test1}</echo> -->
			
			
			<!-- 2a. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
			
			<!-- Test: Gib den Inhalt der Datei aus -->
			<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
			<!-- <echo>${myfile}</echo> -->
	
	
			<!--2b. Werte den Inhalt der Datei zeilenweise aus -->			
			<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
			<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
				<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
					<file file="${conf.copyLocalFilePath}" />
				</tokens>
				<sequential>
					<fl:let>myCase ::= "neue Zeile"</fl:let><!-- für jede Zeile wird der mögliche Verarbeitungsfall neu ermittelt -->
					<var name="line.length" unset="true" />
					<length string="@{line}" property="line.length" />
					<ac:if>
						<ac:equals arg1="${line.length}" arg2="0" />
						<ac:then>
							<!-- <echo>Leerzeile...</echo> -->
						</ac:then>
						<ac:else>													
							<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->							
							<substringZZZ text="@{line}" start="0" end="1" property="subtext" /><!-- anwenden der oben definierten scriptdef funktion substring -->
							<!-- <echo message="subtext = ${subtext}" />	 -->						
							<ac:if>
								<ac:equals arg1="${subtext}" arg2="#" />
								<ac:then>
									<!-- <echo>Kommentarzeile, wird uebersprungen...</echo> -->
								</ac:then>
								<ac:else>
									<echo>Zeile: @{line}</echo>
									<!-- <echo>Steuerungszeile, wird ausgewertet...</echo> -->
									
									<!-- 2c. Splitte die Zeile mit Flaka - Splitt funktion (steht in der Flaka Doku unter EL). -->							 				 							
									<!-- <fl:echo>linker Teil der Zeile => #{split('@{line}','=')[0]}</fl:echo> --><!-- beachte, dass mit dem #{ ... } die Funktion aufgerufen wird, so dass ihr Ergebnis in den String eingefügt werden kann.-->
									<!-- <fl:echo>rechter Teil der Zeile => #{split('@{line}','=')[1]}</fl:echo> -->
	
									<!-- Schreibe das in eine Flaka - Variable -->		
									<fl:let>myLeftPart ::= split('@{line}','=')[0]</fl:let>		
									<fl:let>myRightPart ::= split('@{line}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
									<fl:echo>Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
									<fl:echo>Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
														 							
									<!-- TODO: Idee: in der initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
									<fl:when test="null('${myRightPart}')">
										<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): @{line}</echo>
										<fl:fail message="Rechter Teil der Steueerungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
										<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
										<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
											 <fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										     <fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>
									<fl:when test="null('${myLeftPart}')">
										<echo>Linker Teil der Steuerungsanweisung existiert nicht (von...): @{line}</echo>
										<fl:fail message="Linker Teil der Steueerungsanweisung existiert nicht: @{line}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
										<!-- Merke: Das wäre beim Kopieren einer Datei von einem feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
										<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
											 <fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										     <fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>

									<!-- TODO: Ermittle hier den Fall. Schreibe den Wert in diese Variable und fülle damit ein Array -->
									<fl:let>myCase ::= "undefined"</fl:let>
									
									<!-- Prüfe, ob Datei vom Linken Teil existiert -->
									<fl:choose>
										<fl:when test=" '${myLeftPart}'.tofile.exists == true ">
											<echo>Datei existiert (von...): ${myLeftPart}</echo>
																																	
											<!-- Prüfe, ob es ein Verzeichnis ist -->
											<isDirectoryZZZ text="${myLeftPart}" property="myisdirectoryLeftPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
											<!-- <echo>linker Teil: isdirectory=${myisdirectoryLeftPart}</echo> -->
																						
											<fl:when test="${myisdirectoryLeftPart} == true">
													<!-- A) Linker Teil - Verzeichnis-Fall: -->
													<echo>Linker Teil: ist Verzeichnis</echo>
													<fl:let>myCase ::= "V"</fl:let>																								 
											</fl:when>
											<fl:when test="${myisdirectoryLeftPart} != true">
													<!-- B) Linker Teil - Dateipfad-Fall:-->
													<echo>Linker Teil: ist KEIN Verzeichnis</echo>
													<fl:let>myCase ::= "D"</fl:let>
											</fl:when>
										</fl:when>
										<fl:otherwise>
											<echo>Datei existiert NICHT (von...): ${myLeftPart}</echo>
											<fl:let>myCase ::= "X"</fl:let>
											<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
										</fl:otherwise>
									</fl:choose>
									
										<!-- Prüfe, ob Datei vom Rechten Teil existiert -->
									<fl:choose>
										<fl:when test=" '${myRightPart}'.tofile.exists == true ">
											<echo>Datei existiert (nach...): ${myRightPart}</echo>
																																	
											<!-- Prüfe, ob es ein Verzeichnis ist -->
											<isDirectoryZZZ text="${myRightPart}" property="myisdirectoryRightPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
											<!-- <echo>rechter Teil: isdirectory=${myisdirectoryRightPart}</echo> -->
																						
											<fl:when test="${myisdirectoryRightPart} == true">
													<!-- A) Rechter Teil - Verzeichnis-Fall: -->
													<echo>Rechter Teil: ist Verzeichnis</echo>
													<fl:let>myCase ::= "${myCase}A"</fl:let>																								 
											</fl:when>
											<fl:when test="${myisdirectoryRightPart} != true">
													<!-- B) Rechter Teil - Dateipfad-Fall:-->
													<echo>Rechter Teil: ist KEIN Verzeichnis</echo>
													<fl:let>myCase ::= "${myCase}B"</fl:let>
											</fl:when>
										</fl:when>
										<fl:otherwise>
											<echo>Datei existiert NICHT (nach...): ${myRightPart}</echo>
											<fl:let>myCase ::= "${myCase}X"</fl:let>
											<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
										</fl:otherwise>
									</fl:choose>	
									<echo>Soweit ermittelter Fall: ${myCase}</echo>
												
												
									<!-- TODO GOON: Je nach Fall ein anderes Target aufrufen. Dadurch ist der Code modularer --> 	
									<!-- todo codeschnipsel unten teilweise hier wieder einfügen oder in ein extra Target packen -->
									<!-- TODO: jeweils ein Array mit den werten des Ausgangsdateipfads und des Zieldateipfads erstellen -->
									
									
						</ac:else>
					</ac:if>
					</ac:else>
					</ac:if>
				</sequential>
			</for>			
		</fl:when>
		<fl:otherwise>
				<echo>Datei existiert NICHT: ${conf.copyLocalFilePath}</echo>
				<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</fl:otherwise>
	</fl:choose>

</target>

</project>