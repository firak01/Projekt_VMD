<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">
   <!-- damit definiert man für antcontrib , bzw. FLAKA einen eigenen Namespace. Antcontrib wird hier per taskdef (siehe unten) hinzugefügt. -->
      
   <!-- ### Notepad++ Hotkeys:
        ALT & 0, ALT & 1, .... XML Tags der Ebene zusammenklappen.
        STRG & + bzw. - .... Schrift vergrößern bzw. verkleinern		-->
    
   	<!-- ### Einbinden der ZKernel - Ant Bibliotheken. Darin liegen die Scriptdefs an einer zentralen Stelle. ### -->
	<!--     Die Definiton von basedr in diesem aufrufenden Projekt hat scheinbar keine Auswirkung. Man muss ../ davorsetzen. -->
	<!--     Erstellt man in diesem importierenden Projekt ein importiertes Target, so wird das importierte Target überschrieben. -->
	<import file="../scriptdef/ZAnt_basic_zBasic_ExceptionZZZ.xml"/>
	<import file="../scriptdef/ZAnt_basic_zBasic_util_datatypeZZZ.xml"/>
	<import file="../scriptdef/ZAnt_basic_zBasic_util_datatype_ArrayZZZ.xml"/>
	<import file="../scriptdef/ZAnt_basic_zBasic_util_datatype_string_StringArrayZZZ.xml"/>
	<import file="../scriptdef/ZAnt_basic_zBasic_util_datatype_string_StringZZZ.xml"/>
	<import file="../scriptdef/ZAnt_basic_zBasic_util_file_FileEasyZZZ.xml"/>
	<import file="../scriptdef/ZAnt_basic_zBasic_util_math_MathZZZ.xml"/>
	<import file="../scriptdef/zAnt_custom_zProject_vmd_MachineRessourceZZZ.xml"/>

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
   <!-- ######## Scriptdefs ############################################################################--> 									
	
			
	
		  						   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <!-- ################################################################################# -->
  <target name="compile" depends="-declaration, -init,-FglRepository_Main,-FglVmd_Main">
  <!-- <target name="compile" depends="-declaration, -init,-FglRepository_Main">--><!-- Einzeln testen --> 
  
   <!-- Die einzelnen internen Targets / Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
   
	<!-- WIRD NICHT BENÖTIGT -->
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
	
	
  	<!-- ### Behandle Uebergabeparameter von den aufrufenden Batches / Eclipse ### -->
	<!-- Es soll gelten, dass die Werte per Batchuebergabe wichtiger sind als die Werte per Umgebungsvariable! -->
	<!-- Alternative 1: Werte entgegennehmen, die an das Ant Script per -Dvmd= bzw. -D%* uebergeben wurden. Letzeres leitet alle Argumente einer Batch an das Ant-Script weiter.-->
	<!-- Alternative 2: Werte entgegennehmen, die per Batch in eine Umgebungsvariable geschrieben wurden. -->
	
	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
		
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
	<!-- controlstring wird noch nicht verwendet, sollte aber ggfs. zur weiteren Steuerung genutzt werden -->
	<property name="controlstring" value="${nothing}"/>
    <echo message="Wert fuer controlstring= ${controlstring}"/>
	<echo>VMD CONSTROLSTRING= ${env.controlstring}</echo>
					
	<property name="vmd" value="${nothing}"/><!--Merke: In der if-Abfrage <isset property="..."></isset> funktioniert nicht immer, darum mit einer eigenen Methode prüfen -->
    <echo message="Wert fuer vmd=${vmd}"/>
	<isSetJsZZZ inputvalue="${vmd}" returnvalue="myIsSetValue" returnboolean="myValueIsSet" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<isBooleanJsZZZ inputvalue="${myValueIsSet}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<ac:if>
	 <equals arg1="${myBooleanValue}" arg2="true" />     
      <ac:then>
		<echo>VMD aus Uebergabeparameter= ${vmd}</echo>
		<fl:let>myVmdUsed::="${vmd}"</fl:let>		
	  </ac:then>
	  <ac:else>
		<echo>VMD aus Umgebungsvariable= ${env.VMD}</echo>
		<fl:let>myVmdUsed::="${env.VMD}"</fl:let><!-- Merke: Die Pfadangaben in der Batch sind mit Slash und nicht mit Backslash -->
	  </ac:else>
	 </ac:if>
	
	<property name="host" value="${nothing}"/><!--Merke: In der if-Abfrage <isset property="..."></isset> funktioniert nicht immer, darum mit einer eigenen Methode prüfen -->
    <echo message="Wert fuer host= ${host}"/>	
  	<isSetJsZZZ inputvalue="${host}" returnvalue="myIsSetValue" returnboolean="myValueIsSet" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<isBooleanJsZZZ inputvalue="${myValueIsSet}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<ac:if>
	 <equals arg1="${myBooleanValue}" arg2="true" />
      <ac:then>
		<echo>HOST aus Uebergabeparameter= ${host}</echo>
		<fl:let>myHostUsed::="${host}"</fl:let>
	  </ac:then>
	  <ac:else>
		<echo>HOST aus Umgebungsvariable = ${env.host}</echo>
		<fl:let>myHostUsed::="${env.host}"</fl:let>
	  </ac:else>
	 </ac:if>
	
  	
<!-- 	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo> -->

  	<!-- Das Betriebssystem wird ausschliesslich in der Batch ermittelt. -->
	<echo>VMD_OS= ${env.VMD_OS}</echo>
	<property name="project.vmd.os" value="${env.VMD_OS}" />
	
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur, 
	        TODO diese Werte in projekt-Konfigurationsdatei uebernehmen, 
	        nachdem sie in den "...checProperties..." Methoden aufgenommen wurden und dort als Fallback mit dem defaultwert versehen wurden. -->
  <property name="project.vmd.dirRepositoryLib" value="lib" />
  <property name="project.vmd.dirRepositoryJsscriptdef" value="jsscriptdef" />
  <property name="project.vmd.dirRepositorySrc" value="src" />
  <property name="project.vmd.dirRepositoryMisc" value="misc" />
  <property name="project.vmd.dirRepositoryTest" value="test" />
  <property name="project.vmd.dirRepositoryArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  
  <!-- Hier wird der ggfs. übergebene Projektdateiname durch eine Hostspezifische Erweiterung uebersteuert. -->
  <!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET-Befehl und ENTER --> 	  
  <fl:let>vmdLocalFile ::= "project_${env.COMPUTERNAME}_vmd.properties"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
  <!-- <echo>Name der lokalen Steuerungsdatei waere: ${vmdLocalFile}</echo> -->
	
	<!-- Hole den Pfad aus der $vmd - Property, die in der Batch uebergeben wurde -->
	<!-- Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->	
	
	<!-- Konvertiere den Pfad in Windows-Format -->
	<path id="pathToConfigFile">
      <pathelement location="${myVmdUsed}"/>
    </path>
    <pathconvert targetos="windows" property="project.path.fileconfig" refid="pathToConfigFile">
    </pathconvert>
    <echo>Normierter Pfad (Windows Style)= ${project.path.fileconfig}</echo>
	
	<fl:let>vmdUsed::='${project.path.fileconfig}'</fl:let>
	<fl:let>sfileadir ::= split('${vmdUsed}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die Groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																													
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>					
	 <echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<!-- <fl:let>xtractedvalue ::= split('${vmd}','/')[${index}];  -->
	<fl:let>xtractedvalue ::= split('${vmdUsed}','\\\\')[${index}];  
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	 <echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!-- Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftStringZZZ' uebergeben. -->
	<!-- <fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo>  -->
	<fl:let>xtractedvalueTemp ::= #{"format('\\%s', xtractedvalue)"}	</fl:let>
	<!-- <fl:let>xtractedvalueTemp ::= #{"format('/%s', xtractedvalue)"}</fl:let> -->
	<stringLeftStringJsZZZ inputstring="${vmdUsed}" inputmatchstring="${xtractedvalueTemp}" returnstring="myPath"  returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
	<echo>Der Pfad ist: '${myPath}'</echo>

  <fl:let>vmdLocalFilePath ::= "${myPath}\\project_${env.COMPUTERNAME}_vmd.properties"</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
  <echo>Pruefe Existenz lokaler Uebersteuerungs-Projektdatei: ${vmdLocalFilePath}</echo>
  
  <fl:choose>
		<fl:when test=" '${vmdLocalFilePath}'.tofile.exists == true ">
			<echo>Lokale Projektdatei existiert: ${vmdLocalFilePath}</echo>
			<fl:let>vmdUsed::='${vmdLocalFilePath}'</fl:let>
		</fl:when>
		<otherwise>
			<echo>Lokale Projektdatei existiert NICHT: ${vmdLocalFilePath} verwende Standard ${myPath}\\project_vmd.properties</echo>
			<fl:let>vmdUsed::="${myPath}\\project_vmd.properties"</fl:let>
		</otherwise>
	</fl:choose>
			
  <echo>Verwende Projektdatei: ${vmdUsed}</echo>
  <property name="projekt.vmd.configPath" value="${vmdUsed}" />
  
  <!-- Teste mal, ob ein defaultwert durch loadproperties ueberschrieben werden kann -->
  <property name="projekt.useDefaultWhenMissing" value="false" />
  
	<!-- ######## Anwenden, der lokalen Konfiguration -->
	<echo>Verwendet Projektkonfiguration: ${projekt.vmd.configPath}</echo>
	
	<!-- Prüfe, ob die angegebenen Datei vorhanden ist -->	 
	 <fl:choose>
		<fl:when test=" '${projekt.vmd.configPath}'.tofile.exists == true ">
			<echo>Ggfs. in Projektdatei angebene/zu verwendende Projektkonfiguration existiert: ${projekt.vmd.configPath}</echo>
			
			<loadproperties>
				<file file="${projekt.vmd.configPath}"/>
			</loadproperties> 	 
			<echo>test1 hat den Wert: ${test1}</echo>
	
			<echo>project.vmd.dirRepositoryPath hat den Wert: ${project.vmd.dirRepositoryPath}</echo> 							
			<echo>project.vmd.dirPathClientFgl hat den Wert: ${project.vmd.dirPathClientFgl}</echo>	
			<echo>project.vmd.os hat den Wert: ${project.vmd.os}</echo>
			<echo>project.vmd.operation_mode hat den Wert: ${project.vmd.operation_mode}</echo>
						
			<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
					   dies passiert hier durch flaka´s install-property handler task -->
				<fl:install-property-handler />  	
				<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
				<property name="env.VMD_OPERATION_MODE" value="${project.vmd.operation_mode}"/><!-- Setze die Umgebungsvariable, was aber nur innerhalb des Ant-Scripts gilt UND das nur für nicht(!) bereits gesetzte (z.B. in einer Batch) Umgebungsvariablen klappt. -->
				<echo>Nach dem Setzen per Property-Handler: VMD_OPERATION_MODE='${env.VMD_OPERATION_MODE}'</echo>
							
			<!-- Noch Kaputt 20160415: 
				WIE SCHREIBT MAN EINE Umgebungsvariable AUS EINEM ANT - SCRIPT, SO DASS SIE IN EINER LAUFENDEN BATCH WEITERVERARBEITET WERDEN KANN -->	

			<!-- Gib den operation_mode als Umgebungsvariable zurück.
                 Dadurch steht diese information direkt der Batch zur Verfügung.
                 Ziel: Die Erzeugung von Protokolldateien steuern. -->
				 
			
				<!-- Die so erzeugte Umgebungsvariable ist aber nur im exec-Teil gültig. -->
				<exec executable="cmd" failonerror="true">
				<env key="VMD_OPERATION_MODE" value="${project.vmd.operation_mode}"/>
				<arg value="/C"/>
				<arg value="echo Wert '%VMD_OPERATION_MODE%' wurde gesetzt als Umgebungsvariable fuer VMD_OPERATION_MODE (gilt aber nur innerhalb des exec-Blocks)."/>
				</exec>				
				<!-- Merke: Damit provoziert man einen Fehler im Ant Script und setzt errorlevel im Batch anders -->
				<!-- <exec>
				<env key="VMD_OPERATION_MODE" value="${project.vmd.operation_mode}"/>				
				</exec> -->
			
				
				<!-- Angeblich kann man die Umgebungsvariable ändern, wenn es sie zuvor schon gibt, also: 
				     Hiermit den Konfigurierten ANT-MODUS auch in die Batch zurückübergeben.-->
				<!-- Ggfs. Fehler wg. fehlender Rechte in restriktiven Umgebungen (z.B. Firmen). Darum dann den Wert in der Batch selbst setzen. 
					 "FEHLER: Der Zugriff auf den Registrierungspfad wurde verweigert." -->
				<exec executable="setx.exe">
						<arg line="OPERATION_MODE_BATCH ${project.vmd.operation_mode}"/>
						<arg line="/m"/>
				</exec>
				<echo>Nach setx.exe: OPERATION_MODE_BATCH='${env.OPERATION_MODE_BATCH}'</echo>
			
			<!-- TODO GOON: Prüfe die Controldateien auf Existenz. -->
			<!-- TODO : Prüfe die Controldatei auf Validität. -->
		</fl:when>
		<otherwise>
			<echo>Ggfs. in Projektdatei angebene/zu verwendende Projektkonfiguration existiert NICHT: ${projekt.vmd.configPath}</echo>
			<fl:fail message="In Projektdatei angegebene Projektkonfiguration existiert NICHT: ${projekt.vmd.configPath}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
		</otherwise>
	</fl:choose>
	</target>
  
  <!-- ############################################################################## -->
  <target name="-init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${project.vmd.dirRepositoryArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${project.vmd.dirRepositoryMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>


<!-- ################################################################################# -->  
<target name="-FglRepository_Main">	
	<!-- Mache Backup des Repositories. -->
	
	<!-- Pruefe die Projekt-Properites -->
	<antcallback target="-FglCheckProjectPropertiesRepository" return="conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />
		
	<!-- Sind alle notwendigen Konfigurations-Properties vorhanden, weitermachen -->
	<!-- TODO GOON, noch kaputt: Hier wird 'Hinweis: <#!!FGLUNDEFINED!!#>' auf der Konsole ausgegeben, es muss also eine Target <arrayEchoZZZ> erstellt werden.
                                                    welches bei einem leeren Array (hier: dem leeren Fehlerarray) nix ausgibt und ansonsten die Fehler Zeile für Zeile ausgeben würde.	-->
	<fl:echo>myGoon hat den Wert: ${myGoon}</fl:echo>
	<ac:if>
		<ac:not>
			<ac:equals arg1="${myaError}" arg2="" />			
		</ac:not>
		<ac:then>
			<fl:echo>Hinweis: ${myaError}</fl:echo>
		</ac:then>
		<ac:else>
		</ac:else>
	</ac:if>
		<ac:if>
			<ac:equals arg1="${myGoon}" arg2="false" />
			<ac:then>
				<fl:echo>NICHT alle notwendigen Konfigurations-Properties vorhanden. Fahre NICHT fort.</fl:echo>
			</ac:then>
			<ac:else>
				<fl:echo>Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
			
				<!-- übernimm Projekt KonfigurationsPROPERTIES in hier verwendete KonfigurationsVARIABLEN -->
				<fl:let>conf.dirRepositoryArchive ::= "${project.vmd.dirRepositoryArchive}"</fl:let>
				<fl:let>conf.dirRepositoryMisc ::= "${project.vmd.dirRepositoryMisc}"</fl:let>
				
			<!-- ######### CLIENT ############################################################################## -->
			
			<!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
			<!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
			<!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
			 
			
				

		<!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
		<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
				dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<fl:let>src.dirFglClientPath::="${conf.dirPathClientFgl}" </fl:let>
	
	<!-- Die Ermittlung des Dateinamens, unbhaengig von Client oder Host.-->
	<!-- Merke: Normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
	<echo>VMD_OS=${env.VMD_OS}</echo>
	<fl:let>osUsed::='${env.VMD_OS}'</fl:let>		
	<fl:let>pathClientUsed::='${conf.dirPathClientFgl}'</fl:let>		
	<antcallback target="-computeFilenameVMD" return="returnFilename">
				<param name="osUsed" value="${osUsed}"/>
				<param name="pathClientUsed" value="${pathClientUsed}"/>					
	</antcallback>		
	<echo>Errechneter wert der VMD Datei=${returnFilename}</echo>
	<fl:let>src.dirFglClientFileName::="${returnFilename}"</fl:let><!-- Merke: Der Computername wird nicht extra gesetzte. Er kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	<fl:let>dest.dirRepositoryVmdPath::="${conf.dirRepositoryPath}"</fl:let>
	<fl:let>dest.dirRepositoryVmdBackupPath::="${dest.dirRepositoryVmdPath}Backups"</fl:let><!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
		  
	<!-- ########### Mache Backup des Repositories. ######################################################### -->
	<antcallback target="-FglRepositoryBackup" return="returnControl">
			<param name="targetDirectory" value="${dest.dirRepositoryVmdBackupPath}"/>
	</antcallback>								
	<ac:if><!-- returnControl prüfen: Backup des Repositories erfolgreich oder nicht -->
		<ac:equals arg1="${returnControl}" arg2="true" />
		<ac:then>
			<fl:echo>FglRepositoryBackup erfolgreich. Fahre fort.</fl:echo> 
				
			<antcallback target="-FglRepositoryCopyClient2archive" return="returnControl">
			<param name="sourceDirectory" value="${src.dirFglClientPath}"/>
			<param name="targetDirectory" value="${dest.dirRepositoryVmdPath}"/>
			<param name="fileNameVmd" value="${src.dirFglClientFileName}"/>
		</antcallback>
		</ac:then>		
		<ac:else>													
			<fl:echo>FglRepositoryBackup NICHT erfolgreich. Ueberspringe das Kopieren.</fl:echo> 
		</ac:else>
	</ac:if><!-- End if: Backup des Repositories erfolgreich oder nicht -->
	</ac:else>
	</ac:if>
</target>

<target name="-FglCheckProjectPropertiesRepository">
	
	<!-- Pruefe die Projekt-Properites fuer den Repository-Zweig -->
	
	<!-- Pruefe die allgemeinen Projekt-Properties -->
	<antcallback target="-FglCheckProjectProperties" return="conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<fl:let>myDirRepositoryPath ::= "${conf.dirRepositoryPath}" </fl:let>
	<fl:let>myDirPathClientFgl ::= "${conf.dirPathClientFgl}" </fl:let>
	<fl:let>myOs ::= "${conf.os}" </fl:let>
	<echo>myDirRepositoryPath hat den Wert: "${myDirRepositoryPath}"</echo>
	<echo>myDirPathClientFgl hat den Wert: "${myDirPathClientFgl}"</echo>
	<echo>myOs hat den Wert: "${myOs}"</echo>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />	

	<!-- Rueckgabebwerte -->
	<ac:var name="conf.dirRepositoryPath" value="${myDirRepositoryPath}" />
	<ac:var name="conf.dirPathClientFgl" value="${myDirPathClientFgl}" />
	<ac:var name="conf.os" value="${myOs}" />
	<ac:var name="returnControl" value="${myGoon}" />
	<arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
</target>

<target name="-FglCheckProjectProperties">

<!-- Prüfe die Existenz der notwendigen Konfigurations-Properties -->
	<!-- Merke: Oben (in Declaration) werden die project - Parameter ausgelesen und hier in conf - Parameter gepackt woraus wiederum die speziellen dest/src Parameter ggfs. geholt werden.-->
	<!-- Merke: Da solche Parameter dann für jedes Unter-Main-Target individuell sein kann, darf es nicht in eine Property gespeiert werden, sondern muss in eine Variable gepackt werden.-->	
	<fl:let>myGoon ::= true</fl:let>
	<arrayInitJsZZZ isize="0" arrayreturn="myaError"/>	
	<ac:if>
		<ac:and>
			<isset property="project.vmd.dirRepositoryPath"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.dirRepositoryPath}" arg2="\${project.vmd.dirRepositoryPath}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>			
			<fl:echo>project.vmd.dirRepositoryPath hat den Wert: '${project.vmd.dirRepositoryPath}'</fl:echo>			
			<fl:let>myDirRepositoryPath ::= "${project.vmd.dirRepositoryPath}" </fl:let> 			
		</ac:then>
		<ac:else><!-- TODO GOON: Default nur verwenden, wenn project.useDefault konfiguriert ist -->
			<fl:let>myDirRepositoryPath ::= "C:/1fgl/repository/Projekt_VMD"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.dirRepositoryPath' verwende als Standard '${myDirRepositoryPath}'." arrayreturn="myaError"  returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />			
			<!--<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />-->
			
			<ac:if>
				<equals arg1="false" arg2="${myReturnControl}"/>
				<ac:then>							
					<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
					<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
				</ac:then>		
			</ac:if>
		</ac:else>
	</ac:if>
	<ac:if>
		<ac:and>
			<isset property="project.vmd.dirPathClientFgl"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.dirPathClientFgl}" arg2="\${project.vmd.dirPathClientFgl}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>
			<fl:echo>project.vmd.dirPathClientFgl hat den Wert: '${project.vmd.dirPathClientFgl}'</fl:echo>			
			<fl:let>myDirPathClientFgl ::="${project.vmd.dirPathClientFgl}"</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myDirPathClientFgl ::= "c:/1fgl/client"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.dirPathClientFgl' verwende als Standard '${myDirPathClientFgl}'." arrayreturn="myaError" returncontrol="myReturnControl" returncontrolstring="myReturnControlString"  sflagcontrol="" />
			<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
			<ac:if>
				<equals arg1="false" arg2="${myReturnControl}"/>
				<ac:then>							
					<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
					<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
				</ac:then>		
			</ac:if>
		</ac:else>
	</ac:if>
	<ac:if>
		<ac:and>
			<isset property="project.vmd.os"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.os}" arg2="\${project.vmd.os}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>						
			<fl:echo>project.vmd.os hat den Wert: '${project.vmd.os}'</fl:echo>						
			<fl:let>myOs ::="${project.vmd.os}"</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myGoon ::= false</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.os'" arrayreturn="myaError" returncontrol="myReturnControl" returncontrolstring="myReturnControlString"  sflagcontrol="" />
			<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
			<ac:if>
				<equals arg1="false" arg2="${myReturnControl}"/>
				<ac:then>							
					<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
					<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
				</ac:then>		
			</ac:if>
		</ac:else>
	</ac:if>
	
	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="conf.dirRepositoryPath" value="${myDirRepositoryPath}" />
	<ac:var name="conf.dirPathClientFgl" value="${myDirPathClientFgl}" />
	<ac:var name="conf.os" value="${myOs}" />
	<ac:var name="returnControl" value="${myGoon}" />
	<arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->		
</target>
     

<target name="-FglRepositoryBackup">	
	<fl:let>myTargetDirectory ::= "${targetDirectory}"</fl:let>
	<echo>Creating Backup: ${myTargetDirectory}</echo>
	
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade, dabei gehe ich davon aus, dass alle Unterverzeichnisse automtisch erstellt werden. -->
	<mkdir dir="//${myTargetDirectory}"/>

	<echo>a) VmdRepository Archive:</echo>
	<echo>project.vmd.dirRepositoryArchive = "${project.vmd.dirRepositoryArchive}"</echo>
	<echo>conf.dirRepositoryArchive = "${conf.dirRepositoryArchive}"</echo>
	<echo>myTargetDirectory = "${myTargetDirectory}"</echo>
	
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${myTargetDirectory}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${conf.dirRepositoryArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${project.vmd.dirRepositoryArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind.
               Merke: Dabei gilt, das diese Dateien über alle Rechner identischen Inhalt haben sollen.-->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${myTargetDirectory}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${conf.dirRepositoryMisc}"
	/>
	<fl:let>myReturnControl ::= true</fl:let>
	<fl:let>returnControl ::= ${myReturnControl}</fl:let>
</target>
		
<target name="-FglRepositoryCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->	
	<echo>Pushing Files to Repository:</echo>
	<fl:let>mySourceDirectory ::= "${sourceDirectory}"</fl:let>
	<fl:let>myTargetDirectory ::= "${targetDirectory}"</fl:let>
	<fl:let>myFileNameVmd ::= "${fileNameVmd}"</fl:let>
		
	<echo>a) VMD File:</echo>
	<!-- <echo>conf.dirRepositoryArchive = "${conf.dirRepositoryArchive}"</echo>
	<echo>mySourceDirectory = "${mySourceDirectory}"</echo>
	<echo>myTargetDirectory = "${myTargetDirectory}"</echo>
	<echo>myFileNameVmd = "${myFileNameVmd}"</echo> -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${conf.dirRepositoryArchive}" overwrite="false"  preservelastmodified="true">
		<fileset dir="//${mySourceDirectory}">	  
	    <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<!-- <include name="${src.dirFglClientFileName}" /> -->	
		<include name="${myFileNameVmd}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${myTargetDirectory}/${conf.dirRepositoryMisc}" overwrite="false"  preservelastmodified="true"> 	
	  <fileset dir="//${mySourceDirectory}">
		<exclude name="${myFileNameVmd}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="-FglVmd_Main">
	<fl:let>sScript::='-FglVmd_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" /> <!-- unset="true" /> -->
	<ac:var name="myReturnControlString" value="alles o.k." /> <!-- unset="true" /> -->
		
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
	<echo>######################################</echo>
	<!-- Fuehre die in der Steuereungsdatei definierten Aktionen aus. -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	<!-- Z.B. Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	
	<!-- Pruefe die Projekt-Properites -->
	<antcallback target="-FglCheckProjectPropertiesVmd" return="conf.dirRepositoryVmdBat,conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,conf.operation_mode,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />
		
	<!-- Sind alle notwendigen Konfigurations-Properties vorhanden, weitermachen -->
	<fl:echo>myGoon hat den Wert: ${myGoon}</fl:echo>
	<ac:if>
		<ac:not>
			<ac:equals arg1="${myaError}" arg2="" />			
		</ac:not>
		<ac:then>
			<!-- TODO IDEE : mache ein Target <arrayEchoZZZ>, in dem die Elemente eines Arrays Zeile für Zeile ausgegeben werden -->
			<fl:echo>Hinweis: ${myaError}</fl:echo>
		</ac:then>
		<ac:else>
		</ac:else>
	</ac:if>
	<ac:if>
		<ac:equals arg1="${myGoon}" arg2="false" />
		<ac:then>
			<fl:echo>NICHT alle notwendigen Konfigurations-Properties vorhanden. Fahre NICHT fort.</fl:echo>
		</ac:then>
		<ac:else>
			<fl:echo>Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
			
			<!-- Konfiguriere sonstige Variablen -->						
			<!-- ... müssten normalerweise stehen in -FglCheckProjectPropertiesVmd ... -->
			<!-- wie z.B. <fl:let>conf.dirRepositoryVmdBat ::= "${project.vmd.dirRepositoryBat}" </fl:let> -->	
						
		
			<!-- Falls der Test - Modus angestellt ist, verwende die Test-Konfigurationsdatei und rechne den Dateinamen nicht aus.-->		
			<!-- <echo>conf.operation_mode='${conf.operation_mode}'</echo> -->
			<ac:if>
				<ac:equals arg1="${conf.operation_mode}" arg2="test" />
				<ac:then>
					<fl:echo>testmodus</fl:echo> 							 			
					<fl:let>conf.copyLocalFileName ::= "test_vmd.properties"</fl:let>
				</ac:then>		
				<ac:else>													
					<fl:echo>echtmodus</fl:echo>
								
					<!-- 1. Rechne den Dateinamen aus -->
					<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
					dies passiert hier durch flaka´s install-property handler task -->
					<fl:install-property-handler />
					<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->

					<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
					<fl:let>conf.copyLocalFileName ::= "Fgl${env.COMPUTERNAME}_copy_local.properties"</fl:let>
				</ac:else>
			</ac:if><!-- Testmodus oder nicht: Konfigurationsdateinamen ausrechnen -->

			<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
			<!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
			<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
			<echo>Copy files general, by property file:</echo>
			<echo>${conf.copyLocalFilePath}</echo>

			<!-- Arbeite die Steuerungsdatei ab -->					
			<antcallback target="-FglFileControlController_Main" return="returnControlString, returnControl">
				<param name="localFileControlPath" value="${conf.copyLocalFilePath}"/>												
			</antcallback>      
			<fl:echo>Ergebnis des FileControll Controllers: ${returnControlString}</fl:echo>		
										
		</ac:else>	<!-- Alle Projekt-Konfigurationsparameter sind vorhanden -->
	</ac:if>	<!-- Alle Projekt-Konfigurationsparameter sind vorhanden -->	
	
	
		</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>			
	
</target>

<target name="-FglCheckProjectPropertiesVmd">
	
	<!-- Pruefe die Projekt-Properties fuer den Repository-Zweig -->
	
	<!-- Pruefe die allgemeinen Projekt-Properties -->
	<antcallback target="-FglCheckProjectProperties" return="conf.dirRepositoryPath,conf.dirPathClientFgl,conf.os,returnControl,returnaString">
		<param name="useDefaultWhenMissing" value="${project.useDefaultWhenMissing}"/>
	</antcallback>
	<fl:let>myGoon ::= "${returnControl}" </fl:let>
	<fl:let>myDirRepositoryPath ::= "${conf.dirRepositoryPath}" </fl:let>
	<fl:let>myDirPathClientFgl ::= "${conf.dirPathClientFgl}" </fl:let>
	<fl:let>myOs ::= "${conf.os}" </fl:let>
	<echo>myDirRepositoryPath hat den Wert: "${myDirRepositoryPath}"</echo>
	<echo>myDirPathClientFgl hat den Wert: "${myDirPathClientFgl}"</echo>
	<echo>myOs hat den Wert: "${myOs}"</echo>
	<arrayCopyJsZZZ arrayinput="${returnaString}" arrayreturn="myaError" sflagcontrol="" />	

	<!--prüfe die speziellen Projekt-Properites -->		
	<ac:if>
		<ac:and>
			<isset property="project.vmd.operation_mode"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.operation_mode}" arg2="\${project.vmd.operation_mode}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>
			<fl:echo>project.vmd.operation_mode hat den Wert: '${project.vmd.operation_mode}'</fl:echo>	
			<fl:let>myOperation_mode ::= "${project.vmd.operation_mode}"</fl:let>			
		</ac:then>
		<ac:else>			
			<fl:let>myOperation_mode ::= "prod"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.operation_mode' verwende als Standard '${myOperation_mode}'." arrayreturn="myaError" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
			<ac:if>
				<equals arg1="false" arg2="${myReturnControl}"/>
				<ac:then>							
					<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
					<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
				</ac:then>		
			</ac:if>
		</ac:else>
	</ac:if>
	
	<ac:if>
		<ac:and>
			<isset property="project.vmd.dirRepositoryBat"/>	
			<!-- <ac:equals arg1="${myGoon}" arg2="true" /> -->
			<ac:not><!-- Abprüfen, ob der Variableninhalt gleich dem Variablennamen ist -->
				<ac:equals arg1="${project.vmd.dirRepositoryBat}" arg2="\${project.vmd.dirRepositoryBat}" /><!-- Merke: mit dem Backslash maskiert man das $ Zeichen-->
			</ac:not>
		</ac:and>
		<ac:then>
			<fl:echo>project.vmd.dirRepositoryBat hat den Wert: '${project.vmd.dirRepositoryBat}'</fl:echo>	
			<fl:let>myDirRepositoryBat ::= "${project.vmd.dirRepositoryBat}"</fl:let>			
		</ac:then>
		<ac:else>					
			<fl:let>myDirRepositoryBat ::= "bat"</fl:let>
			<arrayAppendJsZZZ arrayinput="${myaError}" valueinput="Nicht konfiguriert: 'project.vmd.dirRepositoryBat' verwende als Standard '${myDirRepositoryBat}'." arrayreturn="myaError" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
			<ac:if>
				<equals arg1="false" arg2="${myReturnControl}"/>
				<ac:then>							
					<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
					<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
				</ac:then>		
			</ac:if>
		</ac:else>
	</ac:if>
	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="conf.dirRepositoryVmdBat" value="${myDirRepositoryBat}" />
	<ac:var name="conf.dirRepositoryPath" value="${myDirRepositoryPath}" />
	<ac:var name="conf.dirPathClientFgl" value="${myDirPathClientFgl}" />
	<ac:var name="conf.os" value="${myOs}" />
	<ac:var name="conf.operation_mode" value="${myOperation_mode}" />
	<ac:var name="returnControl" value="${myGoon}" />
	<arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
</target>

<!-- ######################################################################### -->
<target name="-FglFileControlController_Main">
	<fl:let>sScript::='-FglFileControlController_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	<fl:let>myLocalFileControlPath ::= "${localFileControlPath}"</fl:let>

	
	<!-- Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<fl:when test=" '${myLocalFileControlPath}'.tofile.exists == true ">
					<echo>Datei existiert: ${myLocalFileControlPath}</echo>
						
					<!-- 1a. Lies den Inhalt der Datei als Properties-Datei ein. -->	
					<!--<loadproperties>
						<file file="${conf.copyGeneralFilePath}"/>
						</loadproperties> 
						<echo>test1 hat den Wert: ${test1}</echo> -->
		
		
					<!-- 2. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
					<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
					<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
		
					<!-- Test: Gib den Inhalt der Datei aus -->
					<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
					<!-- <echo>${myfile}</echo> -->


					<!-- ################################################################ -->
					<!-- Die "Schemata" Untersuchung machen. Dazu die Steuerungsdatei Zeile für Zeile auswerten, bis zum nächsten Eintrag, der ein anderes Schema ist.
						Für das Analysierte Schema den passenden Schema-Controller aufrufen. Orientiere dich bei den Schema-Namen an den DOS Befehlen.						
						Weitere Schema Befehle sind vmd://, copy://, del://. zip://-->
										
					<!-- 1b. Werte den Inhalt der Datei zeilenweise aus -->
					<!-- Beispiel für eine Schleife in ant, und wie man mit sequentials und dem @ Parameter darin arbeiten kann.  -->			
					<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
					<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
						<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
							<file file="${myLocalFileControlPath}" />
						</tokens>
						<sequential>
							<fl:let>myCase ::= "neue Zeile"</fl:let><!-- für jede Zeile wird der mögliche Verarbeitungsfall neu ermittelt -->
							
							<var name="myLine" value="@{line}" />
							<!-- <fl:echo>Zeile:'${myLine}'</fl:echo> -->					
							
							<var name="line.length" unset="true" />
							<length string="@{line}" property="line.length" /><!-- ueber das length-Tag wird eine property gefüllt, die lediglich so aussieht als wäre sie eine Methode des line-Objekts -->							
							<!-- <fl:echo>Zeile Länge: ${line.length}</fl:echo> -->
							
							<ac:if>
								<ac:equals arg1="${line.length}" arg2="0" />
							    <ac:then>
									<fl:let>myLineTrimmed::=''</fl:let>
								</ac:then>
								<ac:else>
									<fl:let>myLineTrimmed::=trim("@{line}")</fl:let>
								</ac:else>
							</ac:if>													
							<!-- <fl:echo>Zeile trimmed:'${myLineTrimmed}'</fl:echo> 
							<var name="myLineTrimmed.length" unset="true" />
							<length string="${myLineTrimmed}" property="myLineTrimmed.length" />
							<fl:echo>Zeile trimmed Länge ${myLineTrimmed.length}</fl:echo> -->
							
							<ac:if>								
								<ac:equals arg1="${myLineTrimmed}" arg2="" />								
								<ac:then>
									<fl:echo>Leerzeile, wird übersprungen...</fl:echo>
								</ac:then>
								<ac:else>												
									<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->																
									<stringSubStringJsZZZ inputstring="${myLineTrimmed}" inputindexstart="0" inputindexend="1" returnstring="subtext" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
									<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
									<!-- <fl:echo message="subtext = ${subtext}" /> -->
									<ac:if>
										<ac:equals arg1="${subtext}" arg2="#" />
										<ac:then>
											<!-- <fl:echo>Kommentarzeile, wird uebersprungen...</fl:echo> -->
										</ac:then>
										<ac:else>
											<fl:echo>zu verarbeitende Zeile:'${myLineTrimmed}'</fl:echo>																																																							
											<!-- <fl:echo>1. myStringCurrent.Schema:'${myStringCurrent.Schema}'</fl:echo> -->
											<ac:var name="myReturnControlCaller" value="true" unset="true" />
											<ac:var name="myReturnControlStringCaller" value="alles o.k." unset="true" />
											<antcallback target="-FglSchemaController_Analyzer" return="myReturnControlCaller,myReturnControlStringCaller,returnControlString.Schema,returnControl.SchemaChanged,linea.UnSchema">
												<param name="lineCurrent" value="${myLineTrimmed}" />
												<param name="stringCurrent.Schema" value="${myStringCurrent.Schema}"/>
												<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
											</antcallback>
											<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControlCaller}" returncontrolstring="${myReturnControlStringCaller}"/>
																																
											<!-- Nach dem Untercontrolleraufruf, oder ohne Untercontrolleraufruf: Fülle linea.Schema als Kopie von lineaCurrent.Schema -->
												<!--<fl:echo>2a. returnString.Schema:'${returnString.Schema}'</fl:echo>												
												<fl:echo>2b. myStringCurrent.Schema:'${myStringCurrent.Schema}'</fl:echo>
												<fl:echo>2c. linea.Schema</fl:echo>
												<arrayDebugJsZZZ arrayinput="${linea.Schema}" ilevel="1"/>
												<fl:echo>2d. myLineaCurrent.Schema</fl:echo>
												<arrayDebugJsZZZ arrayinput="${myLineaCurrent.Schema}" ilevel="1"/>												
												<fl:echo>2e. returnControl.Schema: '${returnControl.Schema}</fl:echo> -->
											
											<!-- Falls der Controller meint returnControl.Schema==true, dann hat das Schema gewechselt und damit müssen diese Anweisungen ausgeführt werden. -->																						
												<isBooleanJsZZZ inputvalue="${returnControl.SchemaChanged}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
												<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
												<ac:if>
												  <equals arg1="${myBooleanValue}" arg2="true" />
												  <ac:then>		
													<echo>Schemawechsel hat stattgefunden. Altes Schema ist: '${myStringCurrent.Schema}'</echo>
													
													<!-- Aufruf des SchemaControllers, der auf die Untercrontroller verteilt -->
													<fl:echo>AUFRUF DES SCHEMA-CONTROLLERS BEI SCHEMA-WECHSEL</fl:echo>
													<antcallback target="-FglSchemaController_Controller" return="returnControlString, returnControl">
														<param name="stringCurrent.Schema" value="${myStringCurrent.Schema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
														<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
													</antcallback>																										
												  </ac:then>
												  <ac:else>
													<echo>Noch hat kein Schemawechsel stattgefunden.</echo>													
												  </ac:else>
												</ac:if>
																								
												<fl:let>myStringCurrent.Schema::='${returnString.Schema}'</fl:let><!-- uebernimm das zurueckgebene Schema als neues Schema -->												
												<!-- <echo>myStringCurrent.Schema = '${myStringCurrent.Schema}'</echo> -->													 
												<arrayCopyJsZZZ arrayinput="${linea.UnSchema}" arrayreturn="myLineaCurrent.UnSchema" sflagcontrol="" /><!-- uebernimm das Zeilenarray, ggfs. als neues Schema -->												
										</ac:else>	
									</ac:if><!-- end if <ac:equals arg1="${subtext}" arg2="#" /> -->
								</ac:else>
							</ac:if><!-- end if <ac:equals arg1="${line.length}" arg2="0" /> -->
						</sequential>
					</for><!-- end for param="line"> -->	

					<!-- Wenn keine Zeilen mehr zu verarbeiten sind, das letzte Array, des letzen Schemas noch abarbeiten, durch den passenden Funktionsaufruf -->								
					<fl:echo>AUFRUF DES ABSCHLIESSENDEN SCHEMA-CONTROLLERS</fl:echo>
					<!--<fl:echo>2f. Verabeite das letze Array, fuer das Schema: '${myStringCurrent.Schema}</fl:echo>-->
					<!--<arrayDebugJsZZZ arrayinput="${myLineaCurrent.UnSchema}" ilevel="1"/>-->
					<antcallback target="-FglSchemaController_Controller" return="returnControlString, returnControl">
						<param name="stringCurrent.Schema" value="${myStringCurrent.Schema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
						<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
					</antcallback>										
					
					<!-- TODO: Die Meldungen aus den aufgerufenen Unterfunktionen zurueckgeben und nicht blos hier alles auf supergut setzen. -->
					<echo>${sScript}Ergebnis des AUFRUF DES ABSCHLIESSENDEN SCHEMA-CONTROLLERS zurueckgeben: ${returnControlString}</echo>
					<ac:var name="myReturnControl" value="${returnControl}" />
					<ac:var name="myReturnControlString" value="${sScript}${returnControlString}"/>																					
				</fl:when><!-- Existiert die Konfigurationsdatei für das lokale Ausführen -->
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
					<ac:var name="myReturnControl" value="false" />
					<ac:var name="myReturnControlString" value="${sScript}Konfigurations-Datei existiert NICHT: ${myLocalFileControlPath}"/>	
				</otherwise>
			</fl:choose>
			
			
			
			</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="'${baz}'"/>			
			<!--<echo>Im ErrorHandling ${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>			
			
			<!-- Rueckgabebwerte -->
			<ac:var name="returnControl" value="${myReturnControl}" />
			<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
			
			<!-- <arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="srcaTotal.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
			<!-- <arrayCopyJsZZZ arrayinput="${mySrcaTotal.filename}" arrayreturn="srcaTotal.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
			<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filedir}" arrayreturn="destaTotal.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
			<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>

<target name="-FglSchemaController_Analyzer">
	<fl:let>sScript::='-FglSchemaController_Analyzer: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" unset="true" />
	<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
			
	<fl:let>myLineNextSchema::="${lineCurrent}"</fl:let>
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />	
	<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.Schema}" ilevel="1"/> -->
	
	<!-- Prüfe, ob eine Zeile ueberhaupt korrekt uebergeben wurde -->
	<ac:if>
		<ac:equals arg1="${myLineNext}" arg2="0" />
		    <ac:then>
				<fl:fail message="Argument Error: Empty line"/>
			</ac:then>
			<ac:else>
				<stringSubStringJsZZZ inputstring="${myLineNext}" inputindexstart="0" inputindexend="1" returnstring="subtext" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
				<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
				<ac:if>
					<ac:equals arg1="${subtext}" arg2="#" />
					<ac:then>
						<fl:fail message="Argument Error: Comment line"/>
					</ac:then>
					<ac:else>
						<!-- Also nur in diesem Fall weitermachen -->
					</ac:else>
				</ac:if>
			</ac:else>
	</ac:if>
	
	<!-- Uebernimm den vorherigen Schema-Teil -->
	<fl:let>myStringCurrent.Schema::=trim('${stringCurrent.Schema}')</fl:let>
	<!--<echo>myStringCurrent.Schema=${myStringCurrent.Schema}</echo>-->
	
	<!-- Ermittle den neuen Schema-Teil, falls leer dann mache copy als Default-Schema -->
	<!-- Ermittle die Zeile ohne Schema-Anfang.-->
	<!--<echo>myLineNextSchema="${myLineNextSchema}"</echo>-->
	<stringLeftStringJsZZZ inputstring="${myLineNextSchema}" inputmatchstring="://" returnstring="schemanext"  returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
	<fl:let>mySchemaNext::="${schemanext}"</fl:let>
	<!--<echo>mySchemaNext="${mySchemaNext}"</echo>-->
	<fl:let>mySchemaNextTrimmed::=trim('${mySchemaNext}')</fl:let>
	<!--<echo>mySchemaNextTrimmed="${mySchemaNextTrimmed}"</echo>-->
	<ac:if>
		<ac:equals arg1="${mySchemaNextTrimmed}" arg2="" />
		    <ac:then>
				<fl:let>mySchemaNextTrimmed::="copy"</fl:let>
				<fl:let>myLineNext::="${myLineNextSchema}"</fl:let>
			</ac:then>
			<ac:else>
				<!-- Ermittle die Zeile ohne Schemateil -->				
				<stringRightStringJsZZZ inputstring="${myLineNextSchema}" inputmatchstring="${mySchemaNext}://" returnstring="myLineNext" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
				<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
				<!--<echo>myLineNext="${myLineNext}"</echo>-->
			</ac:else>
	</ac:if>
	<fl:let>myReturnString.Schema::='${mySchemaNextTrimmed}'</fl:let>
	<echo>myReturnString.Schema="${myReturnString.Schema}"</echo>
	
	

	<!-- Prüfe, ob sich das Schema geändert hat -->	
	<isSetJsZZZ inputvalue="${myStringCurrent.Schema}" returnvalue="myIsSetValue" returnboolean="myValueIsSet" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<!-- Das Ergebnis von isSetJsZZZ prüfen -->
	<isBooleanJsZZZ inputvalue="${myValueIsSet}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<!--<ac:if>
	  <equals arg1="${myBooleanValue}" arg2="true" />
      <ac:then>		
		<echo>Property war gesetzt.</echo>
	  </ac:then>
	  <ac:else>
		<echo>Property war NICHT gesetzt.</echo>
	  </ac:else>
    </ac:if>-->
	 
	<fl:choose>
		<fl:when test="${myBooleanValue}==false">
			<echo>Noch nicht gesetztes altes Schema</echo>
			
			<!-- Erzeuge das Array zum ersten mal -->
			<arrayInitJsZZZ isize="0" arrayreturn="mylineaNext.UnSchema"/>
			
			<!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.Schema}" ilevel="1"/> -->
																				
		</fl:when><!-- test="'${myBooleanValue}'==false -->
	</fl:choose>
	 
	<fl:choose>		
		<fl:when test="'${mySchemaNextTrimmed}'=='${myStringCurrent.Schema}' or ${myBooleanValue}==false"><!-- TODO GOON 20151112: Hier pruefen, ob die Variable initialisiert ist -->
			<echo>Keine Schemaaenderung</echo>
			<fl:let>myReturnControl.SchemaChanged::=false</fl:let>
										
			<!-- Hänge an bestehendes Array an -->
			<ac:var name="myReturnControlCaller" value="true" unset="true" />
			<ac:var name="myReturnControlStringCaller" value="alles o.k." unset="true" />
			<arrayAppendJsZZZ arrayinput="${mylineaNext.UnSchema}" valueinput="${myLineNext}" arrayreturn="myArrayNew" returncontrol="myReturnControlCaller" returncontrolstring="myReturnControlStringCaller" sflagcontrol="" />
			<echo message="${sScript}yyyyyyyymyReturnControlCaller | myReturnControlStringCaller = ${myReturnControlCaller} | ${myReturnControlStringCaller}" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControlCaller}" returncontrolstring="${myReturnControlStringCaller}"/>			
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />
	
			<!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.UnSchema}" ilevel="1"/> -->
																				
		</fl:when><!-- '${mySchemaCurrent}'=='${myStringCurrent.Schema}' -->
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->		
			<echo>Schemaaenderung vorhanden!</echo>
			<fl:let>myReturnControl.SchemaChanged::=true</fl:let>
			
			<!-- Mache neues Array. Hänge an neues Array an -->			
			<arrayInitJsZZZ isize="0" arrayreturn="mylineaNext.UnSchema"/>
			<ac:var name="myReturnControlCaller" value="true" unset="true" />
			<ac:var name="myReturnControlStringCaller" value="alles o.k." unset="true" />
			<arrayAppendJsZZZ arrayinput="${mylineaNext.UnSchema}" valueinput="${myLineNext}" arrayreturn="myArrayNew" returncontrol="myReturnControl" returncontrolstring="myReturnControlString"  sflagcontrol="" />
			<echo message="${sScript}xxxxxxxxxmyReturnControlCaller | myReturnControlStringCaller = ${myReturnControlCaller} | ${myReturnControlStringCaller}" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControlCaller}" returncontrolstring="${myReturnControlStringCaller}"/>
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />
	
			<!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mylineaNext.Schema}" ilevel="1"/> -->
					
		</otherwise>
	</fl:choose>	
	<fl:let>myReturnControl::=true</fl:let>
	<fl:let>myReturnControlString::="${sScript}Alles ok"</fl:let>
	
	</ac:try>
		<ac:catch>
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->
			<!-- 20160222 noch kaputt: PROBLEM myError wird nicht zurückgegeben. --> 
			<property name="baz" refid="myErrorObject" />
			<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>
					
			<ac:var name="myReturnControl" value="false" />
			<ac:var name="myReturnControlString" value="${baz}"/>						
		</ac:catch>

		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>			
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<echo>${sScript}Am Ende returnControlString=${sScript}${myReturnControlString}</echo>
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	
	<!-- Rueckgabebwerte -->
	<!--<ac:var name="returnString" value="${myReturnString}" />-->
	<ac:var name="returnControl.SchemaChanged" value="${myReturnControl.SchemaChanged}" />
	<ac:var name="returnString.Schema" value="${myReturnString.Schema}" />		
	<arrayCopyJsZZZ arrayinput="${mylineaNext.UnSchema}" arrayreturn="linea.UnSchema" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>

<target name="-FglSchemaController_Controller">
	<fl:let>sScript::='-FglSchemaController_Controller: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" /> <!-- unset="true" /> -->
	<ac:var name="myReturnControlString" value="alles o.k." /> <!-- unset="true" /> -->
	<!-- Merke: Orientier dich bei der Vergabe der Schema Namen an den DOS - Befehlen -->
	<!-- Bisher umgesetzt: vmd, copy -->
	<!-- TODO umzusetzen: del, zip -->

	<fl:let>myStringCurrentSchema::="${stringCurrent.Schema}"</fl:let>
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="myLineaCurrent.UnSchema" sflagcontrol="" />	
	<!--<arrayDebugJsZZZ arrayinput="${myLineaCurrent.UnSchema}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	
	
	<!-- #### Rufe nun die Funktion auf, die das vorherige Schema verarbeiten soll. #### -->
	<!-- ###################################################### -->
	<ac:if>								
		<ac:equals arg1="${myStringCurrent.Schema}" arg2="vmd" />								
		<ac:then>
			<fl:echo>${sScript}AUFRUF DES VMD-CONTROLLERS FUER DEN VMD-FALL</fl:echo>
			<antcallback target="-FglVmdController_Main" return="returnString, returnControl,srcaTotal.filedir,srcaTotal.filename,destaTotal.filedir,destaTotal.filename">
				<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
			</antcallback>
			
			<fl:echo>${sScript}Ergebnis des VMD Controllers fuer den VMD-Fall: ${returnString}</fl:echo>
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->

			<ac:if>
				<ac:equals arg1="${returnControl}" arg2="false" />
				<ac:then>
					<fl:echo>${sScript}VMD Controller beendet mit false. Keine weitere Verarbeitung.</fl:echo>
				</ac:then>
				<ac:else>
					<fl:echo>${sScript}Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
					
					<!-- Beim VMD-Kopiern ein Flag mitgeben, das erst bewirkt, dass der HOSTNAME als Suffix hinter den Dateinamen kommt -->					
					<antcallback target="-FGLCopyLocal_Main" return="returnControlString, returnControl">
						<param name="controlString" value="append_hostname"/>	
						<!-- Scheinbar kann man als Parameter auch arrays direkt uebergeben, nur Arrays zurückgeben ist dann halt etwas schwieriger -->
						<param name="mySrcaTotal.filedir" value="${srcaTotal.filedir}"/>	
						<param name="mySrcaTotal.filename" value="${srcaTotal.filename}"/>	
						<param name="myDestaTotal.filedir" value="${destaTotal.filedir}"/>	
						<param name="myDestaTotal.filename" value="${destaTotal.filename}"/>	
					</antcallback>      
					<fl:echo>${sScript}Ergebnis des Kopierens: ${returnControlString}</fl:echo>			
				</ac:else> <!-- Controller erfolgreich -->
			</ac:if><!-- Ergebnis des VMD Controllers -->																
		</ac:then>
	 </ac:if>	
	<!-- ###################################################### -->
		<ac:if>								
		<ac:equals arg1="${myStringCurrent.Schema}" arg2="copy" />								
		<ac:then>
			<fl:echo>${sScript}AUFRUF DES VMD-CONTROLLERS FUER DEN COPY-FALL</fl:echo>
			<antcallback target="-FglVmdController_Main" return="returnString, returnControl,srcaTotal.filedir,srcaTotal.filename,destaTotal.filedir,destaTotal.filename">
				<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
			</antcallback>
			
			<fl:echo>${sScript}Ergebnis des VMD Controllers fuer den COPY-FALL: ${returnString}</fl:echo>
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${srcaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays	-->
			<!-- <arrayDebugJsZZZ arrayinput="${destaTotal.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->

			<ac:if>
				<ac:equals arg1="${returnControl}" arg2="false" />
				<ac:then>
					<fl:echo>${sScript}VMD Controller beendet mit false. Keine weitere Verarbeitung.</fl:echo>
				</ac:then>
				<ac:else>
					<fl:echo>${sScript}Alle notwendigen Konfigurations-Properties vorhanden. Fahre fort.</fl:echo>
					
					<!-- Beim COPY-Kopiern kein Flag mitgeben, das bewirkt, dass der Dateiname verändert wird -->					
					<antcallback target="-FGLCopyLocal_Main" return="returnControlString, returnControl">
						<param name="controlString" value=""/>	
						<!-- Scheinbar kann man als Parameter auch arrays direkt uebergeben, nur Arrays zurückgeben ist dann halt etwas schwieriger -->
						<param name="mySrcaTotal.filedir" value="${srcaTotal.filedir}"/>	
						<param name="mySrcaTotal.filename" value="${srcaTotal.filename}"/>	
						<param name="myDestaTotal.filedir" value="${destaTotal.filedir}"/>	
						<param name="myDestaTotal.filename" value="${destaTotal.filename}"/>	
					</antcallback>      
					<fl:echo>${sScript}Ergebnis des Kopierens: ${returnControlString}</fl:echo>	
				</ac:else> <!-- Controller erfolgreich -->
			</ac:if><!-- Ergebnis des VMD Controllers -->																
		</ac:then>
	 </ac:if>	
	 <!-- ###################################################### -->
		<ac:if>								
		<ac:equals arg1="${myStringCurrent.Schema}" arg2="del" />								
		<ac:then>
			<fl:echo>${sScript}AUFRUF DES CONTROLLERS FUER DEN DEL-FALL</fl:echo>			
			<antcallback target="-FglDelController_Main" return="returnControlString, returnControl,return.saTotal.filedir,return.saTotal.filename">
				<param name="lineaCurrent.UnSchema" value="${myLineaCurrent.UnSchema}"/><!-- Das sind die Zeilen ohne den voranstehenden Schema Teil -->												
			</antcallback>
			
			<fl:echo>${sScript}Ergebnis des Controllers fuer den DEL-FALL: ${returnControlString}</fl:echo>
			<arrayDebugJsZZZ arrayinput="${return.saTotal.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays	-->
			<arrayDebugJsZZZ arrayinput="${return.saTotal.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays	-->
			<arrayCopyJsZZZ arrayinput="${return.saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${return.saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />
			<ac:if>
				<ac:equals arg1="${returnControl}" arg2="false" />
				<ac:then>
					<fl:echo>${sScript}DEL Controller beendet mit false. Keine weitere Verarbeitung.</fl:echo>
				</ac:then>
				<ac:else>
					<fl:echo>${sScript}DEL Controller beendet mit true. Fahre fort.</fl:echo>
					
					<!-- Starte das Loeschen der durch die Arrays beschriebenen Dateien -->					
					<antcallback target="-FGLDelLocal_Main" return="returnControlString, returnControl">
						<param name="controlString" value=""/>	
						<!-- Scheinbar kann man als Parameter auch arrays direkt uebergeben, nur Arrays zurückgeben ist dann halt etwas schwieriger -->
						<param name="saTotal.filedir" value="${mysaTotal.filedir}"/>	
						<param name="saTotal.filename" value="${mysaTotal.filename}"/>							
					</antcallback>      
					<fl:echo>${sScript}Ergebnis des Loeschens: ${returnControlString}</fl:echo>						
				</ac:else> <!-- Controller erfolgreich -->
			</ac:if><!-- Ergebnis des VMD Controllers -->																
		</ac:then>
	 </ac:if>	
	<!-- ###################################################### -->	
	<!--<fl:let>myReturnControl::=${returnControl}</fl:let>-->
	<!--<fl:let>myReturnControlString::=${returnControlString}</fl:let>-->
	<ac:var name="myReturnControl" value="${returnControl}"/>
	<ac:var name="myReturnControlString" value="${returnControlString}"/>
		
		
		</ac:try>
	<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
		
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<!--<arrayCopyJsZZZ arrayinput="${mylineaNext.Schema}" arrayreturn="linea.Schema" sflagcontrol="" />--><!-- So gibt man einen Arraywertzurueck -->
</target>

<!-- ######################################################################### -->
<!-- ######################################################################### -->
<target name="-FglDelController_Main">  
	<fl:let>sScript::='-FglDelController_Main: '</fl:let>	
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="myLineaNext.UnSchema" sflagcontrol="" />	
	<!--<arrayDebugJsZZZ arrayinput="${myLineaNext.UnSchema}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->

	<!-- Arrays für alle Dateien, die es dann später zu loeschen gilt -->
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filedir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filename"/>
	
	<arrayElementCountJsZZZ arrayinput="${myLineaNext.UnSchema}" ireturn="myArraySize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<fl:choose>
	<fl:when  test="${myArraySize}>=1"><!-- Sind Einträge im Array vorhanden. -->

		<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${myArraySize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>
		
		<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
		<ac:if>
			<equals arg1="0" arg2="${iubound}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
			<ac:then><!-- iubound = 0 Fall -->			
				<echo>##################${sScript}NUR 1 EINTRAG in diesem Schemalauf</echo> 
				<arrayGetJsZZZ arrayinput="${myLineaNext.UnSchema}" index="0" arrayget="myLineTrimmed" sflagcontrol=""/>
				<fl:echo>${sScript}zu verarbeitende Zeile (ohne Schema):'${myLineTrimmed}'</fl:echo>
			
				<!-- Hier in einem antcallback alles aufrufen, was in der Schleife auch passiert -->
				<antcallback target="-FglDelController_LineController" return="returnString, returnControl,return.saTotal.filedir,return.saTotal.filename">
					<param name="lineCurrent" value="${myLineTrimmed}"/>
					<param name="saTotal.filedir" value="${mysaTotal.filedir}" />
					<param name="saTotal.filename" value="${mysaTotal.filename}" />					
				</antcallback>
				<!--<arrayDebugJsZZZ arrayinput="${return.saTotal.filedir}" ilevel="1"/>-->
				<!--<arrayDebugJsZZZ arrayinput="${return.saTotal.filename}" ilevel="1"/>-->
				<arrayCopyJsZZZ arrayinput="${return.saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->			
			</ac:then><!-- iubound = 0 Fall -->
			<ac:else><!-- iubound > 0 Fall -->	
			
				<!-- Ermittle die Anzahl, der Dateien -->	
				<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
				<!-- Den ubound des Arrays um +1 erhöhen, um die Anzahl zu bekommen. -->
				<var name="op1" value="${iubound}"/>
				<var name="op2" value="1"/>
				<var name="op" value="+"/>
				<math result="iAnzahl" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>						
				<echo>######################${sScript} ${iAnzahl} EINTRAEGE in diesem Schemalauf</echo> 
				<ac:for param="icounter" end="${iubound}">			
				<sequential>
					<echo>##################${sScript}icounter ist @{icounter}</echo> 
					<arrayGetJsZZZ arrayinput="${myLineaNext.UnSchema}" index="@{icounter}" arrayget="myLineTrimmed"/>
					<fl:echo>${sScript}zu verarbeitende Zeile (ohne Schema) @{icounter} :'${myLineTrimmed}'</fl:echo>
				
					<!-- Hier die hier in ein antcallback auslagern und für jede Zeile aufrufen. -->
					<antcallback target="-FglDelController_LineController" return="returnString, returnControl,return.saTotal.filedir,return.saTotal.filename">
						<param name="lineCurrent" value="${myLineTrimmed}"/>
						<param name="saTotal.filedir" value="${mysaTotal.filedir}" />
						<param name="saTotal.filename" value="${mysaTotal.filename}" />						
					</antcallback>
					
					<arrayCopyJsZZZ arrayinput="${return.saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->					
					<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>-->
					<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>-->
					</sequential>
				</ac:for>
			</ac:else><!-- iubound > 0 Fall -->
		</ac:if><!-- ubound = 0 tatsaechlich notwendige Abfrage -->
			
		<!-- TODO: Hier tatsaechlich den Rueckgabewert vom Kopiererfolg abhaengig machen -->
		<fl:let>myReturnControl ::= true</fl:let>
		<fl:let>myReturnString ::= "${sScript}Alles ok"</fl:let>
	</fl:when><!-- Existiert die Konfigurationsdatei für das lokale Ausführen -->
	<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
		<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		<fl:let>myReturnControl ::= false</fl:let>
		<fl:let>myReturnString ::= "${sScript}Array für del - Schema Zeilen ist leer"</fl:let>
	</otherwise>
	</fl:choose>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filedir}" arrayreturn="return.srcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filename}" arrayreturn="return.srcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>
<target name="-FglDelController_LineController"> 
	<fl:let>sScript::='-FglDelController_LineController: '</fl:let>
	<!--       Singletyp: Man kann eine Datei, inklusive Pfad angeben del://verzeichnisX\y.txt
	     TODO: Singletyp, mehrere Dateipfade mit Semikolon getrennt del://verzeichnisX\y.txt;verzeichnis\z.txt;verzeichnisB\x.txt
		 
		 
		 TODO: Matrixtyp: Verzeichnis mit mehreren Dateien, oder ohne Dateien, d.h. alle
		       del://verzeichnisX=y.txt;z.txt;x.txt-->	 
	<!-- Durch dieses Target kann ein antcallback in einer Schleife eingebaut werden, der dann sowohl für den ubound=0 als auch für den ubound > 0 Fall aufgerufen werden kann. -->
	<fl:let>myLineUnschemed::="${lineCurrent}"</fl:let><!-- darin ist kein Schema mehr enthalten -->
	<!--<fl:echo>${sScript}EINGANGSARRAY: saTotal.filedir</fl:echo>-->
	<!--<arrayDebugJsZZZ arrayinput="${saTotal.filedir}" ilevel="1"/>-->
	<!--<fl:echo>${sScript}EINGANGSARRAY: saTotal.filename</fl:echo>-->
	<!--<arrayDebugJsZZZ arrayinput="${saTotal.filename}" ilevel="1"/>-->
	<arrayCopyJsZZZ arrayinput="${saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />	
				
	<!-- TODO: Idee: in der Initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->	
	<!-- IDEE für die Zukunft: Lösche durchaus in einer Zeile mehrere Dateien in einem Verzeichnis
	           del://verzeichnis=a.txt,b.txt,c.txt
               Das funktioniert auch mit mehreren Dateien in mehreren Verzeichnissen.
			   del://verzeichnis1,verzeichnis2=a.txt,b.txt			
			   Das funktioniert auch mit mehrerern Dateien
			   del://verzeichnisX\y.txt,verzeichnisZ\xyz.txt
			   -->
			   
			   
	<!-- TODO GOON, noch KAPUTT: Rufe antcallback FglDelLocal_FileByMatrix auf
	                             Darin wird aus einer Ziele je ein Array für die Verzeichnisse und ein Array für die Dateistrings erzeugt. 
								 Dabei wird es beliebig kompliziert, je nachdem wie die Konfigurationszeile gebaut ist
								 a) Gleichheitszeichen, kein Gleichheitszeichen.
								 b) Ein oder mehrer Verzeichnisse, ein oder mehrerer Dateien. Hierzu muss sogar erst noch geprüft werden, 
								    ob es sich um einen Datei- oder um einen Verzeichnispfad handelt. ...-->
									
									
			   
	
	<!-- Start ... -->
	<!-- Pruefe, ob in der Zeile ein Gleichheitszeichen ist. Dies steuert auf oberster Ebenen den zu behandelnden Fall -->				
	<!-- Schreibe das in eine Flaka Variable -->			
	<fl:let>myLeftPart::=split('${myLineUnschemed}','=')[0]</fl:let>
	<fl:let>myRightPart::=split('${myLineUnschemed}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
	<fl:echo>${sScript}Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
	<fl:echo>${sScript}Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
		
	<fl:when test="null('${myLeftPart}')">
		<echo>${sScript}Linker Teil der Steuerungsanweisung existiert nicht (Verzeichnis oder Dateinamen): ${myLineTrimmed}</echo>
		<fl:fail message="${sScript}Linker Teil der Steuerungsanweisung existiert nicht: ${myLineTrimmed}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	
	<!-- TODO: Pruefen, ob die Zeile mit einem Schema beginnt. Falls ja ==> Fehler werfen. -->
	
	<!-- TODO noch kaputt -->
	<!--### Aufruf des Controllers der verschiedenen Fälle ####################-->
	<isSetJsZZZ inputValue="${myRightPart}" returnvalue="myIsSetValue" returnboolean="myValueIsSet" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<isBooleanJsZZZ inputvalue="${myValueIsSet}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<ac:if>
	 <equals arg1="${myBooleanValue}" arg2="true" />     
      <ac:then>
		<echo>${sScript}myRightPart ist gesetzt = '${myRightPart}'</echo>

		<antcallback target="-FGLDelLocal_AnalyseMatrix" return="returnControl, returna.filedir, returna.filename">
			<param name="analyze" value="${myAnalyze}"/>
			<param name="leftPart" value="${myLeftPart}"/>
			<param name="rightPart" value="${myRightPart}"/>												
		</antcallback>		
	  </ac:then>
	  <ac:else>
		<echo>${sScript}Nur linker Teil der Steuerungsanweisung existiert (Dateinamen... ohne Schema): ${myLineTrimmed}</echo>						
		<antcallback target="-FglDelLocal_AnalyseSingle" return="returnControl, returnString, returna.filedir, returna.filename">
			<param name="singlePart" value="${myLeftPart}"/>													
		</antcallback>
	  </ac:else>
	 </ac:if>
	 <!--<echo>######${sScript}zurueckgegebene und entegegengenommene Arrays aus -FglDelLocal_AnalyseSingle:</echo>-->
	 <!--<arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/>-->
	 <!--<arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/>-->
	 
	 <fl:let>myReturnControl::="${returnControl}"</fl:let>		
	<fl:choose>
		<fl:when test="${myReturnControl}==true">
			<fl:let>myReturnString::='${sScript}Alles o.k.| ${returnString}'</fl:let>
		</fl:when>	
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<fl:let>myReturnString::='${sScript}Ein Fehler muss aufgetreten sein. | ${returnString}'</fl:let>
		</otherwise>
	</fl:choose>	
			 		
	 <fl:echo>${sScript}Ergebnis von -FGLDelLocal_AnalyseMatrix bzw. -FglDelLocal_AnalyseSingle=${myReturnControl}</fl:echo>
	 <fl:echo>${sScript}returna.filedir=${returna.filedir}</fl:echo>
	 <fl:echo>${sScript}returna.filename=${returna.filename}</fl:echo>
	 <arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="mysaFiledir" sflagcontrol="" />
	 <arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="mysaFilename" sflagcontrol="" />

	<!-- Hänge die zurückgelieferten Arrays an die schon existierenden an -->	
	<isArrayEmptyJsZZZ arrayinput="${mysaFilename}" returnboolean="myArrayIsEmpty" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
	<fl:echo>${sScript}myArrayIsEmpty=${myArrayIsEmpty}</fl:echo>
	<ac:if>
		<and>
			<equals arg1="${myReturnControl}" arg2="true"/>
			<not>				
				<equals arg1="${myArrayIsEmpty}" arg2="true"/>
			</not>
			<!-- Auch ohne Dateien, sollte das Verzeichnis geloescht werden.
			<not>
				<equals arg1="${mysaFilename}" arg2="true"/>
			</not>-->
	
		</and>

		<ac:then>		
			<fl:echo>${sScript}Ergebnis: ${returnControl}, haenge Array an.</fl:echo>
			<arrayAppendArrayJsZZZ arrayinput="${mysaTotal.filedir}" array2append="${mysaFiledir}" arrayReturn="myArrayTotal1" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>			
			<arrayCopyJsZZZ arrayinput="${myArrayTotal1}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />						
			<arrayAppendArrayJsZZZ arrayinput="${mysaTotal.filename}" array2append="${mysaFilename}" arrayReturn="myArrayTotal2"   returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal2}" arrayreturn="mysaTotal.filename" sflagcontrol="" />
			
			<!--<fl:echo>${sScript}Ergebnis mit angehaengtem Array:</fl:echo>-->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>-->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>-->
		</ac:then>
		<ac:else>
			<fl:echo>${sScript}Ergebnis: ${returnControl} => kein Arraywert anzuhaengen.</fl:echo>
		</ac:else>
	</ac:if>		
	<!-- ... Ende -->
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filedir}" arrayreturn="return.saTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywert zurueck -->
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filename}" arrayreturn="return.saTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywert zurueck -->		
</target>

<target name="-FglDelLocal_AnalyseSingle">
	<fl:let>sScript::='-FglDelLocal_AnalyseSingle: '</fl:let>	
	<!-- MERKE: Hier wird keine Array reingegeben, sondern nur ein Array rausgegeben. -->
	<fl:let>mySinglePart ::= "${singlePart}"</fl:let>
	
	<!-- Bereite die Rueckgabewerte vor -->
	<arrayInitJsZZZ isize="0" arrayreturn="mysaFiledir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mysaFilename"/>	
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filedir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mysaTotal.filename"/>
	
	<!-- TODO GOON noch kaputt: Teile die Werte der Dateien mit Kommata auf und arbeite die Dateien in einer Schleife ab. 
	                            Falls es Verzeichniswerte mit Komata gibt, ist das hier die falsche Funktion. Verwende ... Matrix ...-->
	
	<!-- ### Übernimm nur die Dateien, die existieren, alles andere macht beim Loeschen keinen Sinn -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test="'${mySinglePart}'.tofile.exists == true ">
			<echo>${sScript}Datei/Verzeichnis existiert: ${mySinglePart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${mySinglePart}" property="myisdirectoryPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<!--<echo>Teil: isdirectory=${myisdirectoryPart}</echo>-->														
			<fl:when test="${myisdirectoryPart} == true">
					<!-- A) Teil - Verzeichnis-Fall: -->
					<echo>${sScript}Teil: Ist Verzeichnis, damit sollten alle Dateien im Verzeichnis geloescht werden.</echo>
					<arrayAppendJsZZZ arrayinput="${mysaFiledir}" valueinput="${mySinglePart}" arrayreturn="mysaTotal.filedir" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
					<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
					<ac:if>
						<equals arg1="false" arg2="${myReturnControl}"/>
						<ac:then>							
							<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
							<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
						</ac:then>		
					</ac:if>					
					<arrayAppendJsZZZ arrayinput="${mysaFilename}" valueinput="**.**" arrayreturn="mysaTotal.filename" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />								
					<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
					<ac:if>
						<equals arg1="false" arg2="${myReturnControl}"/>
						<ac:then>							
							<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
							<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
						</ac:then>		
					</ac:if>
					<fl:let>myReturnControl::=true</fl:let>
					<fl:let>myReturnString::='${sScript}Alles o.k.'</fl:let>
			</fl:when>
			<fl:when test="${myisdirectoryPart} != true">			
					<!-- B) Linker Teil - Dateipfad-Fall:-->
					<echo>${sScript}Teil: Ist KEIN Verzeichnis</echo>
					
					<!-- Ermittle aus dem Pfad den Verzeichnis und den Dateiteil -->
					<getFilenameFromPathJsZZZ pathstring="${mySinglePart}" returnfilename="myFilename" returncontrol="mytempReturnControl" returnacontrolstring="myaReturnControl" sflagcontrol="" />
					<echo>${sScript}Der Dateiname ist: '${myFilename}'</echo>
					<arrayAppendJsZZZ arrayinput="${mysaFilename}" valueinput="${myFilename}" arrayreturn="mysaTotal.filename" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
					<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
					<ac:if>
						<equals arg1="false" arg2="${myReturnControl}"/>
						<ac:then>							
							<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
							<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
						</ac:then>		
					</ac:if>
					<fl:let>myDirectoryPath::=''</fl:let>
					<stringLeftBackStringJsZZZ inputstring="${mySinglePart}" inputmatchstring="${myFilename}" returnstring="myDirectoryPath" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
					<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
					<echo>${sScript}Der Pfad ist: '${myDirectoryPath}'</echo>					
					<arrayAppendJsZZZ arrayinput="${mysaFiledir}" valueinput="${myDirectoryPath}" arrayreturn="mysaTotal.filedir" returncontrol="myReturnControl" returncontrolstring="myReturnControlString"  sflagcontrol="" />								
					<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
					<ac:if>
						<equals arg1="false" arg2="${myReturnControl}"/>
						<ac:then>							
							<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
							<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
						</ac:then>		
					</ac:if>
			
					<fl:let>myReturnControl::=${mytempReturnControl}</fl:let>									
					<fl:choose>
						<fl:when test="${myReturnControl}==true">
							<fl:let>myReturnString::='${sScript}Alles o.k.'</fl:let>
						</fl:when>	
						<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
							<fl:let>myReturnString::='${sScript}Ein Fehler muss aufgetreten sein.'</fl:let>
						</otherwise>
					</fl:choose>										
			</fl:when>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>${sScript}Datei/Verzeichnis existiert NICHT (damit nicht relevant fuer Loeschung): ${mySinglePart}</echo>	
			
			<!-- Eingabearray gleich Ausgabearray, trotzdem wieder zurückgeben. -->
			<fl:let>myReturnControl::=true</fl:let>
			<fl:let>myReturnString::="${sScript}: Datei/Verzeichnis existiert NICHT. Trotzdem alles o.k."</fl:let>
		</otherwise>
	</fl:choose>
	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />	
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filedir}" arrayreturn="returna.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->				
	<arrayCopyJsZZZ arrayinput="${mysaTotal.filename}" arrayreturn="returna.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->				
</target>

<!-- ######################################################################### -->
<target name="-FglVmdController_Main"> 
	<fl:let>sScript::='-FglVmdController_Main: '</fl:let>
	<arrayCopyJsZZZ arrayinput="${lineaCurrent.UnSchema}" arrayreturn="mylineaNext.UnSchema" sflagcontrol="" />	

	<!-- Arrays für alle Dateien, die es dann später zu kopieren gilt -->
	<!-- Todo: diese dann auch im Schema "copy" verwenden -->
	<arrayInitJsZZZ isize="0" arrayreturn="mySrcaTotal.filename"/>
	<arrayInitJsZZZ isize="0" arrayreturn="mySrcaTotal.filedir"/>
	<arrayInitJsZZZ isize="0" arrayreturn="myDestaTotal.filename"/>
	<arrayInitJsZZZ isize="0" arrayreturn="myDestaTotal.filedir"/>
			
	<arrayElementCountJsZZZ arrayinput="${mylineaNext.UnSchema}" ireturn="myArraySize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<fl:choose>
	<fl:when  test="${myArraySize}>=1"><!-- Sind Einträge im Array vorhanden. -->

		<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${myArraySize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<echo>Errechneter ubound Wert des Arrays: ${iubound}</echo>
		
		<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
		<ac:if>
			<equals arg1="0" arg2="${iubound}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
			<ac:then><!-- iubound = 0 Fall -->			
				<echo>NUR 1 EINTRAG in diesem Schemalauf</echo> 
				<arrayGetJsZZZ arrayinput="${lineaCurrent.UnSchema}" index="0" arrayget="myLineTrimmed" sflagcontrol=""/>
				<fl:echo>zu verarbeitende Zeile:'${myLineTrimmed}'</fl:echo>
			
				<!-- Hier in einem antcallback alles aufrufen, was in der Schleife auch passiert -->
				<antcallback target="-FglVmdController_LineController" return="returnString, returnControl,return.srcaTotal.filedir,return.srcaTotal.filename,return.destaTotal.filedir,return.destaTotal.filename">
					<param name="lineCurrent" value="${myLineTrimmed}"/>
					<param name="srcaTotal.filedir" value="${mySrcaTotal.filedir}" />
					<param name="srcaTotal.filename" value="${mySrcaTotal.filename}" />
					<param name="destaTotal.filedir" value="${myDestaTotal.filedir}" />
					<param name="destaTotal.filename" value="${myDestaTotal.filename}" />
				</antcallback>
				<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filename}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.destaTotal.filedir}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
				<arrayCopyJsZZZ arrayinput="${return.destaTotal.filename}" arrayreturn="myDestaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->					
			</ac:then><!-- iubound = 0 Fall -->
			<ac:else><!-- iubound > 0 Fall -->	
				<echo>${iubound} EINTRAEGE in diesem Schemalauf</echo>
				<ac:for param="icounter" end="${iubound}">			
				<sequential>
					<echo>icounter is @{icounter}</echo> 
					<arrayGetJsZZZ arrayinput="${lineaCurrent.UnSchema}" index="@{icounter}" arrayget="myLineTrimmed" sflagcontrol=""/>
					<fl:echo>zu verarbeitende Zeile:'${myLineTrimmed}'</fl:echo>
				
					<!-- Hier die hier in ein antcallback auslagern und für jede Zeile aufrufen. -->
					<antcallback target="-FglVmdController_LineController" return="returnString, returnControl,return.srcaTotal.filedir,return.srcaTotal.filename,return.destaTotal.filedir,return.destaTotal.filename">
						<param name="lineCurrent" value="${myLineTrimmed}"/>
						<param name="srcaTotal.filedir" value="${mySrcaTotal.filedir}" />
						<param name="srcaTotal.filename" value="${mySrcaTotal.filename}" />
						<param name="destaTotal.filedir" value="${myDestaTotal.filedir}" />
						<param name="destaTotal.filename" value="${myDestaTotal.filename}" />
					</antcallback>
					<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.srcaTotal.filename}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.destaTotal.filedir}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
					<arrayCopyJsZZZ arrayinput="${return.destaTotal.filename}" arrayreturn="myDestaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->					
					</sequential>
				</ac:for>
			</ac:else><!-- iubound > 0 Fall -->
		</ac:if><!-- ubound = 0 tatsaechlich notwendige Abfrage -->
		<!-- TODO: Hier tatsaechlich den Rueckgabewert vom Kopiererfolg abhaengig machen -->
		<fl:let>myReturnControl ::= true</fl:let>
		<fl:let>myReturnString ::= "alles ok"</fl:let>
	</fl:when><!-- Existiert die Konfigurationsdatei für das lokale Ausführen -->
	<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
		<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		<fl:let>myReturnControl ::= false</fl:let>
		<fl:let>myReturnString ::= "Array für vmd - Schema Zeilen ist leer"</fl:let>
	</otherwise>
	</fl:choose>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="srcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filename}" arrayreturn="srcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filedir}" arrayreturn="destaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>
<target name="-FglVmdController_LineController"> 
	<!-- Durch dieses Target kann ein antcallback in einer Schleife eingebaut werden, der dann sowohl für den ubound=0 als auch für den ubound > 0 Fall aufgerufen werden kann. -->
	<fl:let>myLineTrimmed ::= "${lineCurrent}"</fl:let>
	<arrayCopyJsZZZ arrayinput="${srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${srcaTotal.filename}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${destaTotal.filedir}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${destaTotal.filename}" arrayreturn="myDestaTotal.filename" sflagcontrol="" />	
		
	<!-- Schreibe das in eine Flaka - Variable -->		
	<fl:let>myLeftPart::=split('${myLineTrimmed}','=')[0]</fl:let>
	<fl:let>myRightPart::=split('${myLineTrimmed}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
	<fl:echo>Steuerungszeile linker Teil vom '=' => ${myLeftPart}</fl:echo>
	<fl:echo>Steuerungszeile rechter Teil vom '=' => ${myRightPart}</fl:echo>
																	
	<!-- TODO: Idee: in der Initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
	<fl:when test="null('${myRightPart}')">
		<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): ${myLineTrimmed}</echo>
		<fl:fail message="Rechter Teil der Steuerungsanweisung existiert nicht: ${myLineTrimmed}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
										
		<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
		<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
		<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
		<fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
	</fl:when>
	<fl:when test="null('${myLeftPart}')">
		<echo>Linker Teil der Steuerungsanweisung existiert nicht (von...): ${myLineTrimmed}</echo>
		<fl:fail message="Linker Teil der Steuerungsanweisung existiert nicht: ${myLineTrimmed}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																						
		<!-- Merke: Das wäre beim Kopieren einer Datei von einem feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
		<!-- <fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
		<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
		<fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
	</fl:when>
					
	<!-- TODO noch kaputt: IDEE: Normiere hier den möglichen Dateipfad nach Windows Style -->
	<!-- Wie oben bei der Ermittlung der Projektdatei, die in der Batch definiert wurde.
			Das Problem hier ist, das eine Property gefüllt wird und sich diese Property nie im Wert ändert -->
			<!--<path id="pathTempLeft">
					<pathelement location="${myLeftPart}"/>
					</path>
					<pathconvert targetos="windows" property="part.path.temp.left" refid="pathTempLeft">
					</pathconvert>
					<echo>Normierter Pfad (Windows Style)= ${part.path.temp.left}</echo>
							
					<path id="pathTempRight">
					<pathelement location="${myRightPart}"/>
					</path>
					<pathconvert targetos="windows" property="part.path.temp.right" refid="pathTempRight">
					</pathconvert>
					<echo>Normierter Pfad (Windows Style)= ${part.path.temp.right}</echo> -->
						
						
	<!-- ### Ermittle hier den Fall. Schreibe den Wert in diese Variable und fülle damit ein Array -->
	<fl:let>myCase ::= "undefined"</fl:let>																										
	<antcallback target="-FGLCopyLocal_Analyze" return="returnAnalyse, returnString">
		<param name="leftPart" value="${myLeftPart}"/>
		<param name="rightPart" value="${myRightPart}"/>
	</antcallback>
								
	<fl:echo>Ergebnis der Analyse: ${returnString}</fl:echo>
	<fl:let>myAnalyze::="${returnString}"</fl:let>
																
	<!--### Aufruf des Controllers der verschiedenen Fälle ####################-->									
	<antcallback target="-FGLCopyLocal_Control" return="returnControl, returnControlString, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
		<param name="analyze" value="${myAnalyze}"/>
		<param name="leftPart" value="${myLeftPart}"/>
		<param name="rightPart" value="${myRightPart}"/>												
	</antcallback>
	<fl:let>myReturnControl::="${returnControl}"</fl:let>											
	<fl:echo>myReturnControl=${myReturnControl}</fl:echo>
	<fl:let>myReturnControlString::="${returnControlString}"</fl:let>											
	<fl:echo>myReturnControlString=${myReturnControlString}</fl:echo>
	<fl:echo>returnSrca.filedir=${returnSrca.filedir}</fl:echo>
	<fl:echo>returnSrca.filename=${returnSrca.filename}</fl:echo>
	<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />
								
															
	<!-- Hänge die zurückgelieferten Arrays an die schon existierenden an -->																	
	<ac:if>
		<equals arg1="${returnControl}" arg2="true"/>
		<ac:then>
			<fl:echo>Ergebnis von -FGLCopyLocal_Control: ${returnControl}, haenge Array an.</fl:echo>
			<arrayAppendArrayJsZZZ arrayinput="${mySrcaTotal.filedir}" array2append="${mySrca.filedir}" arrayReturn="myArrayTotal"  returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />

			<arrayAppendArrayJsZZZ arrayinput="${mySrcaTotal.filename}" array2append="${mySrca.filename}" arrayReturn="myArrayTotal"  returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="mySrcaTotal.filename" sflagcontrol="" />

			<arrayAppendArrayJsZZZ arrayinput="${myDestaTotal.filedir}" array2append="${myDesta.filedir}" arrayReturn="myArrayTotal"   returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="myDestaTotal.filedir" sflagcontrol="" />
								
			<arrayAppendArrayJsZZZ arrayinput="${myDestaTotal.filename}" array2append="${myDesta.filename}" arrayReturn="myArrayTotal"   returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
			<arrayCopyJsZZZ arrayinput="${myArrayTotal}" arrayreturn="myDestaTotal.filename" sflagcontrol="" />
		</ac:then>
		<ac:else>
				<fl:echo>Ergebnis von -FGLCopyLocal_Control: ${returnControl} => kein Arraywert anzuhaengen.</fl:echo>
		</ac:else>
	</ac:if>	
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${myReturnControlString}" />
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="return.srcaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filename}" arrayreturn="return.srcaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filedir}" arrayreturn="return.destaTotal.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
	<arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="return.destaTotal.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
</target>

<!-- ######################################################################### -->
<target name="-FGLCopyLocal_Main"><!-- Parameter controlString: append_hostname, .... -->
	<fl:let>sScript::='-FGLCopyLocal_Main: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<fl:let>myControlString::='${controlString}'</fl:let> 					
	<arrayElementCountJsZZZ arrayinput="${myDestaTotal.filename}" ireturn="iSize.SrcaTotal.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<!--<echo>Anzahl der Dateien: ${iSize.SrcaTotal.filename}</echo>
	<echo>ControlString: ${myControlString}</echo>-->
	<ac:if>
		<equals arg1="0" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
		<ac:then>							
			<fl:let>myReturnString::="Keine Dateien im Array => keine Verarbeitung"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
		<ac:else>	
			<!-- Für VMD Dateien ist es möglich, dass die gleiche VM auf veschiedenen Rechnern läuft -->
			<!-- Darum sicherheitshalber und zum Abgleich jede Datei noch mit einem Postfix _RECHNERNAME ausstatten -->
			<!-- Führe aus Sicherheitsgründen zuerst diesen Kopiervorgang aus, danach den Kopiervorgang für die Datei ohne Postfix. -->				
			<!--### 1. Lauf Kopiere die Dateien (incl. NAMENSERWEITERUNG) der beiden Arrays  ##################### -->

			<!-- 1. Rechne das Dateinamen aus, ergaenzt um das Postfix -->
			<!-- 1a. Dateiendung entfernen -->
			<arrayLeftBackStringJsZZZ arrayinput="${myDestaTotal.filename}" sinput=".txt" arrayreturn="myDestaTotalReduced.filename" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>

			<!-- 1b. Hostnamen und Endung ausrechnen -->
			<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
					dies passiert hier durch flaka´s install-property handler task -->
			<fl:install-property-handler />
			<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
            <ac:if>			
				<equals arg1="'append_hostname'" arg2="'${myControlString}'"/><!-- der Hostname wird im Fall des 'vmd://' Schemas angehängt -->
				<ac:then>						
					<!--<fl:echo>Erweitere den Dateinamen um HOSTSUFFIX</fl:echo>-->
					<fl:let>sHostSuffix ::= "_${env.COMPUTERNAME}.txt"</fl:let><!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 			
				</ac:then>
				<ac:else>
					<fl:let>sHostSuffix ::= ".txt"</fl:let>
				</ac:else>
			</ac:if>
			
		
			<!-- Hänge an alle Einträge des arrays den _HOSTNAME + Endung String an -->
			<arrayPlusStringJsZZZ arrayinput="${myDestaTotalReduced.filename}" sinput="${sHostSuffix}" arrayreturn="myDestaTotalExtended.filename"  returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
	
			<antcallback target="-FGLCopyLocal_Copy" return="returnControl,returnControlString">					
				<param name="srca.filename" value="${mySrcaTotal.filename}"/>
				<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
				<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
				<param name="desta.filename" value="${myDestaTotalExtended.filename}"/>					
			</antcallback>
			<fl:let>myReturnControl ::="${returnControl}"</fl:let>
			<fl:let>myReturnControlString ::="${returnControlString}"</fl:let>
		
		
			<!--### Automatischer 2. Lauf, wenn auf einem HOSTrechner gestartet wird: ????? #####################-->
			<!-- NEIN 20151005 : So kommt es zu Problemen, weil sich der Inhalt dieser Datei von HostRechner zu HostRechner unterscheidet.
								 Eine Alternative Lösung muss her:
								 Z.B. Erstelle ein Sammeldokument .html, in dem in einzelnen DIVs 
								 der Inhalt der hostspezifischen Clientdatei eingefügt wird. -->
			<!--  
			<antcallback target="-FGLCopyLocal_Copy" return="returnControl,returnString">					
				<param name="srca.filename" value="${mySrcaTotal.filename}"/>
				<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
				<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
				<param name="desta.filename" value="${myDestaTotal.filename}"/>					
			</antcallback>	
			<fl:let>myReturnControl ::="${returnControl}"</fl:let>
			<fl:let>myReturnString ::="${returnString}"</fl:let>
			-->
		</ac:else>
	</ac:if><!-- Anzahl der Dateien pruefen -->

	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /> --><!-- Merke: So gibt man einen Arraywertzurueck -->
</target>

<target name="-FGLCopyLocal_Copy">
			<fl:let>sScript::='-FGLCopyLocal_Copy: '</fl:let>
			<fl:let>sTrace::=""</fl:let>
			<!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->

			<fl:let>mySrcaTotal.filedir::="${srca.filedir}"</fl:let>
			<fl:let>mySrcaTotal.filename::="${srca.filename}"</fl:let>
			<fl:let>myDestaTotal.filedir::="${desta.filedir}"</fl:let>
			<fl:let>myDestaTotal.filename::="${desta.filename}"</fl:let>

			<arrayElementCountJsZZZ arrayinput="${mySrcaTotal.filename}" ireturn="iSize.SrcaTotal.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
			<echo>Anzahl der Dateien: ${iSize.SrcaTotal.filename}</echo>
			<ac:if>
				<equals arg1="0" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
				<ac:then>
					<echo>Keine Dateien im Array => keine Verarbeitung</echo>
				</ac:then>
				<ac:else>					
					<!-- Leite das Kopieren ein -->
					<ac:if>				
					<equals arg1="1" arg2="${iSize.SrcaTotal.filename}"/><!-- Merke: man muss doch tatsächlich ein Fallunterscheidung einbauen, da in ac:for (des aufzurufenden copy Targets) nicht beide Parameter 0 (also gleich) sein dürfen. -->
					<ac:then>

						<!-- ###### KOPIERE NUR EINEN WERT ############## -->
						<arrayGetJsZZZ arrayinput="${mySrcaTotal.filedir}" index="0" arrayget="mySrc.sFiledir" sflagcontrol=""/>	
						<arrayGetJsZZZ arrayinput="${mySrcaTotal.filename}" index="0" arrayget="mySrc.sFilename" sflagcontrol=""/>	
						<arrayGetJsZZZ arrayinput="${myDestaTotal.filedir}" index="0" arrayget="myDest.sFiledir" sflagcontrol=""/>	
						<arrayGetJsZZZ arrayinput="${myDestaTotal.filename}" index="0" arrayget="myDest.sFilename" sflagcontrol=""/>
					
						<!--<propertyregex property="mytemp01" input="${mySrc.sFiledir}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen. Merke: Property ist nicht veränderbar, darum für jeden Aufruf eine extra Variable verwenden. -->
						<!--<echo>Normierter Verzeichniseintrag: ${mytemp}</echo>-->
						<!--<fl:let>mySrc.sFiledirNormed::='${mytemp01}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
						<!--<echo>Normierter Verzeichniseintrag: ${mysFiledirNormed}</echo>-->
						
						<!--<propertyregex property="mytemp02" input="${myDest.sFiledir}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen. Merke: Property ist nicht veränderbar, darum für jeden Aufruf eine extra Variable verwenden. -->
						<!--<echo>Normierter Verzeichniseintrag: ${mytemp}</echo>-->
						<!--<fl:let>myDest.sFiledirNormed::='${mytemp02}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
						<!--<echo>Normierter Verzeichniseintrag: ${mysFiledirNormed}</echo>-->
						
						<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
						<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">
							<param name="stringInput" value="${mySrc.sFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							<param name="intNumber" value="1" />
						</antcallback>													
						<echo>${sScript}Normierter Verzeichniseintrag -returnString: ${returnString}</echo>
						<fl:let>mySrc.sFiledirNormed::='${returnString}'</fl:let><!-- wichtig: Call by value erzwingen -->
						<echo>${sScript}Normierter Verzeichniseintrag -src: ${mySrc.sFiledirNormed}</echo>
						
						<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
						<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">
							<param name="stringInput" value="${myDest.sFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							<param name="intNumber" value="1" />
						</antcallback>													
						<echo>${sScript}Normierter Verzeichniseintrag -returnString: ${returnString}</echo>
						<fl:let>myDest.sFiledirNormed::='${returnString}'</fl:let><!-- wichtig: Call by value erzwingen -->
						<echo>${sScript}Normierter Verzeichniseintrag -dest: ${myDest.sFiledirNormed}</echo>
						
											
					
						<antcallback target="-FGLCopyLocal_CopyFileSingle" return="returnControl,returnControlString">					
								<param name="src.sFiledir" value="${mySrc.sFiledirNormed}"/>
								<param name="src.sFilename" value="${mySrcaTotal.filename}"/>								
								<param name="dest.sFiledir" value="${myDest.sFiledirNormed}"/>
								<param name="dest.sFilename" value="${myDestaTotal.filename}"/>					
						</antcallback>	
						<fl:let>myReturnControl ::="${returnControl}"</fl:let>
						<fl:let>myReturnControlString ::="${returnControlString}"</fl:let>
					</ac:then>
					<ac:else> 
					<antcallback target="-FGLCopyLocal_CopyFileByFile" return="returnControl,returnControlString">					
								<param name="srca.filename" value="${mySrcaTotal.filename}"/>
								<param name="srca.filedir" value="${mySrcaTotal.filedir}"/>
								<param name="desta.filedir" value="${myDestaTotal.filedir}"/>
								<param name="desta.filename" value="${myDestaTotal.filename}"/>					
						</antcallback>
						<fl:let>myReturnControl ::="${returnControl}"</fl:let>
						<fl:let>myReturnControlString ::="${returnControlString}"</fl:let>
					</ac:else>
					</ac:if> 
				</ac:else>
			</ac:if>
			
			<!-- Rueckgabewerte -->
			<ac:var name="returnControl" value="${myReturnControl}" />
			<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />		
</target>
<target name="-FGLCopyLocal_CopyFileByFile">
	<fl:let>sScript::='-FGLCopyLocal_CopyFileByFile: '</fl:let>
	
	<fl:let>mySrca.filedir ::= "${srca.filedir}"</fl:let>
	<fl:let>mySrca.filename ::= "${srca.filename}"</fl:let>
	<fl:let>myDesta.filedir ::= "${desta.filedir}"</fl:let>
	<fl:let>myDesta.filename ::= "${desta.filename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> -->
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Prüfen: Alle Arrays sollen gleich lang sein.-->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filedir}" ireturn="iSize.Srca.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${mySrca.filename}" ireturn="iSize.Srca.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filedir}" ireturn="iSize.Desta.filedir"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${myDesta.filename}" ireturn="iSize.Desta.filename"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<ac:if>
		<and>
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Srca.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filename}" />
			<equals arg1="${iSize.Srca.filedir}" arg2="${iSize.Desta.filedir}" />
		</and>
		<ac:then>		
				<fl:echo message="Alle Arrays haben gleich viel Elemente: ${iSize.Srca.filedir} " />				
		</ac:then>
		<ac:else>
				<fl:fail message="Unterschiedliche Anzahl an Elementen in den Arrays: iSize.Srca.filedir=${iSize.Srca.filedir} | iSize.Srca.filename=${iSize.Srca.filename} | iSize.Desta.filedir=${iSize.Desta.filedir} | iSize.Desta.filename=${iSize.Desta.filename}  "/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:else>
	</ac:if>
	
	<!-- Merke es gibt ein antcontrib Target 'Pathtofileset' dies hier vielleicht anwenden ? -->
	
	<!-- Schleife über alle Arraypositionen-->
	<!-- TODO IDEE: Ermittle den letzten wert des arrays -->

	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${iSize.Srca.filename}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>Errechneter ubound Wert des Arrays: ${iubound}</echo>
	
	<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
	<ac:for param="icounter" end="${iubound}">			
		<sequential>
			<echo>icounter is @{icounter}</echo> 
			<arrayGetJsZZZ arrayinput="${mySrca.filedir}" index="@{icounter}" arrayget="mySrc.filedir" sflagcontrol=""/>	
			<arrayGetJsZZZ arrayinput="${mySrca.filename}" index="@{icounter}" arrayget="mySrc.filename" sflagcontrol=""/>	
			<arrayGetJsZZZ arrayinput="${myDesta.filedir}" index="@{icounter}" arrayget="myDest.filedir" sflagcontrol=""/>	
			<arrayGetJsZZZ arrayinput="${myDesta.filename}" index="@{icounter}" arrayget="myDest.filename" sflagcontrol=""/>	
				
			<!-- 4. Der eigentliche Kopiervorgang -->
			<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
			<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
			<echo>Pushing File FileByFile ${mySrc.filedir}\${mySrc.filename} to Destination: ${myDest.filedir}\${myDest.filename} </echo>
														
			<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
			<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
						  TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
			<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
			<!-- 	Relative Pfade verwenden:
			<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
			<fileset dir="//${mySrc.filedir}">		 -->
			
			<!-- absolute Pfade verwenden: -->
			<copy todir="${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
				<fileset dir="${mySrc.filedir}">		
				<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
				<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
				<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
																
					<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
					<include name="${mySrc.filename}" />				
				</fileset>
				<globmapper from="${mySrc.filename}" to="${myDest.filename}"/>
			</copy>
		</sequential>
		</ac:for>		

	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
</target>
<target name="-FGLCopyLocal_CopyFileSingle">
	<fl:let>sScript::='-FGLCopyLocal_CopyFileSingle: '</fl:let>
	<fl:let>mySrc.sFiledir::="${src.sFiledir}"</fl:let>
	<fl:let>mySrc.sFilename::="${src.sFilename}"</fl:let>
	<fl:let>myDest.sFiledir::="${dest.sFiledir}"</fl:let>
	<fl:let>myDest.sFilename::="${dest.sFilename}"</fl:let>
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> -->
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			
	<!-- 4. Der eigentliche Kopiervorgang -->
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing File Single ${mySrc.sFiledir}\${mySrc.sFilename} to Destination: ${myDest.sFiledir}\${myDest.sFilename} </echo>
													
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	 
	<!-- ACHTUNG: Existiert die Quelldatei nicht, kommt es hier zu einem BUILD Fehler.
				  TODO: Diesen abfangen (try ... catch), protokollieren und weiter zum nächsten in der Schleife -->
	<!-- Merke: WIE WIRD DER NEUE DATEINAME GESETZT ? innerhalb von <copy><fileset dir=...> </fileset><globmapper from="*" to="*.bak"/></copy>-->
	<!-- 	Relative Pfade verwenden:
	<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
	<fileset dir="//${mySrc.filedir}">		 -->
	
	<!-- absolute Pfade verwenden: -->
	<copy todir="${myDest.sFiledir}" overwrite="false"  preservelastmodified="true"> 
		<fileset dir="${mySrc.sFiledir}">		
		<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
		<!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
														
			<!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
			<include name="${mySrc.sFilename}" />				
		</fileset>
		<globmapper from="${mySrc.sFilename}" to="${myDest.sFilename}"/>
	</copy>
	
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnControlString" value="${sScript}Alles o.k." />
</target>

<target name="-FGLCopyLocal_Analyze">
	<fl:let>sScript::='-FGLCopyLocal_Analyze: '</fl:let>
	<fl:let>myLeftPart ::= "${leftPart}"</fl:let>
	<fl:let>myRightPart ::= "${rightPart}"</fl:let>
	<fl:let>myCaseTotal ::= ""</fl:let>

	<!-- Merke: Die Analyse der beiden Teile links/rechts ist gleich. Daher dies in ein target ausgelagert, das dann jeweils aufgerufen wird. -->	
	<antcallback target="-FGLCopyLocal_AnalyzePart" return="returnControl,returnString">					
			<param name="sPartToAnalyze" value="${myLeftPart}"/>											
	</antcallback>	
	<fl:let>myCaseLeft ::= "${returnString}"</fl:let>	

	<isBooleanJsZZZ inputvalue="${returnControl}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test="${myValueIsBoolean}==true">
			<fl:choose>
				<fl:when test="${myBooleanValue}==true">
					<echo>Analyze des linken Teils war erfolgreich. Starte Analyze des rechten Teils.</echo>
					<antcallback target="-FGLCopyLocal_AnalyzePart" return="returnControl,returnString">					
						<param name="sPartToAnalyze" value="${myRightPart}"/>											
					</antcallback>
					<fl:let>myCaseRight ::= "${returnString}"</fl:let>
					<fl:let>myCaseTotal ::= "${myCaseLeft}${myCaseRight}"</fl:let>
				</fl:when>	
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<echo>Analyze des linken Teils war NICHT erfolgreich. Spare mir die Auswertung des rechten Teils.</echo>
				</otherwise>
			</fl:choose>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>Auswertung vom linken Teil mit Fehler. Spare mir die Auswertung des rechten Teils.</echo>
		</otherwise>
	</fl:choose>
			
	<echo>Soweit ermittelter Fall: ${myCaseTotal}</echo>

	<!-- Rueckgabebwerte -->
	<ac:var name="returnAnalyze" value="${myReturnControl}" />
	<ac:var name="returnString" value="${myCaseTotal}" />	
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->				
</target>
<target name="-FGLCopyLocal_AnalyzePart">
	<fl:let>sScript::='-FGLCopyLocal_AnalyzePart: '</fl:let>
	<fl:let>myPart::="${sPartToAnalyze}"</fl:let>
	
	<!-- Prüfe, ob Datei vom Linken Teil existiert -->
	<fl:choose><!-- Merke: choose muss man verwenden, wenn man otherwise einsetzen will. -->
		<fl:when test=" '${myPart}'.tofile.exists == true ">
			<echo>Datei/Verzeichnis existiert: ${myPart}</echo>
																									
			<!-- Prüfe, ob es ein Verzeichnis ist -->
			<isDirectoryZZZ text="${myPart}" property="myisdirectoryPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
			<echo>Teil: isdirectory=${myisdirectoryPart}</echo>
														
			<fl:when test="${myisdirectoryPart} == true">
					<!-- A) Teil - Verzeichnis-Fall: -->
					<echo>Teil: ist Verzeichnis</echo>
					<fl:let>myCase::="D"</fl:let>	<!-- D=directory-->																						 
			</fl:when>
			<fl:when test="${myisdirectoryPart} != true">			
					<!-- B) Linker Teil - Dateipfad-Fall:-->
					<echo>Teil: ist KEIN Verzeichnis</echo>
					<fl:let>myCase::="F"</fl:let><!-- F=file-->
			</fl:when>
		</fl:when>
		<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
			<echo>Datei/Verzeichnis existiert NICHT: ${myPart}</echo>
										   <!-- Merke: kleines d , d.h. Verzeichnis existiert nicht => Datei existiert auch nicht. -->
			                               <!--        Kleines f, d.h. Datei existiert nicht, Verzeichnis aber. -->
			<!-- <fl:fail message="Datei/Verzeichnis existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
			<isFilenameRelevantVMD text="${myPart}" property="myisfilenamePart" />			
			<isBooleanJsZZZ inputvalue="${myisfilenamePart}" returnbooleanvalue="myBooleanValue" returnboolean="myValueIsBoolean" returnchanged="myReturnChanged" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />	 
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>	
			<fl:choose>
 			<fl:when test="${myValueIsBoolean}==true">
				<!-- <echo>When:  Ein boolean Wert wurde gefunden.</echo> -->
				<fl:choose>
				<fl:when test="${myBooleanValue}==true">
					<echo>NICHT EXISTIERENDER EINTRAG GILT ALS DATEINAME: ${myPart}</echo>
					<fl:let>myCase::="f"</fl:let>
				</fl:when>	
				<otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->
					<echo>NICHT EXISTIERENDER EINTRAG GILT ALS VERZEICHNIS: ${myPart}</echo>
					<fl:let>myCase::="d"</fl:let>
				</otherwise>
				</fl:choose>
			</fl:when>
			<otherwise>
				<echo>Ergebnis von isFilenameRelevantVMD (= ${myValueIsBoolean} ) nicht interpretierbar: ${myPart}</echo>
				<fl:let>myCase::="X"</fl:let>
			</otherwise><!-- Merke: otherwise gehört nicht zu flaka! -->	
			</fl:choose>
		</otherwise>
	</fl:choose>
	
	<echo>Teilanalyze Fall: ${myCase}</echo>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnString" value="${myCase}" />	
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->		
</target>
<target name="-FGLCopyLocal_Control">
	<fl:let>sScript::='-FGLCopyLocal_Control: '</fl:let>
	<fl:let>myAnalyze::="${analyze}"</fl:let>
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	
	<!--### Zu Anfang erst einmal alle Rückgabeparameter mit Leerstring deklarieren, damit selbst im "false-Fall" keine $Variablennamen zurückgegeben werden. ### -->
	<arrayInitJsZZZ isize="0" arrayreturn="mySrca.filedir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayInitJsZZZ isize="0" arrayreturn="mySrca.filename"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayInitJsZZZ isize="0" arrayreturn="myDesta.filedir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayInitJsZZZ isize="0" arrayreturn="myDesta.filename"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->

	
	<!--### START: Aufruf der verschiedenen Fälle ####################-->
	<!-- F=file, D=directory,X=not defined, f=file not found, d=directory not found.
   	      Es geht nicht nur um die Konfiguration, sondern auch darum, dass die Dateien / Verzeichnisse existieren -->
	
	<!-- Je nach Fall ein anderes Target aufrufen. Dadurch ist der Code modularer --> 	
	<!-- Jeweils ein Array erstellen 1) mit den Werten des Ausgangsdateipfads, 2) mit den Werten des Zieldateipfads -->										
	<ac:if>
		<ac:equals arg1="${myAnalyze}" arg2="dd"/>										
		<ac:then>
			<echo>Fall: Verzeichnis links nicht existent, Verzeichnis rechts nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControlString::="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	<ac:elseif>
		<!-- TODO noch Kaputt: Instring abprüfen auf X -->
		<ac:equals arg1="${myAnalyze}" arg2="XX"/>										
		<ac:then>
			<echo>Fall: Linker Ausdruck nicht interpretierbar, rechter Ausdruck nicht interpretierbar</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControlString::="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>		
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="ff"/>										
		<ac:then>
			<echo>Fall: Datei links nicht existent, rechts Datei nicht existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControlString::="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="dD"/>										
		<ac:then>
			<echo>Fall: Verzeichnis links nicht existent, rechts Verzeichnis existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControlString::="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="fD"/>										
		<ac:then>
			<echo>Fall: Datei links NICHT existent, rechts Verzeichnis existent</echo>
			<!-- <fl:fail message="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
			<fl:let>myReturnControlString::="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="Dd"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis existent, rechts Verzeichnis NICHT existent</echo>
			<!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->
			
			<!-- TODO noch Kaputt: Kopiere alle Dateien des Verzeichnisses links in das Verzeichnis nach rechts. -->
			<fl:let>myReturnControlString::="NOCH NICHT ENTWICKELT. Kopiere alle Dateien des Verzeichnisses links in das Verzeichnis nach rechts. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>
	<ac:or>
		<ac:equals arg1="${myAnalyze}" arg2="DF"/>										
		<ac:equals arg1="${myAnalyze}" arg2="Df"/>										
	</ac:or>
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts existierende/nicht existierende Datei</echo>
			<!-- Kopiere die rechts benannte Datei aus dem links angegebenen Verzeichnis nach rechts -->
			<antcallback target="-FGLCopyLocal_Control_DF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Control_DF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControlString ::="Ergebnis des Control_DF Aufrufs: ${returnControl}"</fl:let>
			<fl:let>myReturnControl::="${returnControl}"</fl:let>	
			<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FD"/>
			<ac:equals arg1="${myAnalyze}" arg2="Fd"/><!-- Merke: Nicht existierende Verzeichnisse werden automatisch durch ant erstellt. -->
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Verzeichnis</echo>
			<antcallback target="-FGLCopyLocal_Control_FD" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Control_FD Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControlString ::="Ergebnis des Control_FD Aufrufs: ${returnControl}"</fl:let>
			<fl:let>myReturnControl::="${returnControl}"</fl:let>	
			<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />			
		</ac:then>
	</ac:elseif>
	<ac:elseif>
		<ac:equals arg1="${myAnalyze}" arg2="DD"/>										
		<ac:then>
			<echo>Fall: links Verzeichnis, rechts Verzeichnis</echo>
			<!-- TODO GOON 20150923: Kopiere alle Dateien aus dem einen Verzeichnis in das andere -->
			<fl:let>myReturnControlString::="NOCH NICHT ENTWICKELT. Kopiere alle Dateien aus dem einen Verzeichnis in das andere. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>
	</ac:elseif>
	<ac:elseif>		
		<ac:or>
			<ac:equals arg1="${myAnalyze}" arg2="FF"/>
			<ac:equals arg1="${myAnalyze}" arg2="Ff"/><!-- kleines f = nicht existierende Datei -->
		</ac:or>
		<ac:then>
			<echo>Fall: links Datei, rechts Datei (oder noch nicht existent)</echo>

			<antcallback target="-FGLCopyLocal_Control_FF" return="returnControl, returnSrca.filedir, returnSrca.filename, returnDesta.filedir, returnDesta.filename">
				<param name="leftPart" value="${myLeftPart}"/>
				<param name="rightPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnSrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${returnDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

			<fl:echo>Ergebnis des Control_FF Aufrufs: ${returnControl}</fl:echo>
			<fl:let>myReturnControlString ::="Ergebnis des Control_FF Aufrufs: ${returnControl}"</fl:let>
			<fl:let>myReturnControl ::= "${returnControl}"</fl:let>
			<arrayCopyJsZZZ arrayinput="${returnSrca.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnSrca.filename}" arrayreturn="mySrca.filename" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" />
			<arrayCopyJsZZZ arrayinput="${returnDesta.filename}" arrayreturn="myDesta.filename" sflagcontrol="" />
		</ac:then>
	</ac:elseif>	
	<ac:elseif>
		<ac:or>			
			<ac:equals arg1="${myAnalyze}" arg2="fd"/>
			<ac:equals arg1="${myAnalyze}" arg2="df"/>
		</ac:or>
		<ac:then>			
			<echo>Fall: Datei nicht existent, Verzeichnis nicht existent</echo>
			
			<!-- Kein komplettes abbrechen, nur weil eine Datei nicht existiert. -->
			<fl:let>myReturnControlString::="Ungueltiges Konfiguration. Analyseergebnis ist: ${myAnalyze}"</fl:let>
			<fl:let>myReturnControl::=false</fl:let>		

			<!-- TODO NOCH KAPUTT: Dafür sorgen, das keine Datei / kein Verzeichnis zurückgegeben wird. -->
		</ac:then>
	</ac:elseif>	
	<ac:else>		
		<fl:fail message="Ungueltiges Analyseergebnis: ${myAnalyze}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->										
	</ac:else>											
	</ac:if>	
	
	<!-- Rueckgabebwerte -->
	<fl:echo>${sScript}##############################################################################################################################</fl:echo>
	<fl:echo>${sScript}zurueckgegebene Arrays. Es sollten die 'unerwuenschten' Dateien und Verzeichnisskombinationen nicht mehr darin enthalten sein.</fl:echo>
	<arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	<arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->	
	
	
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${myReturnControlString}" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${myDesta.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" />
		
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
</target>

<target name="-FGLCopyLocal_Control_FD">
	<fl:let>sScript::='-FGLCopyLocal_Control_FD: '</fl:let>
	<!-- Fall: Kopiere die benannte Datei von links nach rechts in das benannte Verzeichnis. -->	
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	<!--  "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	
	<!-- <fl:echo>FD-FALL: BIS HIERHER O.K.!!! -FGLCopyLocal_Control_FD</fl:echo> -->
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
	
	<fl:let>myReturnControl::="${returnControl}"</fl:let>
	<fl:let>mySrca.filedir::="${returna.filedir}"</fl:let><!-- klappt das mit fl:let so? oder sollte man doch besser das ganze Array kopieren? -->	
	<fl:let>mySrca.filename::="${returna.filename}"</fl:let>
	<!-- <arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
	<!-- <arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="mySrca.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->		
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<ac:if>
		<ac:equals arg1="${myReturnControl}" arg2="false"/>										
		<ac:then>
			<echo>Linker Fall=false => Ueberspringe rechten Fall</echo>
		</ac:then>
		<ac:else>
			<echo>Behandle rechten Fall: Uebernimm dabei die Datei Angabe vom linken Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_D_Part" return="returnControl, returna.filedir">
				<param name="sPart" value="${myRightPart}"/>
				<param name="saFilename" value="${mySrca.filename}"/><!-- TODO GOON : Parameter hinzugefügt 20150921, weil er in der Funktion verwendet wurde. Sinnvoll? -->
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			
			<fl:let>returnControl ::= "${returnControl}"</fl:let>
			<fl:let>myDesta.filedir ::= "${returna.filedir}"</fl:let><!-- klappt das mit fl:let so? oder sollte man doch besser das ganze Array kopieren? -->	
			<fl:let>myDesta.filename ::= "${mySrca.filename}"</fl:let><!-- WICHTIG: HIER WIRD DER QUELLDATEINAME ALS ZIELDATEINAME UEBERNOMMEN -->
			<!-- <arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
			<!-- <arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="myDesta.filename" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->		
						
			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->				
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->			
		</ac:else>
	</ac:if>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" /><!-- WICHTIG: Uebernimm die Dateien von links --><!-- So gibt man einen Arraywertzurueck -->		
</target>

<target name="-FGLCopyLocal_Control_DF">
	<fl:let>sScript::='-FGLCopyLocal_Control_DF: '</fl:let>
	<!-- Fall: Kopiere die recht benannte Datei vom Verzeichnis links nach rechts an den benannten Dateinamen. -->	
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	<echo>Behandle rechten Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
		<param name="sPart" value="${myRightPart}"/>
	</antcallback>
	<fl:let>myReturnControl::="${returnControl}"</fl:let>
	
	<!--<fl:let>myDesta.filedir::="${returna.filedir}"</fl:let>--><!-- klappt das mit dem fl:let so, oder sollte man doch das array kopieren? -->
	<!--<fl:let>myDesta.filename::="${returna.filename}"</fl:let>-->
	<arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" /><!-- So nimmt man einen Arraywert entgegen. -->	
	<arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="myDesta.filename" sflagcontrol="" /><!-- So nimmt man einen Arraywert entgegen. -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	
	<ac:if>
		<ac:equals arg1="${returnControl}" arg2="false"/>										
		<ac:then>
			<echo>Rechter Fall=false => Ueberspringe linken Fall</echo>
		</ac:then>
		<ac:else>
			<echo>Behandle linken Fall: Uebernimm dabei die Datei Angabe vom rechten Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_D_Part" return="returnControl, returna.filedir">
				<param name="sPart" value="${myLeftPart}"/>	
				<param name="saFilename" value="${myDesta.filename}"/><!-- Das dient nur dazu die Anzahl der Dateien zu ermitteln, um so x-mal einen Verzeichniseintrag zu erstellen --><!-- TODO GOON : Parameter hinzugefügt 20150921, weil er in der Funktion verwendet wurde. Sinnvoll? -->				
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<!-- <arrayDebugJsZZZ arrayinput="${returnA.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<fl:let>mySrca.filedir::="${returna.filedir}"</fl:let><!-- klappt das mit dem fl:let so, oder sollte man doch das array kopieren? -->
			<fl:let>mySrca.filename::="${myDesta.filename}"</fl:let><!-- WICHTIG: HIER WIRD DER ZIELDATEINAME ALS QUELLDATEINAME UEBERNOMMEN -->
			<fl:let>myReturnControl::="${returnControl}"</fl:let>

			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->				
		</ac:else>
	</ac:if>
		
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />		
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->	
</target>

<target name="-FGLCopyLocal_Control_FF">
	<fl:let>sScript::='-FGLCopyLocal_Control_FF: '</fl:let>
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myLeftPart::="${leftPart}"</fl:let>
	<fl:let>myRightPart::="${rightPart}"</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>

	<!-- TODO: Dynamisch auf den aktuellen TargetNamen zugreifen.... tryoutAnt_Reflection - currentTarget name
	siehe mein Dokument:
	Java / Ant : BasisObjekte. project / elements (nutzbar auch in scriptdef - JavaScript bietet ein wenig Reflection )		
I think you can't, unless you spend some time coding your own custom tasks (http://ant.apache.org/manual/tutorial-writing-tasks.html)
The built-in properties you can display are: basedir, ant.file, ant.version, ant.project.name, ant.java.version

Ich will aber versuchen es mit einer Scriptdef <reflectionTargetCurrent> zu lösen.	
	target name="test">
  <script language="javascript">
    project.setNewProperty("current_target", self.getOwningTarget());
  </script>
  <echo>${current_target}</echo>
</target>
	-->
	
	<!--  "Part"-Behandlung durch Aufruf der Targets -->
	<echo>Behandle linken Fall</echo>
	<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
		<param name="sPart" value="${myLeftPart}"/>
	</antcallback>
	
	<!-- <fl:echo>FF-FALL: BIS HIERHER O.K.!!! -FGLCopyLocal_Control_FF</fl:echo> -->
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	<!-- <arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
	
	<arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="mySrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="mySrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<fl:let>myReturnControl::=${returnControl}</fl:let>
	<ac:if>
		<ac:equals arg1="${myReturnControl}" arg2="false"/>										
		<ac:then>
			<echo>Linker Fall=false => Ueberspringe rechten Fall</echo>
		</ac:then>
		<ac:else>			
			<echo>Behandle rechten Fall</echo>
			<antcallback target="-FGLCopyLocal_Control_F_Part" return="returnControl, returna.filedir, returna.filename">
				<param name="sPart" value="${myRightPart}"/>
			</antcallback>
			<!-- <arrayDebugJsZZZ arrayinput="${returna.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			<!-- <arrayDebugJsZZZ arrayinput="${returna.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->		
			
			<arrayCopyJsZZZ arrayinput="${returna.filedir}" arrayreturn="myDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
			<arrayCopyJsZZZ arrayinput="${returna.filename}" arrayreturn="myDesta.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	

			<!-- Rückagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${myDesta.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filedir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
			<!-- <arrayDebugJsZZZ arrayinput="${mySrca.filename}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->
			<fl:let>myReturnControl::=true</fl:let>
		</ac:else>
	</ac:if>
	
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<arrayCopyJsZZZ arrayinput="${mySrca.filedir}" arrayreturn="returnSrca.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${mySrca.filename}" arrayreturn="returnSrca.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filedir}" arrayreturn="returnDesta.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	
	<arrayCopyJsZZZ arrayinput="${myDesta.filename}" arrayreturn="returnDesta.filename" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->	

</target>

<target name="-FGLCopyLocal_Control_F_Part">
	<fl:let>sScript::='-FGLCopyLocal_Control_F_Part: '</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<!-- der einfachste Fall, kopiere die Datei von links nach rechts, d.h. hier packe die reinkommenden Werte in die Returnarrays -->	
	<fl:let>myPart::="${sPart}"</fl:let>	
	<fl:echo>fuer: ${myPart}</fl:echo>
	
	
	<!-- Ermittle aus dem linken Teil den Dateinamen. Er sollte des letzte Element eines Arrays nach dem Aufruf der Splitt - Methode sein -->
	<!-- <echo>src.filedir = #{split('aabcc','b')[0]}</echo> -->
	<!-- Z.B.: Hiermit holt man ggfs. den Laufwerksnamen, oder auch das letzte Element -->
	<!-- <echo>src.filedir = #{split('${myLeftPart}','\\\\')[0]}</echo> -->
	<fl:let>sfileadir::=split('${myPart}','\\\\')</fl:let><!-- 4 Backslashe um den 1 Backslash zu escapen in der split - Funktion -->
											
	<!-- 2. ermittle die groesse der liste, damit man an den letzten Teil kommt. Entweder ein Verzeichnis oder eine Datei. -->
	<!--    Merke: #{size(${src.fileadir})} funktioniert nicht. Siehe tryoutAnt_FlakaListHandling -->																	

												
	<!-- Nutze deshalb auf src.fileadir den scriptdef aufruf -->											
	<arrayElementCountJsZZZ arrayinput="${sfileadir}" ireturn="mylistasize"/>
	<fl:echo>groesse tempa per scriptdef Aufruf: ${mylistasize}</fl:echo>								
	<echo>Pfadbestandteilausgabe</echo>
	<ac:for param="mydiry" list="${sfileadir}"><!-- Beachte das for nur für sequential funktioniert und darin mit @ auf die Param-Variable zugegriffen werden kann. -->
		<sequential>
			<echo>Pfadbestandteil: @{mydiry}</echo>
		</sequential>				
	</ac:for>
																	
	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mylistasize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<echo>errechneter wert fuer Index des letzten Pfadteils: ${index}</echo>
	<fl:let>xtractedvalue::=split('${myPart}','\\\\')[${index}]; 
		<!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
	</fl:let>
	<echo>An letzter Stelle gefundener wert: ${xtractedvalue}</echo>

	<!-- Hole den Pfad, als Teil links vom Dateinamen -->
	<!-- Merke: Format muss man verwenden um den Backslash in den String zu bekommen -->
	<!-- Merke: hier den format ausdruck noch mit #{ } umgeben, sonst wird er nicht ausgerechnet sondern als Text übergeben. -->
	<!-- Merke: das in eine Variable packen, sonst kann man es nicht an 'stringLeftStringZZZ' uebergeben. -->
	<fl:echo>#{format('\\%s', xtractedvalue)}</fl:echo> 
	<fl:let>xtractedvalueTemp::=#{"format('\\%s', xtractedvalue)"}	</fl:let>
	<stringLeftStringJsZZZ inputstring="${myPart}" inputmatchstring="${xtractedvalueTemp}" returnstring="myPath"  returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
	<echo>Der Pfad ist: ${myPath}</echo>
	
	<!-- 4. Packe die Werte in ein Array -->
	<arrayInitJsZZZ isize="0" arrayreturn="fileadir"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt. -->
	<arrayAppendJsZZZ arrayinput="${fileadir}" valueinput="${myPath}" arrayreturn="myFileadir" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />	
	<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
	<ac:if>
		<equals arg1="false" arg2="${myReturnControl}"/>
		<ac:then>							
			<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
			<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
		</ac:then>		
	</ac:if>
	<!-- <arrayDebugJsZZZ arrayinput="${myFileadir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	

	<arrayInitJsZZZ isize="0" arrayreturn="fileaname"/><!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
	<arrayAppendJsZZZ arrayinput="${fileaname}" valueinput="${xtractedvalue}" arrayreturn="myFileaname" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
	<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
	<ac:if>
		<equals arg1="false" arg2="${myReturnControl}"/>
		<ac:then>							
			<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
			<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
		</ac:then>		
	</ac:if>
	<!-- <arrayDebugJsZZZ arrayinput="${myFileaname}" ilevel="1"/ --><!-- Ausgabe des neuen Arrays -->	
	
		
	<!-- Rückagebwerteckagebwerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="true" />
	<arrayCopyJsZZZ arrayinput="${myFileadir}" arrayreturn="returna.filedir" sflagcontrol="" />
	<arrayCopyJsZZZ arrayinput="${myFileaname}" arrayreturn="returna.filename" sflagcontrol="" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>

<target name="-FGLCopyLocal_Control_D_Part">
	<fl:let>sScript::='-FGLCopyLocal_Control_D_Part: '</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<!-- Fall: Hole den Verzeichnisnamen aus dem rechten Teil und verwende die ermittelten Dateinamen aus dem linken Teil. -->	
	<fl:let>myPart::="${sPart}"</fl:let>
	<fl:let>myAFilename::="${saFilename}"</fl:let>
	<fl:echo>fuer: ${myPart}</fl:echo>
	<fl:echo>fuer: ${myAFilename}</fl:echo>
		
	<!-- Packe die Verzeichniswerte in ein Array. UND ZWAR so haeufig wie Dateien vorhanden sind. -->
	<!-- 1. Ermittle Anzahl der Dateien, das ist der einzige Grund warum myAFilename übergeben wird. -->
	<arrayElementCountJsZZZ arrayinput="${myAFilename}" ireturn="iSize"/>
	<echo>ArrayGroesse der Dateien: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
	
	<!-- 2. Fuellen des neuen Arrays in einer Schleife -->
	<ac:for param="icounter" end="${iSize}">
		<sequential>
			<arrayInitJsZZZ isize="0" arrayreturn="myAFiledir"/> <!-- Groesse 0, sonst wird das erste Element ein "empty element" und das neue wird angehängt.-->
			<arrayAppendJsZZZ arrayinput="${myAFiledir}" valueinput="${myPart}" arrayreturn="myArrayNew" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" sflagcontrol="" />
			<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString}" />
			<ac:if>
				<equals arg1="false" arg2="${myReturnControl}"/>
				<ac:then>							
					<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
					<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
				</ac:then>		
			</ac:if>
			<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myAFiledir" sflagcontrol="" />
		</sequential>
	</ac:for>
	<!-- <arrayDebugJsZZZ arrayinput="${myAFiledir}" ilevel="1"/> --><!-- Ausgabe des neuen Arrays -->	
	
	<!-- Rückgabewerte: Sie werden dann bis in die eigentliche Kopierfunktionalität weitergeschleift. -->
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="true" />	
	<arrayCopyJsZZZ arrayinput="${myAFiledir}" arrayreturn="returna.filedir" sflagcontrol="" /><!-- So gibt man einen Arraywertzurueck -->
</target>

<!-- ## Loeschanalyse/control Targets ########################################## -->
<target name="-FGLDelLocal_Main"><!-- Parameter controlString: Noch nix -->
	<fl:let>sScript::='-FGLDelLocal_Main: '</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true"/> <!-- unset="true" /> -->
	<ac:var name="myReturnControlString" value="alles o.k."/> <!-- unset="true" /> -->
	
	<fl:let>myControlString::='${controlString}'</fl:let> 	
	<echo>ControlString: ${myControlString}</echo>	
	<arrayCopyJsZZZ arrayinput="${saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />	
	
		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	
	
	<fl:let>bGoon::=true</fl:let>
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	
	<ac:if>
		<not>			
			<equals arg1="true" arg2="${bGoon}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->				
		</not>		
		<ac:then>							
			<fl:let>myReturnControl::=false</fl:let>
		</ac:then>	
		<ac:else>	
			<!-- Merke:
				Für VMD Dateien ist es möglich, dass die gleiche VM auf veschiedenen Rechnern läuft.
				Darum sicherheitshalber und zum Abgleich jede Datei noch mit einem Postfix _RECHNERNAME ausstatten 
				DAS GIBT ES HIER NICHT. -->		
			
			<!--### Lösche die Dateien, beschrieben durch die beiden Arrays  ##################### -->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
			<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
			<antcallback target="-FGLDelLocal_Delete" return="returnControl,returnControlString">					
				<param name="saTotal.filedir" value="${mysaTotal.filedir}"/>
				<param name="saTotal.filename" value="${mysaTotal.filename}"/>				
			</antcallback>
			<fl:let>myReturnControl::="${returnControl}"</fl:let>
			<!--<fl:let>myReturnControlString::="${returnControlString}"</fl:let>	-->
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
		</ac:else>
	</ac:if><!-- Anzahl der Dateien pruefen -->

		</ac:try>
	<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
		
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myDestaTotal.filename}" arrayreturn="destaTotal.filename" sflagcontrol="" /> --><!-- Merke: So gibt man einen Arraywertzurueck -->
</target>
<target name="-FGLDelLocal_Delete">
	<fl:let>sScript::='-FGLDelLocal_Delete: '</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<fl:let>sTrace::=""</fl:let>
	<ac:var name="myReturnControl" value="true" /> <!-- unset="true" /> -->
	<ac:var name="myReturnControlString" value="alles o.k." /> <!-- unset="true" /> -->
    <arrayCopyJsZZZ arrayinput="${saTotal.filedir}" arrayreturn="mysaTotal.filedir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.filename}" arrayreturn="mysaTotal.filename" sflagcontrol="" />	

		<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
	
	<fl:let>bGoon::=true</fl:let>
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filedir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.filename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays	-->
	
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.filedir}" ireturn="mysaTotal.filedir.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<!--<echo>Anzahl der Eintraege im Verzeichnisarray: ${mysaTotal.filedir.iSize}</echo>-->
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.filename}" ireturn="mysaTotal.filename.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<!--<echo>Anzahl der Eintraege im Dateiarray: ${mysaTotal.filename.iSize}</echo>-->	
	<ac:if>
		<or>
			<equals arg1="0" arg2="${mysaTotal.filedir.iSize}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->		
			<equals arg1="0" arg2="${mysaTotal.filename.iSize}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->		
		</or>		
		<ac:then>							
			<fl:let>myReturnString::="Keine Dateien in einem der Arrays => keine Verarbeitung"</fl:let>			
			<fl:let>bGoon::=false</fl:let>
		</ac:then>
	</ac:if>
	
	<ac:if>		
		<and>
			<not>
				<equals arg1="${mysaTotal.filedir.iSize}" arg2="${mysaTotal.filename.iSize}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->
			</not>		
			<equals arg1="true" arg2="${bGoon}"/><!-- Merke: man muss doch tatsächlich Sicherheitsabfrage einbauen, da in ac:for (des aufzurufenden copy Targets) der zweite Parameter nicht kleiner dem ersten sein darf. -->		
		</and>		
		<ac:then>							
			<fl:let>myReturnString::="Anzahl der Eintraege in den Arrays unterschiedlich => keine Verarbeitung"</fl:let>
			<fl:let>bGoon::=false</fl:let>
		</ac:then>
	</ac:if>
			
	<!-- Leite das Kopieren ein -->
	<ac:if>
		<equals arg1="true" arg2="${bGoon}"/>
			<ac:then>
				<ac:if>
					<equals arg1="1" arg2="${mysaTotal.filename.iSize}"/><!-- Merke: man muss doch tatsächlich ein Fallunterscheidung einbauen, da in ac:for (des aufzurufenden copy Targets) nicht beide Parameter 0 (also gleich) sein dürfen. -->			
					<ac:then>	
						<!-- ###### LOESCHE NUR EINEN WERT ############## -->
						<!--<fl:let>mysFiledir::=''</fl:let>-->
						<arrayGetJsZZZ arrayinput="${mysaTotal.filedir}" index="0" arrayget="mysFiledir" sflagcontrol=""/>	
						<!--<echo>Eintrag 0 im Verzeichnisarray: ${mysFiledir}</echo>-->											
						<arrayGetJsZZZ arrayinput="${mysaTotal.filename}" index="0" arrayget="mysFilename" sflagcontrol=""/>										
						<!--<echo>Eintrag 0 im Dateiarray: ${mysFilename}</echo>-->
						
						<!--<propertyregex property="mytemp" input="${mysFiledir}" regexp="\\" replace="\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur verdoppeln reicht nicht -->
						<!--<propertyregex property="mytemp" input="${mysFiledir}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" />--><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
						
						<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
						<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
							<param name="stringInput" value="${mysFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							<param name="intNumber" value="1" />
						</antcallback>
						
						<!--<fl:let>mysFiledirNormed::='${mytemp}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
						<fl:let>mysFiledirNormed::='${returnString}'</fl:let>
						<echo>${sScript}Normierter Verzeichniseintrag: ${mysFiledirNormed}</echo>
						
						<!-- SITUATION: Kopiert man mysFilename in eine andere Variable, geht scheinbar die Referenz verloren.
                                  ABER: Warum passiert das nur beim sFiledir?
							    LÖSUNG: Die einfachen Backslashe verhindern die Übertragung als Parameter für den antcallback. Man muss den Wert in Hochkommata setzen.-->				
						
						<antcallback target="-FGLDelLocal_DeleteFileSingle" return="returnControl,returnControlString">					
							<param name="sFiledir" value="${mysFiledirNormed}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->							
							<param name="sFilename" value="${mysFilename}"/>						
						</antcallback>	
						<fl:let>myReturnControl::="${returnControl}"</fl:let>						
						<!--<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>-->
						<ac:var name="myReturnControlString" value="${returnControlString}"/>						
						<ac:if>
							<equals arg1="${myReturnControl}" arg2="false" />
							<ac:then>		
									<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - '${myReturnControlString}'" />				
									<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
							</ac:then>
							<ac:else>						
							</ac:else>
						</ac:if>
					</ac:then>
					<ac:else> 
						<!-- 20160221: TODO GOON NOCH KAPUTT -->					
						<antcallback target="-FGLDelLocal_DeleteFileByFile" return="returnControl,returnControlString">					
							<param name="saTotal.sFiledir" value="${mysaTotal.filedir}"/>
							<param name="saTotal.sFilename" value="${mysaTotal.filename}"/>														
						</antcallback>
						<fl:let>myReturnControl::="${returnControl}"</fl:let>						
						<!--<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>-->
						<ac:var name="myReturnControlString" value="${returnControlString}"/>						
						<ac:if>
							<equals arg1="${myReturnControl}" arg2="false" />
							<ac:then>		
									<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFilebyFile festgestellt - '${myReturnControlString}'" />				
									<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
							</ac:then>
							<ac:else>						
							</ac:else>
						</ac:if>
					</ac:else>
				</ac:if> 
		</ac:then>
	</ac:if>
	
	
	</ac:try>
	<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
			
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />			
</target>
<target name="-FGLDelLocal_DeleteFileSingle"> 
	<fl:let>sScript::='-FGLDelLocal_DeleteFileSingle: '</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>
	<fl:let>sTrace::=""</fl:let>
	<!-- Durch dieses gekapselte Target kann in antcallback in einer Schleife eingebaut werden, der dann sowohl für den ubound=0 als auch für den ubound > 0 Fall aufgerufen werden kann. -->
	<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
	<ac:var name="myReturnControl" value="true" /> <!-- unset="true"/> -->
	<ac:var name="myReturnControlString" value="alles o.k." /> <!-- unset="true" /> -->
	
	<!-- Uebernahme von Einzelwerten -->
	<fl:let>myDir::='${sFiledir}'</fl:let><!-- Warum geht hier die Referenz verloren? Das muss mit den Backslashes zu tun haben. Ausserdem muss der Wert mit Backslashes in Hochkommata übertragen werden, quasi eine Möglichkeit es als byValue zu übertragen. -->
	<fl:let>myFile::='${sFilename}'</fl:let>
	
	<!-- Uebernahme von Array Werten -->
	<!--<arrayCopyJsZZZ arrayinput="${srcaTotal.filedir}" arrayreturn="mySrcaTotal.filedir" sflagcontrol="" />-->

	<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>

	<fl:when test="null('${myFile}')">
		<echo>Uebergabeparameter ist Null (myFile)</echo>
		<fl:fail message="Uebergabeparameter ist Null (myFile)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	<fl:when test="'${myFile}'==''">
		<echo>Uebergabeparameter ist Leerwert (myFile)</echo>
		<fl:fail message="Uebergabeparameter ist Leerwert (myFile)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	
	<fl:when test="null('${myDir}')">
		<echo>Uebergabeparameter ist Null (myDir)</echo>
		<fl:fail message="Uebergabeparameter ist Null (myDir)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>
	<fl:when test="'${myDir}'==''">
		<echo>Uebergabeparameter ist Leerwert (myDir)</echo>
		<fl:fail message="Uebergabeparameter ist Leerwert (myDir)"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	</fl:when>	
	<!--<fl:echo>Uebergabeparameter sind (myDir = myFile):  ${myDir} = ${myFile}</fl:echo>-->
																
	<!-- ### Lösche anhand des Verzeichnis- und Dateinamens -->
	<!-- TODO Fange Fehler ab, wenn eine Datei / ein Verzeichnis nicht (mehr) vorhanden ist -->
	<!-- TODO GOON noch kaputt: Den Fall abfangen, falls eine Datei nicht gelöscht werden kann, wg. Rechte, in anderem Programm geöffnet, etc. -->
	<!-- TODO GGON noch kaputt: Prüfe, ob der Backslash am Emde steht, ergänze ihn falls notwendig -->
	<echo>Deleting File Single ${myDir}\\${myFile}</echo>
											
    <!-- Dokumentation: -->											
	<!-- 	Relative Pfade verwenden, auch beim Löschen?:
	<copy todir="//${myDest.filedir}" overwrite="false"  preservelastmodified="true"> 
	<fileset dir="//${mySrc.filedir}">		 -->
	
	<!-- Von mir verwendetere Ausdruck zum Löschen von Verzeichnissen, nur wenn sie leer sind.
	<delete includeemptydirs="true">
		<fileset dir="onlyifempty" excludes="**/*" />
	</delete>       -->
	
	<!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
	<!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />-->
					
	<!-- absolute Pfade verwenden: -->
	<!-- Das eigentliche Löschen beim Test temporaer raus, sonst muss man sich immer wieder neu die Testdateien hinlegen. --> 
	<delete includeEmptyDirs="true"><!-- Lösche das Ausgangsverzeichnis, wenn es leer ist (was durch includeEmptyDirs='true' gesteuert wird. -->
		<fileset dir="${myDir}" includes="${myFile}" defaultexcludes="false"><!-- z.B. *.svn Dateien gehoeren zu den Defautlexcludes, d.h. wuerden nicht geloescht. -->																			
			<include name="${myFile}" /><!--Hier den errechneten Namen der Dateien verwenden und nicht z.B. alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->					
		</fileset>	
		<fileset dir="${myDir}" excludes="**/*" defaultexcludes="false" /><!-- z.B. *.svn Dateien gehoeren zu den Defautlexcludes, d.h. wuerden nicht geloescht. -->									
	</delete>
	
		<!-- Problem: Damit wird aber nicht der ganze Pfad gelöscht, falls er nur aus leeren Verzeichnissen besteht. -->
		<!-- Lösungsansatz: Mache eine Funktion, mit der man einen String in ein Array zerlegen kann.
		                    Dieses Array dann in einer Schleife durchgehen -->
		<!-- ABER: Delete Target erlaubt keine anderen Scriptdefs innerhalb. 
		                 Daher 1) ein neues/eigenes  delete Targets für Verzeichnisse verwenden 
						    und 2) das Array ausserhalb dieses neuentargets aufbauen und dieses neue Target in der Schleife ausführen -->
		<!--<echo>Exploding directory path to array: ${myDir}</echo>-->
		<arrayInitJsZZZ isize="0" arrayreturn="myReturnArray"/>	<!-- Das Testarray wieder neu initialisieren -->
		<fl:let>sDelimiter::='\\'</fl:let><!-- escapter Backslash -->
		<stringExplodeJsZZZ inputstring="${myDir}" inputdelimiter="${sDelimiter}" returnarraystring="myReturnArray" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
		<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
		<arrayCopyJsZZZ arrayinput="${myReturnArray}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
	
		<!-- Trimme das Array, dadurch wird ein leeres Element, z.B. erzeugt durch einen abschliessenden Backslash entfernt -->
		<arrayStringTrimJsZZZ inputarraystring="${myArray}" inputcontrolstring="trim" returnarraystring="myReturnArray2" returnboolean="myReturnBoolean" returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
		<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl2}" returncontrolstring="${myReturnControlString}"/>
		<ac:if>
			<equals arg1="true" arg2="${myReturnBoolean}"/>
			<ac:then>			
				<!--<echo>${sScript}Array wurde getrimmt. myReturnControl2=${myReturnControl2}</echo>-->
				<arrayCopyJsZZZ arrayinput="${myReturnArray2}" arrayreturn="myArray" sflagcontrol="" />
				<!--<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>	-->						
			</ac:then>
			<ac:else>
				<!--<echo>${sScript}Nichts aus dem Array weggetrimmt. myReturnControl2=${myReturnControl2}</echo>-->
			</ac:else>			
		</ac:if>
			
	
		<!-- Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
		<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
		<arrayElementCountJsZZZ arrayinput="${myArray}" ireturn="myArray.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->			
		
		<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
		<var name="op1" value="${myArray.iSize}"/>
		<var name="op2" value="1"/>
		<var name="op" value="-"/>
		<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
		<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>
	
		<!-- Ziel: Leere Verzeichnisse auch loeschen -->
		<!-- Baue aus dem Array immer wieder neu den absoluten Verzeichnispfad, aber immer wieder um eine obere Indexposition weniger -->
		<!-- Fange aber nicht bei dem obersten Verzeichnis an, das wurde durch Ant-Funktionalität schon geloescht (includeEmptyDirs="true") -->
		<!-- Verwende dazu eine Schleife und inputindexhigh wird darin immer um 1 reduziert. -->
		<!-- <ac:for param="i" end="1" begin="1"> --><!-- nettes Attribut: beginn -->
		<!-- <ac:for param="icounter" end="${iubound}" keepgoing="true">	--><!-- keepgoing sorgt dafuer, dass die Schleife selbst nicht abgebrochen wird. Der Fehler würde anschliessend geworfen. -->
		<ac:for param="icounter" end="${iubound}" >
		<sequential>
			<!--<echo>${sScript}icounter=@{icounter}</echo>-->
						
			<var name="op1" value="${iubound}"/>
			<var name="op2" value="@{icounter}"/>
			<var name="op" value="-"/>
			<math result="iIndexTemp" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
						
			<!--Das Ausgangsverzeichnis wurde schon durch Ant-Funktionaliaet geloescht (includeEmptyDirs="true"). Darum noch ein Verzeichnis weniger -->
			<var name="op1" value="${iIndexTemp}"/>
			<var name="op2" value="1"/>
			<var name="op" value="-"/>
			<math result="iIndexTemp02" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
			<echo>${sScript}Errechnete Obergrenze des Arrays fuer diesen Lauf: ${iIndexTemp02}</echo>
			<ac:if>
			<not>
				<equals arg1="-1" arg2="${iIndexTemp02}"/>				
			</not>
			<ac:then>			
				<arrayStringImplodeJsZZZ inputarraystring="${myArray}" inputdelimiter="\\" inputindexlow="-1" inputindexhigh="${iIndexTemp02}" returnstring="myReturnStringSub" returncontrol="myReturnControlSub" returncontrolstring="myReturnControlSubString"/>			
				<echo>${sScript}arrayStringImplode=${myReturnStringSub} (Merke: Bei Leerstring Fehler in isFileRootJsZZZ)</echo>
				<echo>${sScript}zu loeschendes Verzeichnis ${myReturnStringSub}</echo>								
			</ac:then>
			<ac:else>
				<echo>${sScript}Obergrenzenmaximum erreicht.</echo>
			</ac:else>
			</ac:if>
			
						
			<!-- TODO GOON noch kaput: Im Fehlerfall die sequential - Anweisung abbrechen. -->
			<fl:let>myReturnControl::="${myReturnControlSub}"</fl:let>

			<!-- Root nicht versuchen zu löschen -->			
		<isFileRootJsZZZ inputfilepath="${myReturnStringSub}" returnboolean="myReturnValue2" returncontrol="myReturnControl2" returncontrolstring="myReturnControlString2"/>
		<!--<echo message="myReturnValue2 = ${myReturnValue2}" />-->
		<ac:if>
			<and>
				<equals arg1="true" arg2="${myReturnValue2}"/>
				<equals arg1="true" arg2="${myReturnControl2}"/>
			</and>
			<ac:then>			
				<echo>${sScript}Root erreicht. Keine weitere Verarbeitung.</echo>								
			</ac:then>
			<ac:elseif>
				<and>
				<equals arg1="false" arg2="${myReturnValue2}"/>
				<equals arg1="true" arg2="${myReturnControl2}"/>
			</and>
			<ac:then>							
				<echo>${sScript}Root noch nicht erreicht. Weitere Verarbeitung moeglich.</echo>
				
				<fl:let>myDir::="${myReturnStringSub}"</fl:let>
				<!-- Das eigentliche Löschen beim Test temporaer raus, sonst muss man sich immer wieder neu die Testdateien hinlegen -->
				<delete includeEmptyDirs="true"><!-- Lösche das Verzeichnis, wenn es leer ist (was durch includeEmptyDirs='true' gesteuert wird. -->					
					<fileset dir="${myDir}" excludes="**/*" defaultexcludes="false" /><!-- z.B. *.svn Dateien gehoeren zu den Defautlexcludes, d.h. wuerden nicht geloescht. -->									
				</delete>			
			</ac:then>
			</ac:elseif>
			<ac:else>
			    <!-- Fehlerfall -->
				<echo>${sScript}Fehler geworfen: ${myReturnControlString2}</echo>	
				<fail message="${myReturnControlString2}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->
			</ac:else>			
		</ac:if>
			
		</sequential>
		</ac:for>		

		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
	<!-- ############### -->
	<!--<echo>${sScript} gibt zurueck: ${myReturnControlString}</echo>-->
	<!-- Rueckgabebwerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
	<!--<arrayCopyJsZZZ arrayinput="${mySrcaTotal.filedir}" arrayreturn="return.srcaTotal.filedir" sflagcontrol="" />--><!-- So gibt man einen Arraywertzurueck -->	
</target>
<target name="-FGLDelLocal_DeleteFileByFile">
	<fl:let>sScript::='-FGLDelLocal_DeleteFileByFile: '</fl:let>
	<fl:echo>Start von ${sScript}</fl:echo>	
	<fl:let>sTrace::=""</fl:let>
	<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
	<ac:var name="myReturnControl" value="true" /> <!-- unset="true" /> -->
	<ac:var name="myReturnControlString" value="alles o.k." /> <!-- unset="true" /> -->
	
	<!--<echo>${sScript}Uebergebene Eingangs-Arrays:</echo>-->
	<arrayCopyJsZZZ arrayinput="${saTotal.sFiledir}" arrayreturn="mysaTotal.sFiledir" sflagcontrol="" />	
	<arrayCopyJsZZZ arrayinput="${saTotal.sFilename}" arrayreturn="mysaTotal.sFilename" sflagcontrol="" />
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.sFiledir}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays -->	
	<!--<arrayDebugJsZZZ arrayinput="${mysaTotal.sFilename}" ilevel="1"/>--><!-- Ausgabe des neuen Arrays -->	
	
	
	<!-- ErrorHandling -->
	<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
			
	<!-- Prüfen: Alle Arrays sollen gleich lang sein.-->
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.sFiledir}" ireturn="mysaTotal.sFiledir.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
	<arrayElementCountJsZZZ arrayinput="${mysaTotal.sFilename}" ireturn="mysaTotal.sFilename.iSize"/><!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->	
	<ac:if>
		<equals arg1="${mysaTotal.sFiledir.iSize}" arg2="${mysaTotal.sFilename.iSize}" />
		<ac:then>		
				<fl:echo message="${sScript}Alle Arrays haben gleich viel Elemente: ${mysaTotal.sFilename.iSize} " />				
		</ac:then>
		<ac:else>
				<fl:fail message="${sScript}Unterschiedliche Anzahl an Elementen in den Arrays: mysaTotal.sFiledir.iSize=${mysaTotal.sFiledir.iSize} | mysaTotal.sFilename.iSize=${mysaTotal.sFilename.iSize}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:else>
	</ac:if>
	
	<!-- Merke es gibt ein antcontrib Target 'Pathtofileset' dies hier vielleicht anwenden ? -->
	
	<!-- Schleife über alle Arraypositionen-->
	<!-- TODO IDEE: Ermittle den letzten wert des arrays -->

	<!-- 3. Ermittle die Indexposition, den Dateinamen und den Dateipfad -->	
	<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
	<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
	<var name="op1" value="${mysaTotal.sFilename.iSize}"/>
	<var name="op2" value="1"/>
	<var name="op" value="-"/>
	<math result="iubound" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
	<!--<echo>${sScript}Errechneter ubound Wert des Arrays: ${iubound}</echo>-->
	
	<!-- Hole die Werte der aktuellen Arrayposition, das geht nur wenn iubound > icounter, darum muss man doch tatsächlich eine Fallunterscheidung einbauen, wenn param und end gleich sind -->
	<ac:for param="icounter" end="${iubound}">			
		<sequential>
			<echo>${sScript}icounter is @{icounter}</echo> 
			<arrayGetJsZZZ arrayinput="${mysaTotal.sFiledir}" index="@{icounter}" arrayget="sFiledir" sflagcontrol="raw"/>	
			<arrayGetJsZZZ arrayinput="${mysaTotal.sFilename}" index="@{icounter}" arrayget="sFilename" sflagcontrol=""/>	
			<fl:let>mysFiledir::='${sFiledir}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<!--<echo message="${sScript}@{icounter}ter:'mysFiledir' raw='${mysFiledir}'" />-->

			<!-- Aufruf des Single-File Kopiervorgang -->			
			<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
			<!-- Lösungsansatz 20160202: den 'raw' Verzeichnisstring an die stringEscapeBackslash Funktion übergeben. -->
			<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
				<param name="stringInput" value="${mysFiledir}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
				<param name="intNumber" value="1" />					
			</antcallback>			
			<fl:let>mysFiledirEscaped::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<!--<echo>${sScript}Backslash-escapeter Verzeichniseintrag: ${mysFiledirEscaped}</echo>-->
			<fl:let>mysFilename::='${sFilename}'</fl:let>
			
			<antcallback target="-FGLDelLocal_DeleteFileSingle" return="returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->							
				<param name="sFilename" value="${mysFilename}"/>						
			</antcallback>	
						
			<!-- 20160222 TODO GOON noch kaput: Im Fehlerfall die sequential - Anweisung abbrechen. -->			
			<ac:var name="myReturnControl" value="${returnControl}"/>
			<!--<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>-->
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
			<ac:if>
				<equals arg1="${myReturnControl}" arg2="false" />
				<ac:then>		
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>						
				</ac:else>
			</ac:if>
		</sequential>
		</ac:for>		

		</ac:try>
			<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
	<!--<echo>${sScript} gibt zurueck: ${myReturnControlString}</echo>-->
	<!-- Rueckgabewerte -->
	<ac:var name="returnControl" value="${myReturnControl}" />
	<ac:var name="returnControlString" value="${sScript}${myReturnControlString}" />
</target>
		
<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-stringEscapeBackslashZZZ">
	<fl:let>sScript::='-stringEscapeBackslashZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<!-- Escape den Backslash. Dies in ein Hilfstarget packen, das propertyRegex mit einer Property statt Variablen arbeitet.
							   Properties aendern aber nicht ihren Wert innerhalb eines Targets, was unguenstig fuer Schleifen ist.		-->	
	<!-- Steuerungsflag: 'encoded' -->

<!-- Scheint ein Fehler in antcontrib zu sein. Vielleicht auch alternative Lösung durch FLAKA ....
	<project xmlns:fl="antlib:it.haefelinger.flaka">

  <property name="digitA" value="42"/>
  <property name="digitB" value="23"/>
  <property name="wordA"  value="abcd"/>
  <property name="wordB"  value="efgh"/>

  <!- compare of digits ->
  <fl:when test=" '${digitA}' > '${digitB}' ">
    <echo>${digitA} gt ${digitB}</echo>
  </fl:when>

  <!- example with string compare in switch ->
  <fl:switch value="${wordA}">
    <cmp gt="${wordB}">
      <echo>${wordA} gt ${wordB}</echo>
    </cmp>
    <cmp lt="${wordB}">
    <echo>${wordA} lt ${wordB}</echo>
    </cmp>
  </fl:switch>

</project>-->
	<fl:let>mysFlagControl::="${stringInputControl}"</fl:let>
	<fl:let>mysString::="${stringInput}"</fl:let>
	<fl:let>myiNumber::="${intNumber}"</fl:let><!-- wichtig: in Hochkommata setzen. Nur so wird der Wert gerettet, weil call by value-->
	<fl:let>returnControl::=false</fl:let>
						
	<!--<echo message="${sScript}myiNumber=${myiNumber}" />-->
	<ac:if>
		<ac:equals arg1="${myiNumber}" arg2="0" />
		<ac:then>
			<!-- mache nix -->
			<fl:let>mysString::="${stringInput}"</fl:let>			
		</ac:then>
		<ac:elseif>
			<ac:equals arg1="${myiNumber}" arg2="1" />
			<ac:then>
				<echo message="${sScript}0:'mysString'=${mysString}" />
			
				<!--ac:for erwartet immer ungleiche Parameterwerte. D.h. Schleife ueber ein Element geht nicht. Darum hier separat aufrufen. --> 
				<!-- Hier: 1-mal Das eigentliche Escapen aufrufen. Man beachte die voranstehenden doppelten Minuszeichen. -->
				<antcallback target="--stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
						<param name="stringInput" value="${mysString}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
						<param name="stringInputControl" value="${mysFlagControl}" />
				</antcallback>
				
				<!--<fl:let>mysStringNormed::='${returnString}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
				<!--<echo>${sScript}Normierter Verzeichniseintrag: ${mysStringNormed}</echo>-->
				<fl:let>mysString::='${returnString}'</fl:let>
				
			</ac:then>
		</ac:elseif>
		<ac:else>
		    <!-- Merke: AntContib islessthan funktioniert nicht als condition in ac:if (weil Bug), darum meine eigene Methode nutzen -->
			<antcallback target="-isLessThanZZZ" return="returnBoolean,returnControl,returnTrace">
				<param name="inputvalue01" value="${myiNumber}"/>					
				<param name="inputvalue02" value="0"/>	
			</antcallback>				 
			<!--<echo>${sScript}returnBoolean=${returnBoolean}</echo>-->
			<!--<echo>${sScript}returnControl=${returnControl}</echo>-->
			<!--<echo>${sScript}returnTrace=${returnTrace}</echo>-->
			<fl:let>myLessThanZero::=${returnBoolean}</fl:let>
			<ac:if>
				<ac:equals arg1="${myLessThanZero}" arg2="true" />
				<ac:then>
					<fl:fail message="${sScript}Die Anzahl der Escape - Backslash kleiner 0. Unerwarteter Parameter"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>
					<!-- 3. Reduziere die Anzahl um -1 -->	
					<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
					<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
					<var name="op1" value="${myiNumber}"/>
					<var name="op2" value="1"/>
					<var name="op" value="-"/>
					<math result="myiNumberIndexed" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
					<!--<echo>${sScript}Errechneter ubound Wert: ${myiNumberIndexed}</echo>-->
					
					
					<ac:for param="icounter" end="${myiNumberIndexed}">			
						<sequential>
							<!--<echo>${sScript}icounter ist @{icounter}</echo>-->
							<echo message="${sScript}1:'mysString'=${mysString}" />
							
							<!-- Hier: x mal Das eigentliche Escapen aufrufen. Man beachte die voranstehenden doppelten Minuszeichen. -->
							<antcallback target="--stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
									<param name="stringInput" value="${mysString}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							</antcallback>
							
							<!--<fl:let>mysStringNormed::='${returnString}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
							<!--<echo>${sScript}Normierter Verzeichniseintrag: ${mysStringNormed}</echo>-->
							<fl:let>mysString::='${returnString}'</fl:let>
							
						</sequential>
					</ac:for>		
				</ac:else>		
			</ac:if>									
		</ac:else>
	</ac:if><!-- Gleichheitszeichen -->
	
	<!-- Rueckgabewerte -->
	<ac:var name="returnString" value="${mysString}" />
	<!--<echo message="${sScript}'returnString'=${returnString}" />-->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnTrace" value="${sScript} Alles ok.|${sTrace}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
</target>

<target name="--stringEscapeBackslashZZZ">
	<fl:let>sScript::='--stringEscapeBackslashZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<!-- Escape den Backslash. Dies in ein Hilfstarget gepackt, da propertyRegex mit einer Property statt Variablen arbeitet.
							   Properties aendern aber nicht ihren Wert innerhalb eines Targets, was unguenstig fuer Schleifen ist.		-->
    <!-- Steuerungsflag: 'encoded' -->
    <fl:let>mysFlagControl::="${stringInputControl}"</fl:let>							   
	<fl:let>mysString::="${stringInput}"</fl:let>
	<fl:let>returnControl::=false</fl:let>
	<fl:let>returnString::="${stringInput}"</fl:let>	

	<!-- Ggfs. ist der String durch JavaScript encoded worden, dies macht z.B. arrayAppend vom mir automatisch.
	hier also erst einmal unencoden -->	
	<stringUnencodeJsZZZ inputstring="${mysString}" returnstring="mysStringUnencoded"  returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
	<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
	<echo message="${sScript}bcontrol | mysStringUnecoded = ${myReturnControl} | ${mysStringUnencoded}" />
	
	<!-- Das eigentliche Escapen des Backslashs -->	
	<!-- Aufruf des propertyregex Targets: Hier zum vervierfachen der Backslashe -->	
	<!-- Merke: It is important to note that when doing a "replace" operation, if the input string does not match the regular expression, then the property is not set. You can change this behavior by supplying the "defaultValue" attribute. This attribute should contain the value to set the property to in this case. -->
	            <!-- d.h. nutze 'defaultValue', sonst bleibt der Rueckgabewert leer, wenn durch die RegEx-Operation nichts gefunden wird. -->
	<propertyregex property="mytemp" input="${mysStringUnencoded}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" defaultValue="${mysString}"/><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
	<!--<echo message="${sScript}mytemp = ${mytemp}" />-->
		
	<!-- Ggfs. je nachdem wie bcontrol aussieht (s. stringUnencodeJsZZZ) den String wieder in seine Encoded Form versetzten -->
	<!-- Das ueber einen sFlagControl Parameter steuerbar machen. -->
	<if>
		<and>
			<equals arg1="${mysFlagControl}" arg2="encoded" />
			<equals arg1="${bControl}" arg2="true" />
		</and>
		<then>
			<echo message="${sScript}Encoded wiederherstellen" />
			<stringEncodeJsZZZ inputstring="${mysString}" returnstring="mysStringEncoded"  returncontrol="myReturnControl" returnControlString="myReturnControlString" sflagcontrol="" />
			<catchReturnControlZZZ script="${sScript}" returnControl="${myReturnControl}" returncontrolstring="${myReturnControlString}"/>
			<fl:let>mysString::="${mysStringEncoded}"</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben-->
		</then>
		<else>
			<echo message="${sScript}Unencoded lassen" />
			
			<!-- wegen der vielen Zwischenschritte reicht auch das vervierfachen nicht.-->
	<!-- Aufruf des propertyregex Targets: Hier zum erneuten vervierfachen der Backslashe -->	
	<!-- Merke: It is important to note that when doing a "replace" operation, if the input string does not match the regular expression, then the property is not set. You can change this behavior by supplying the "defaultValue" attribute. This attribute should contain the value to set the property to in this case. 
	            d.h. nutze 'defaultValue', sonst bleibt der Rueckgabewert leer, wenn durch die RegEx-Operation nichts gefunden wird. -->
	<!--<propertyregex property="mytemp02" input="${mytemp}" regexp="\\" replace="\\\\\\\" global="true" />--><!-- das waere wieder verdoppeln -->
	<propertyregex property="mytemp02" input="${mytemp}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" defaultValue="${mytemp}"/><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
	<!--<echo message="${sScript}mytemp02 = ${mytemp02}" />-->
	<fl:let>mysString::='${mytemp02}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<!--<echo message="${sScript}'mysString'=${mysString}" />-->
	
			
			<!-- mache nix hinsichtlich codierung -->
		</else>
	</if>
		
	<!-- Rueckgabewerte -->
	<ac:var name="returnString" value="${mysString}" />
	<!--<echo message="${sScript}'returnString'=${returnString}" />-->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnTrace" value="${sScript}Alles ok.|${sTrace}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywert zurueck -->			
</target>
	


</project>