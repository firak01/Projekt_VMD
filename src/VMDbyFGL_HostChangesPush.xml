<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
   xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	   <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	
	
	
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung ###-->
	<scriptdef name="substring" language="javascript">
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		 ]]>
	</scriptdef>
		
	<scriptdef name="isdirectory" language="javascript">
		 <attribute name="text" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");		 
		   var fd = new java.io.File(text);
		   var berg = false;
		   if (fd.isDirectory()) {
			   print("js true");
		       berg = true;
			} else {
				print("js false");
				berg = false;
			}
			project.setProperty(attributes.get("property"), berg);
		 ]]>
	</scriptdef>
	
	<scriptdef name="list_element_countzzz" language="javascript">
		 <attribute name="lista" />
		 <attribute name="iresult" />
		 <![CDATA[
		   var lista = attributes.get("lista");		 
		   var iReturn = 2;
		   print("typeof lista = " + typeof(lista));
		   
		   project.log("Hello FGL from script");
		   project.log("Attribute lista = " + attributes.get("lista"));
		   //project.log("First fileset basedir = "+ elements.get("fileset").get(0).getDir(project));
		   
		   project.setProperty(attributes.get("iresult"), iReturn);
		 ]]>
	</scriptdef>
	
   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafür sorgen dass die Deklaration vor allen anderen Targets ausgeführt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
  	
	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
  	
  
    <!-- Ausgangsverzeichnis: Das Repository -->
  	<!-- a) Feste Unterverzeichnisstruktur -->
 <property name="dest.dirRepositoryVmdLib" value="lib" />
  <property name="dest.dirRepositoryVmdBat" value="bat" />
  <property name="dest.dirRepositoryVmdSrc" value="src" />
  <property name="dest.dirRepositoryVmdMisc" value="misc" />
  <property name="dest.dirRepositoryVmdTest" value="test" />
  <property name="dest.dirRepositoryVmdArchive" value="vmd" />
  
  <!-- b) Als Umgebungsvarialbe (Batch) oder Argument (Eclipse) übergebene Konfigurationsdatei --> 
  <!-- TODO GOON: Fallunterscheidung, je nachdem was existiert -->
  <loadproperties>
  	<file file="${vmd}"/>
  	<!--<file file="${env.VMD}"/>-->
  </loadproperties> 
  <echo>test1 hat den Wert: ${test1}</echo>  	 
  <echo>conf.dirRepositoryVmdPath hat den Wert: ${conf.dirRepositoryVmdPath}</echo>
  <property name="dest.dirRepositoryVmdPath" value="c:/1fgl/repository/Projekt_VMD" />  
 
  <!-- TODO GOON: Prüfe die Controldateien auf Existenz und Validität. Setze bGOON Variablen, die dann in den Targets abgeprüft werden. -->
  	
  	
  <!-- ######### CLIENT ############################################################################## -->
  <!-- mit absoluten Pfaden hat das kopieren so nicht geklappt, erst wenn wie unten // vor der property steht, funktioniert es -->
  <!-- Achtung: verwende auch auf deutschen Systemen C:\Program Files (x86), Abaenderung in deutschen Namen Programme... bewirkt nur, das scheinbar das Verzeichnis doppelt angelegt wird. -->
  <!-- alle .txt Dateien, die ein juengeres Aenderungsdatum haben. --> 
  <property name="src.dirFglClient" value="client" /> 
  <property name="src.dirFglPath" value="C:/1fgl"/>
  <property name="src.dirFglClientPath" value="${src.dirFglPath}/${src.dirFglClient}" /> 

  <!-- Rechne den Namen der Datei aus... Das ist wichtig, alle anderen Dateien des Verzeichnisses kommen in misc-->
  	 <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}" />
    <property name="src.dirFglClientFileName" value = "Fgl${env.COMPUTERNAME}_Installationen.txt"/><!-- Merke: Aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>src.dirFglClientFilePath ::= '${src.dirFglClientFilePath}/${src.dirFglClientFileName}'</fl:let>
	<echo>Wert von src.dirFglClientFilePath=${src.dirFglClientFilePath}</echo>
	</target>
  
  <!-- ################################################################################# -->
   <target name="compile" depends="declaration, init,FglRepositoryBackup,FglCopyClient2archive,FglCopyLocal">
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  
  <target name="init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
       
<target name="FglRepositoryBackup">
	<!-- Die erstellten Backup - zip Dateien sollten ausserhalb des Git Repositories sein -->
	<property name ="dest.dirRepositoryVmdBackupPath" value="${dest.dirRepositoryVmdPath}Backups" />
  
	<echo>Creating Backup:</echo>
	
	<!-- Example of howto change file modification date, usefull to enforce 'overwrite' -->
	<!-- <touch>
	  <fileset dir="${dest.dir}"/>
	</touch>
	-->

	<!-- Erstelle sicherheitshalber die Pfade -->
	<mkdir dir="//${dest.dirRepositoryVmdPath}"/>
	<mkdir dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" />
	<mkdir dir="//${dest.dirRepositoryVmdBackupPath}"/>

	<echo>a) VmdRepository Archive:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryArchive.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}"
	/>
	
	<!-- damit die Aenderung: Datei wurde geloescht mitbekommen wird, alle Dateien (nur die Programmdateien!!!) nach dem Backup loeschen -->
	<!-- NEIN, nicht im VMD_Projekt, da hier die Dateien von verschiedenen Rechnern in einem Verzeichnis zusammengeführt werden.
    	<delete includeemptydirs="false">
		<fileset dir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" includes="**/*.txt"/>
	</delete> -->
	
	<!-- TODO: Der Rückweg : Aus dem vmd und aus dem misc Verzeichnis die Dateien nach c:\1fgl\client kopieren, sofern diese neuer sind. -->
	<echo>b) VmdRepository Misc:</echo>
	<!-- Mache von den Zielverzeichnissen ein Backup -->
	  <zip destfile="//${dest.dirRepositoryVmdBackupPath}/${backup_RepositoryMisc.name}"
       basedir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}"
	/>
</target>
	
	
<target name="FglCopyClient2archive">
	<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
	<echo>Pushing Files to Repository:</echo>
	<echo>a) VMD File:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
	     <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
		 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
		
		<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
		<include name="${src.dirFglClientFileName}" />		
	  </fileset>
	</copy>
	
	<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
	<echo>b) Misc Files:</echo>
	<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
	<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
	  <fileset dir="//${src.dirFglClientPath}">	
		 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
		<include name="**.txt"/>
	  </fileset>
	</copy>
</target>

<!-- ######################################################### -->
<!-- Beispiel für ein antcallback, in dem aus einer Schleife ein Wert zurückgeliefert wird. -->
<!-- HOST - SPEZIFISCHE AUFGABEN -->
<target name="FglCopyLocal">
	<echo>######################################</echo>
	
	<!-- Schiebe die angegebenen Dateien von a nach b auf dem lokalen Rechner -->
	<!-- Gesteuert wird das über eine Datei, die für jeden HOST-Rechner individuell ist. 
	       Unterschied zu FGLCopyRepository ist, das hier der Dateiname geändert werden MUSS, d.h. in der Steuerdatei MUSS hinter dem Gleichheitszeichen ein Dateipfad stehen.-->
	
	<!-- 1. Rechne den Dateinamen aus -->
	<!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaka´s install-property handler task -->
	<fl:install-property-handler />
	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
	
	 <!-- Todo: Eigentlich müssen oben erst die conf - Parameter definiert werden und daraus werden dann die dest/src Parameter ggfs. geholt -->
	<property name="conf.dirRepositoryVmdPath" value="${dest.dirRepositoryVmdPath}" /> 
	<property name="conf.dirRepositoryVmdBat" value="${dest.dirRepositoryVmdBat}" />
	
	<property name="src.dirFglClientFilePath" value="${src.dirFglClientPath}/" />

	<!-- Merke: COMPUTERNAME kommt aus der Liste der Windows Umgebungsvariablen: DOS Box. SET - Befehl und ENTER --> 	  
    <property name="conf.copyLocalFileName" value = "Fgl${env.COMPUTERNAME}_copy_local.properties"/>
	
	<!-- normalerweise kann in ANT keine  Property verändert werden. Benutze dazu Flaka LET -->
    <!--das würde also nicht verändert, wenn src.dirFglClientFile vorher schon definiert ist <property name="src.dirFglClientFile" value="${src.dirFglPath}/${src.dirFglClient}" />  -->
	<fl:let>conf.copyLocalFilePath ::= '${conf.dirRepositoryVmdPath}/${conf.dirRepositoryVmdBat}/${conf.copyLocalFileName}'</fl:let><!-- beachte hier die doppelten Doppelpunkte, um den bereits gesetzten Wert zu ersetzten -->		
	<echo>Copy files general, by property file:</echo>
	<echo>${conf.copyLocalFilePath}</echo>
	
	<!-- 2a. Prüfe, ob die Steuerungsdatei überhaupt existiert -->
	<fl:choose>
		<when test=" '${conf.copyLocalFilePath}'.tofile.exists == true ">
			<echo>Datei existiert: ${conf.copyLocalFilePath}</echo>

			<!-- 2. Lies den Inhalt der Datei als Properties-Datei ein. -->	
			<!--<loadproperties>
				<file file="${conf.copyGeneralFilePath}"/>
			</loadproperties> 
			<echo>test1 hat den Wert: ${test1}</echo> -->
			
			
			<!-- 2a. Lies den Inhalt der Datei generell ein. Aber: innerhalb des when test auf Dateipfad funktioniert das nicht, da darin der Pfad an den anderen Pfad angehängt wird.-->				
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFilePath}" /> -->
			<!-- <loadfile property="myfile" srcFile ="${conf.copyGeneralFileName}" /> --><!-- hierbei wird relative vom Script-Verzeichnis (also im VMD_Projekt 'src' ausgegangen -->
			
			<!-- Test: Gib den Inhalt der Datei aus -->
			<!-- <echo>Dateiinhalt als Ganzes:</echo> -->
			<!-- <echo>${myfile}</echo> -->
	
	
			<!--2b. Werte den Inhalt der Datei zeilenweise aus -->			
			<echo>Dateiinhalt Zeile fuer Zeile:</echo>		
			<for param="line"><!-- Merke: for, var und if kommen aus der ant-contrib Bibliothek -->
				<tokens><!-- muss in der for-Schleife stehen, damit es dort eine list, path, sequence gibt, durch die iteriert werden kann. Wahrscheinlich wg. Sichtbarkeit-->
					<file file="${conf.copyLocalFilePath}" />
				</tokens>
				<sequential>
					<var name="line.length" unset="true" />
					<length string="@{line}" property="line.length" />
					<if>
						<equals arg1="${line.length}" arg2="0" />
						<then>
							<echo>Zeile: 
							</echo>
						</then>
						<else>						
							<echo>Zeile: @{line}</echo>
							<!-- Kommentarzeilen überspringen. Sie beginnen mit einem #  -->							
							<substring text="@{line}" start="0" end="1" property="subtext" /><!-- anwenden der oben definierten scriptdef funktion substring -->
							<!-- <echo message="subtext = ${subtext}" />	 -->						
							<if>
								<equals arg1="${subtext}" arg2="#" />
								<then>
									<echo>Kommentarzeile, wird uebersprungen...</echo>
								</then>
								<else>
									<echo>Steuerungszeile, wird ausgewertet...</echo>
									
									<!-- 2c. Splitte die Zeile mit Flaka - Splitt funktion (steht in der Flaka Doku unter EL). -->							 				 							
									<!-- <fl:echo>linker Teil der Zeile => #{split('@{line}','=')[0]}</fl:echo> --><!-- beachte, dass mit dem #{ ... } die Funktion aufgerufen wird, so dass ihr Ergebnis in den String eingefügt werden kann.-->
									<!-- <fl:echo>rechter Teil der Zeile => #{split('@{line}','=')[1]}</fl:echo> -->
	
									<!-- Schreibe das in eine Flaka - Variable -->		
									<fl:let>myLeftPart ::= split('@{line}','=')[0]</fl:let>		
									<fl:let>myRightPart ::= split('@{line}','=')[1]</fl:let><!-- beachte hier die einfachen Doppelpunkte bei der unveränderbaren Variablenzuweisung. Erst durch den doppelten Doppelpunkt wird die Variable veränderbar Zuweisung oben UND es gibt kein #{ ... }-->							 
									<!-- <fl:echo>linke Variable => ${myLeftPart}</fl:echo> -->
									<!-- <fl:echo>rechte Variable => ${myRightPart}</fl:echo> -->
														 							
									<fl:when test="null('${myRightPart}')">
										<!-- TODO: Idee: in der initialisierungsphase alle Steuerungsdateien auf Validität prüfen -->
										<!-- FEHLER, Datei nicht definiert -->
										<echo>Rechter Teil der Steuerungsanweisung existiert nicht (nach...): @{line}</echo>
										<!-- <fl:fail message="Rechter Teil der Steuereungsanweisung existiert nicht: @{line}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
																								
									<!-- Merke: Das wäre beim Kopieren einer Datei an einen feststehenden Ort der Ansatz, man muss nur den Dateinamen aus dem Verzeichnissnamen extrahieren. Das ist also beim Kopieren in das Repository Verzeichnis ggfs. einzusetzen.-->
		<!-- 								<fl:echo>rechte Variable ist NULL, nimm den linken Teil.</fl:echo>
										<fl:let> myRightPart ::= '${myLeftPart}'</fl:let>
										<fl:echo>rechte Variable wird aus linkem Wert übernommen: ${myRightPart}</fl:echo> -->
									</fl:when>

									<!-- Prüfe, ob Datei vom Linken Teil existiert -->
									<fl:choose>
										<when test=" '${myLeftPart}'.tofile.exists == true ">
											<echo>Datei existiert (von...): ${myLeftPart}</echo>
											<!-- Prüfe, ob es ein Verzeichnis ist -->
											<isdirectory text="${myLeftPart}" property="myisdirectory" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
											<echo>linker Teil: isdirectory=${myisdirectory}</echo>
											<!-- A) TODO: Wenn der linke Teil ein Verzeichnis ist, alle Dateien darin kopieren, sofern der rechte Teil auch ein Verzeichnis ist. -->
											
											<!-- B) Dateipfad-Fall: Ermittle den Ausgangsdateipfad und den -namen -->
											<fl:let>src.filedir ::= split('${myLeftPart}','\\')[0]</fl:let>
											<fl:let>src.filename ::= split('${myLeftPart}','\\')[1]</fl:let>
											
											<!-- TODO: Prüfe, ob der rechte Teil ein Verzeichnis ist... -->
											<!-- Falls JA: Hole vom linken Teil den Dateinamen und hänge ihn an das Verzeichnis an -->
											<!-- Falls NEIN: Nimm das Verzeichnis, wie es ist. -->																												
											<isdirectory text="${myRightPart}" property="myisdirectory" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
											<echo>recher Teil: isdirectory=${myisdirectory}</echo>																								
											<fl:choose>
												<when test=" '${myisdirectory}' == true ">
													<echo>Rechter Teil (nach...) ${myRightPart} ist ein Verzeichnis </echo>
													<fl:let>dest.filedir ::= ${myRightPart}</fl:let>
													<fl:let>dest.filename ::= ${src.filename}</fl:let>
												</when>
												<otherwise>
													<echo>Rechter Teil (nach...) ${myRightPart} ist KEIN Verzeichnis </echo>
													<fl:let>dest.filedir ::= split('${myRightPart}','\\')[0]</fl:let>
													<fl:let>dest.filename ::= split('${myRightPart}','\\')[1]</fl:let>
												</otherwise>
											</fl:choose>
											
											<echo>src.filedir = #{split('aabcc','b')[0]}</echo>
											<!-- <fl:echo>src.filedir = #{split('aaabccc','b')[0]}</fl:echo> -->
											<echo>src.filedir = #{split('${myLeftPart}','\\\\')[0]}</echo><!-- 4 Backslashe um den Backslash zu escapen in der split - Funktion -->
											<fl:let>src.fileadir ::= split('${myLeftPart}','\\\\')</fl:let>											
											<!-- <echo>groesse src.fileadir = #{size('${src.fileadir}')}</echo> --><!-- ermittle die groesse der liste -->
											<!-- <echo>groesse src.fileadir = #{size(${src.fileadir})}</echo> -->
											<echo>groesse einer Liste mit size(...) = #{size(list(1,2))}</echo>
											<echo>src.fileadir = #{'${src.fileadir}'}</echo>
											<echo>src.fileadir[2] = #{'${src.fileadir}'}[2]</echo><!-- TODO GOON -->
											<echo>src.fileadir[2] = #{'${src.fileadir}'[2]}</echo><!-- TODO GOON -->
											<echo>src.fileadir[2] = #{'${src.fileadir}[2]'}</echo><!-- TODO GOON -->
											<echo>src.fileadir[2] = #{'${src.fileadir[2]}'}</echo><!-- TODO GOON -->
											
											
											<echo>groesse src.fileadir = #{size(src.fileadir)}</echo><!-- Ergebnis 0 -->
											<echo>groesse src.fileadir = #{size(${src.fileadir})}</echo>											
											<echo>groesse src.fileadir = #{size('${src.fileadir}')}</echo><!-- Ergebnis 69 -->
											<echo>groesse src.fileadir = #{size(list('${src.fileadir}')}</echo>
											<echo>groesse src.fileadir = #{size(list(${src.fileadir})}</echo>
											
											<echo>groesse src.fileadir = #{${src.fileadir}.length</echo>
											<echo>groesse src.fileadir = #{${src.fileadir}.length</echo>
											<echo>src.fileadir = #{'${src.fileadir}'.size}</echo><!-- Ergebnis 69 -->
											<echo>src.fileadir = #{size(src.fileadir)}</echo>
											<echo>src.fileadir = #{size(split('${myLeftPart}','\\\\'))}</echo>
											<!-- FAZIT: Die ermittlung der Listengröße einer Variablne funktioniert nicht -->
											<fl:let>tempa ::= list(1,2)</fl:let>	
											<echo>groesse tempa  = #{size(tempa)}</echo>
											
											
											
											<!-- <fl:for var="mydir" in="list(${src.fileadir})"> -->
											<!-- <fl:for var="mydir" in="list(1,2)"> -->
											<fl:for var="mydir" in="split('${myLeftPart}','\\\\')">
											<echo>#{mydir}</echo><!-- Aufruf der Variablen als EL Expression -->
											</fl:for>
											
											
											<list_element_countzzz lista="${tempa}" iresult="mylistasize"></list_element_countzzz>
											<echo>Ergebnis des scriptdef Aufrufs: ${mylistasize}</echo><!-- Aufruf der Variablen als EL Expression -->
											<!--
											<c:let>
    a = list('a','b','c')
</c:let>

How can i modify each elements for that list?

I need something like:

for (int i = 0; i < a.length; i++) {
    a[i] += 'd';
}

I looked in the tutorial, but the examples show only how to retrieve a list element, not how to modify it.

So, how can i modify list elements, iterating on it?
											
											ANTWORT: Es gibt noch keine Lösung, ausser:
										

There is (currently) no function which lets you manipulate lists. All you could do is

<let>
  a = list('a', 'b', .. )    ; your list
  b = list()                 ; empty list 
</let>
<for var=" item " in=" a ">
 <let>
   x = some-el-expression( item ) ;     
   b = append(b, x)
 </let>
</for>
<let>
 a = b
</let>

											-->
											<fl:let>src.filedir ::= split('${myLeftPart}','X')[0]</fl:let>
											<fl:let>src.filename ::= split(${myLeftPart},'V')[1]</fl:let>
											<fl:let>dest.filedir ::= '${myRightPart}'</fl:let>
											<fl:let>dest.filename ::= '${src.filename}'</fl:let>
											<!-- <fl:let>dest.filedir ::= 'aaa'</fl:let>
											<fl:let>dest.filename ::= 'bbb'</fl:let>	
											<fl:let>src.filedir ::= 'ccc'</fl:let>
											<fl:let>src.filename ::= 'ddd'</fl:let> -->
											
											<!-- 4. Der eigentliche Kopiervorgang -->
											<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->
											<!-- Schiebe die spezielle VMD Datei des Host-Rechners in das Repository -->
											<echo>Pushing File ${src.filedir}\${src.filename} to Repository: ${dest.filedir}\${dest.filename} </echo>
											
											<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
											<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdArchive}" overwrite="false"  preservelastmodified="true"> 
											  <fileset dir="//${src.dirFglClientPath}">	
												 <!-- ein bestimmtest Verzeichnis ausschliessen wird wohl funktionieren --> <!-- <exclude name="**/A-dir/**/B-dir/**"/> -->
												 <!-- so werden aber auch die txt-Dateien aus dem Ausgangsverzeichnis nicht kopiert exclude name="**/**/**.txt" />--><!-- Ziel: Keine txt-Dateien aus Unterverzeichnissen oder Unterverzeichnisse selbst holen -->
												
												<!--Hier den errechneten Namen der VMD Datei verwenden und nicht alle Dateien mit der txt Endung --><!-- <include name="**/**.txt"/>-->	
												<include name="${src.dirFglClientFileName}" />		
											  </fileset>
											</copy>
											
											<!-- Alle anderen txt Dateien aus dem client-Ordner in den misc-Ordner verschieben, ausser der VMD Datei. Nix aus Unterordnern verschieben. -->
											<echo>b) Misc Files:</echo>
											<!-- Dateien, die neuer sind, werden nicht ueberschrieben. -->	  
											<copy todir="//${dest.dirRepositoryVmdPath}/${dest.dirRepositoryVmdMisc}" overwrite="false"  preservelastmodified="true"> 
											  <fileset dir="//${src.dirFglClientPath}">	
												 <exclude name="${src.dirFglClientFileName}" /><!-- wichtig: Das exclude muss VOR dem include stehen -->		
												<include name="**.txt"/>
											  </fileset>
											</copy>
										</when>
										<otherwise>
												<echo>Datei existiert NICHT (von...): ${myLeftPart}</echo><!-- hier auch kein fail, sondern nur diese Warnung -->												
										</otherwise>
									</fl:choose>			
								</else>
							</if>											
						</else>
					</if>
				</sequential>
			</for>			
		</when>
		<otherwise>
				<echo>Datei existiert NICHT: ${conf.copyLocalFilePath}</echo>
				<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird. Steuerungsdateien dürfen aber auch "nicht existieren". -->
		</otherwise>
	</fl:choose>

</target>



</project>