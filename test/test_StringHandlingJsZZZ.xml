<?xml version="1.0" encoding="UTF-8" ?>  
<project name="test_StringHandlingJsZZZ"  default="compile" basedir="..">

<!-- ######## Scriptdefs ############################################################################--> 


<!-- ########################### -->
<!-- ########################### -->
	<scriptdef name="arrayDebugJsZZZ" language="javascript">
		<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
			   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
			   - der Inhalt
			   - die Größe des Arrays			-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="arrayinput" />
		<attribute name="ilevel" />	
		<![CDATA[	
			enableJava();
			var myArray = attributes.get("arrayinput");					
			var myLevel = attributes.get("ilevel");					
			if(myLevel<=0){
				
			}else{
			if(myArray===undefined) print("myarray = undefined");
			if(myArray==null) print("myarray = NULL");	
			
			//Typausgabe
			print("typeof myarray = " + typeof(myArray));
					
			
			var iSize=0;
			if(Array.isArray(myArray)){
				print("Array uebergeben bekommen");
				iSize = myArray.length;
				print("Arraygroesse="+iSize);
				
				//TODO: Die gleichen Ausgaben wie im KEIN ARRAY Fall.
				//- Werte
			}else{
				print("kein Array uebergeben bekommen.");
				
				var icount=0;					
				if(typeof(myArray)=="object"){
					print("Object uebergeben bekommen.");
					
					if(myLevel>=2){
					//das listet alle Methoden des objekts auf.... scheint ein String zu sein....
					//print("ALLE METHODEN DES OBJEKTS:");
					//for(x in myArray){
					//	print(x);		
					//};	
					
					print("#################################");
					print("ALLE METHODEN UND CODEINHALT DES OBJEKTS:");
					for(xx in myArray){
						print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
						print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
					};
					};//myLevel>=2;
					
					debugArrayAsString(myArray);
				}else{
					print("kein Objekt");
					debugArrayAsString(myArray);					
				};
			};
			};//myLevel <= 0;
			
			
			function debugArrayAsString(myArray){
					print("#################################");
					print("myArray ist jetzt leider ein String ='"+ myArray +"'");
					//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
					
					print("splitte diesen String nach Komma.");
					var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
					for(x in objectArray){
						print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					};
					
					//var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
					//for(x2 in objectArray02){
					//	print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
					//};
					
					//var objectArrayString = myArray.toString();
					//var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
					//for(z in objectArray03){
					//	print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					//};
					
					print("#################################");
					print("Versuch die Werte auszugeben: ");	
					//Merke: Voraussetzung ist:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 for(yy in objectArray){
							print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
						};
			}
			
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
			
		]]>
	</scriptdef>


<!-- TODO: Diese Funktion in den JSZ-Kernel uebernehmen -->
 <scriptdef name="stringContainsStringZZZ" language="javascript">
 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnboolean" />     
     <![CDATA[
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
       
       var bReturn = text.indexOf(match)> -1;
	   
       project.setProperty(attributes.get("returnboolean"), bReturn);
     ]]>
  </scriptdef>
  
  <!-- ########################### -->
<!-- TODO: Diese Funktion in den JSZ-Kernel uebernehmen -->
 <scriptdef name="stringCountStringZZZ" language="javascript">
 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returninteger" />     
     <![CDATA[
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
       	   
	   //Merke: So bindet man per Prototype erzeugte, die Klassen erweiternde Methoden in dieses CDATA-Konstrukt ein.   
	   String.prototype.count = function(lit, cis) {
	    //lit is the string to search for ( such as 'ex' ), and 
	    //cis is case-insensitivity, defaulted to false, it will allow for choice of case insensitive matches.
		var m = this.toString().match(new RegExp(lit, ((cis) ? "gi" : "g")));
		return (m != null) ? m.length : 0;
	  }
	  
       var iReturn = text.count(match, false);	   
	   
       project.setProperty(attributes.get("returninteger"), iReturn);
	   	   
	  
     ]]>
  </scriptdef>

   <!-- ########################### -->
<scriptdef name="stringEncodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
    <attribute name="returnstring" /> 
	<attribute name="returncontrol" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
		print("Starte stringEncodeJsZZZ");
			  	
       var myString = attributes.get("inputstring");
       print("myString="+myString);
	   
	   var myReturnControl=false;

	   var textEncoded = encodeMyHtml(myString);
	   print("encoded textstring=" + textEncoded);
	  
	   //Feedback, ob etwas geändert worden ist.	  
	   if(textEncoded!=myString){			
			myReturnControl = true;
		};
	   	   	 
       project.setProperty(attributes.get("returnstring"), textEncoded);
	   project.setProperty(attributes.get("returncontrol"), myReturnControl);
	   
	   
	   //TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
  </scriptdef>	
  
  
  <scriptdef name="stringExplodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
	<attribute name="inputdelimiter"/>

    <attribute name="returnarraystring" /> 
	<attribute name="returncontrol" /> 
	
    <![CDATA[
		var myString = attributes.get("inputstring");
		var myDelimiter = attributes.get("inputdelimiter") 
		var myArrayReturn = new Array();
		var bReturnControl = true;
		if(myString===undefined){
			print("myString = undefined");
			bReturnControl = false;
		}else if(myString===''){
			print("myString = leer");			
			bReturnControl = false;
		}else{
			if(myDelimiter===undefined){
				print("myDelimiter = 'undefined'");
				myArrayReturn[0]=myString;
				bReturnControl = false;
			}else if(myDelimiter===''){
				print("myDelimiter = 'leer'");
				myArrayReturn[0]=myString;
				bReturnControl = false;
			}else{	
				 values = myString.split(myDelimiter);
				 for(i=0; i<values.length; i++) {
					//So wird ein Array künstlich erzeugt.... project.setNewProperty(attributes.get("inputprefix")+i, values[i]);
					myArrayReturn[i]=values[i];
				 }				 		
			}
		}				 
		project.setProperty(attributes.get("returnarraystring"), myArrayReturn);
		project.setProperty(attributes.get("returncontrol"), bReturnControl);
     ]]>
	</scriptdef>
  
 <!-- ########################### -->
  <scriptdef name="stringLeftStringZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
	   //print("Starte stringLeftStringZZZ");
	   
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
       //print("matchstring="+match);
	  
	   //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
	   var matchToEncode=match;
	   var matchEncoded = encodeMyHtml(matchToEncode);
	   //print("encoded matchstring=" + matchEncoded);
	   
	   var textToEncode=text;
	   var textEncoded = encodeMyHtml(textToEncode);
	   //print("encoded textstring=" + textEncoded);
       sReturn = getStrLeftStr(textEncoded, matchEncoded);
	   sReturn = unescape(sReturn);
	   //print("sReturn="+sReturn);
	   
       project.setProperty(attributes.get("returnstring"), sReturn);
	   
	   //aus JSZ - Kernel 
	   function getStrLeftStr(sourceStr, keyStr){
		return (sourceStr.indexOf(keyStr) == -1 | keyStr=='') ? '' : sourceStr.split(keyStr)[0];
	  }
		
		//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
  </scriptdef>
  
  <!-- ########################### -->
 <scriptdef name="stringRightStringZZZ" language="javascript">
	 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="text" />
		<attribute name="matchstring" />
		<attribute name="returnstring" />     
		 <![CDATA[
		   var text = attributes.get("text");
		   //print("entgegengenommenes Attribut text="+text);
		   var match = attributes.get("matchstring");
		   //print("entgegengenommenes Attribut matchstring="+match);
		   
		    //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
			var matchToEncode=match;
			var matchEncoded =encodeMyHtml(matchToEncode);
			//print("encoded matchstring=" + matchEncoded);
		   		    
			var textToEncode=text;
			var textEncoded=encodeMyHtml(textToEncode);
			//print("encoded textstring=" + textEncoded);
		   
		   sReturn = getStrRightStr(textEncoded, matchEncoded);
		   //print("sReturn="+sReturn);
		   sReturn = unescape(sReturn);
		   //print("sReturn unescaped="+sReturn);
	   
		   project.setProperty(attributes.get("returnstring"), sReturn);
		   
		   //aus JSZ - Kernel 
		   function getStrRightStr(sourceStr, keyStr){
				idx = sourceStr.indexOf(keyStr);
				return (idx == -1 | keyStr=='') ? '' : sourceStr.substr(idx+keyStr.length);
			}
				
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
		 ]]>
	  </scriptdef>
  
  <!-- ########################### -->
	<scriptdef name="stringLeftBackStringZZZ" language="javascript">
   <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
   <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	  var text = attributes.get("text");
	  var match = attributes.get("matchstring");
      //print("matchstring="+match); 
	  
	   //! FEHLER, Z.B. BEI EINEM BEGINNENDEN BACKSLASH, darum encoden.
	   var matchToEncode=match;
	   var matchEncoded = encodeMyHtml(matchToEncode);
	   //print("encoded matchstring=" + matchEncoded);
	   
	   var textToEncode=text;
	   var textEncoded = encodeMyHtml(textToEncode);
	   //print("encoded textstring=" + textEncoded);
	  
      sReturn = getStrLeftBackStr(textEncoded, matchEncoded);
	  //print("return vor unescape: getStrLeftBackStr=" + sReturn);
	  sReturn = unescape(sReturn);
      project.setProperty(attributes.get("returnstring"), sReturn);
	   
	//äquivalent zu JSZ - Kernel
	//@LeftBack equivalent, !!! casesensitive
	function getStrLeftBackStr(sourceStr, keyStr){
		arr = sourceStr.split(keyStr);
		arr.pop();		//entfernt das letzte Element aus dem Array
		//arr.shift();		//entfernt das erste Element aus dem Array
		//!! so unterschlaegt man aber keyStr: return (keyStr==null | keyStr=='') ? '' : arr.join();		
		
		var sReturn="";
		if(arr.length>=2){
		for (index = 0; index < arr.length-1; ++index) {
			sReturn=sReturn+arr[index]+keyStr;
		}
		}
		sReturn=sReturn+arr[arr.length-1];
		return sReturn;
		
	}
	
	//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
  ]]>
  </scriptdef>
  

 <!-- ########################### -->
<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
  <scriptdef name="stringSubStringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   if(text==''){
		   //print("Leerstring im JS Teil stringSubStringZZZ");
		   project.setProperty(attributes.get("property"), '');
		   }else{
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		   }
		 ]]>
	</scriptdef>
	
 <!-- ########################### -->
	<scriptdef name="stringUnencodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
    <attribute name="returnstring" />
    <attribute name="returncontrol" />	
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
	 //TODO: Die Erweiterung endsWithPos in den JSZ - Kernel packen
	 print("Starte stringUnencodeJsZZZ");
	  
	 var myString = attributes.get("inputstring");
     //print("myString="+myString); 
	 var myReturnControl=false;
			  	  
	 var myStringUnencoded=unescape(myString);	  
	 //print("myStringUnencoded =" + myStringUnencoded);
	   
	 //Feedback, ob etwas geändert worden ist.	  
	 if(myStringUnencoded!=myString){			
		myReturnControl = true;
	 };
	   project.setProperty(attributes.get("returncontrol"), myReturnControl);	   	   	 			
       project.setProperty(attributes.get("returnstring"), myStringUnencoded);
     ]]>
  </scriptdef>	
  
<!-- ################################################################################# -->
	<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!-- <target name="compile" depends="-myTestStringExplode,-myTestStringSubstring,-myTestStringLeftString,-myTestStringRightString,-myTestStringLeftBackString,-myTestStringContainsString,-myTestStringCountString"> -->
 <!-- TODO Test für stringUnencodeJsZZZ und stringEncodeJsZZZ -->
 <target name="compile" depends="-myTestStringExplode">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-myTestStringContainsString">
		<echo>myTestStringContainsString: </echo>
		<property name="totaltext01" value="asdfasdfasdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich -->	
		<echo message="totaltext = ${totaltext01}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringContainsStringZZZ text="${totaltext01}" matchstring="sdf" returnboolean="bcontains" />
		<echo message="bcontains = ${bcontains}" />
		<echo message="############################" />
		
		<property name="totaltext02" value="11111111111" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich -->	
		<echo message="totaltext = ${totaltext02}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringContainsStringZZZ text="${totaltext02}" matchstring="sdf" returnboolean="bcontains" />		
		<echo message="bcontains = ${bcontains}" />
		
	</target> 
	
	
	<target name="-myTestStringCountString">
		<echo>myTestStringCountString: </echo>
		<property name="totaltext01" value="asdfasdfasdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich -->	
		<echo message="totaltext = ${totaltext01}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringCountStringZZZ text="${totaltext01}" matchstring="sdf" returninteger="icontains" />
		<echo message="icontains = ${icontains}" />
		<echo message="############################" />
		
		<property name="totaltext02" value="11111111111" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich -->	
		<echo message="totaltext = ${totaltext02}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringCountStringZZZ text="${totaltext02}" matchstring="sdf" returninteger="icontains" />		
		<echo message="icontains = ${icontains}" />
		
	</target> 

	<target name="-myTestStringExplode">
		<property name="sValue" value="a,b,c"/>
		<echoproperties prefix="sValue"/>
		
		<property name="sDelimiter" value=","/>
		<stringExplodeJsZZZ inputstring="${sValue}" inputdelimiter="${sDelimiter}" returnarraystring="myArray" returncontrol="myReturnControl"/>
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
		
	</target>
	
	<target name="-myTestStringSubstring">
		<echo>myTestStringSubstring: </echo>
		
		<!-- Hier wird die scriptdef Methode substring aufgerufen -->
		<stringSubstringZZZ text="asdfasdfasdf" start="2" end="10" property="subtext" />
		<echo message="subtext = ${subtext}" />
		
		<stringSubStringZZZ text="asdfasdfasdf" start="0" end="1" property="subtext" />
		<echo message="subtext = ${subtext}" />
	</target> 
	
	<target name="-myTestStringLeftString">
		<echo>myTestStringLeft: </echo>
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringLeftStringZZZ text="asdfasdfasdf" matchstring="fas" returnstring="lefttext" />
		<echo message="lefttext = ${lefttext}" />
		
		<stringLeftStringZZZ text="asdfasdfasdf" matchstring="sdf" returnstring="lefttext" />
		<echo message="lefttext = ${lefttext}" />
	</target> 
	
	
	<target name="-myTestStringRightString">
		<echo>myTestStringRight: </echo>
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringRightStringZZZ text="asdfasdfasdf" matchstring="fas" returnstring="righttext" />
		<echo message="righttext = ${righttext}" />
		
		<stringRightStringZZZ text="asdfasdfasdf" matchstring="sdf" returnstring="righttext" />
		<echo message="righttext = ${righttext}" />
	</target> 
	
	
	<target name="-myTestStringLeftBackString">
		<echo>myTestStringLeftBackString: </echo>
		<property name="totaltext04" value="asdfa" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->			
		<property name="matchstring04" value="sdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->			
		<echo message="totaltext = ${totaltext04}" />
		<echo message="matchstring = ${matchstring04}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringLeftBackStringZZZ text="${totaltext04}" matchstring="${matchstring04}" returnstring="leftbacktext" />
		<echo message="leftbacktext = ${leftbacktext}" />
		
		<echo>#####################################</echo>
		<property name="totaltext03" value="asdfasdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->			
		<property name="matchstring03" value="sdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->			
		<echo message="totaltext = ${totaltext03}" />
		<echo message="matchstring = ${matchstring03}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringLeftBackStringZZZ text="${totaltext03}" matchstring="${matchstring03}" returnstring="leftbacktext" />
		<echo message="leftbacktext = ${leftbacktext}" />
		
		<echo>#####################################</echo>
		<property name="totaltext" value="asdfasdfa" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->			
		<property name="matchstring" value="sdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->			
		<echo message="totaltext = ${totaltext}" />
		<echo message="matchstring = ${matchstring}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringLeftBackStringZZZ text="${totaltext}" matchstring="${matchstring}" returnstring="leftbacktext" />
		<echo message="leftbacktext = ${leftbacktext}" />
		
		<echo>#####################################</echo>
		<property name="totaltext02" value="asdfasdfasdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->	
		<property name="matchstring02" value="sdf" /><!-- merke flaka ist hier nicht eingebunden, als kein fl:let moeglich und properies sind nicht aenderbar -->	
		<echo message="totaltext = ${totaltext02}" />
		<echo message="matchstring = ${matchstring02}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<stringLeftBackStringZZZ text="${totaltext02}" matchstring="${matchstring02}" returnstring="leftbacktext" />
		<echo message="leftbacktext = ${leftbacktext}" />
		
	</target> 
 </project>