<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_FlakaListHandling"   default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->
	
	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<!-- gebraucht wird das z.B. für den <for> </for> Task. -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayAppendJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="valueinput" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("valueinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;					
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				}
			}
						
			//3. Erweitere das Array UM ENCODIERTEN WERT
			icountGlobal++;
			print("Wert encoded anhängen an position " + icountGlobal + ": '" + myValue + "'");
			var textEncoded = encodeMyHtml(myValue);
			print("Encoded Wert wird kopiert: '" + textEncoded + "'");
			
			//TODO An dieser Stelle bei der Erweiterung arrays anzuhängen: Prüfen, ob das ein Einzelwert oder ein Array ist.
			myArrayReturn[icountGlobal]=textEncoded;
																						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			
		//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayAppendArrayJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an.
             Merke: Hier wird nicht encoded da davon ausgegangen wird, das die anzuhängenden Werte schon encoded erzeugt wurden.-->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="array2append" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myArray2append = attributes.get("array2append");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
			
			var objectArray2append = myArray2append.split(',');  //Merke: Versuche so ein Array zu machen.							
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
						
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					};
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugebende Array
			icount=-1; 
			var icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert: '" + objectArray[x]+ "'");
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				};
			};
						
			//3. Erweitere das Array, UM ALLE ANDEREN ARRAYWERTE
			for(z in objectArray2append){								
				if(objectArray2append[z]=="<#!!FGLUNDEFINED!!#>"){
					print("<#!!FGLUNDEFINED!!#> Wert NICHT anhaengen.");
				}else{
					icountGlobal++;
					print("Wert anhaengen an position " + icountGlobal + ": '" + objectArray2append[z]+ "'");
					myArrayReturn[icountGlobal]=objectArray2append[z];
				};							
			};			
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayCopyJsZZZ" language="javascript">
		<!-- Hiermit man ein Array in eine anderes neues Array.
             Beispielsweise sinnvoll, wenn von einer Funktion ein neues Array zurückgegeben wird,
             man aber noch mit dem alten 'Variablennamen' weiterarbeiten möchte.			 -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			
			//Kopiervorgang, noch ohne irgendwelche FlagControl Erweiterungen.			
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
				myArrayReturn[icount]=objectArray[x];
			};
															
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
	<!-- ########################### -->
	<scriptdef name="arrayDebugJsZZZ" language="javascript">
		<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
			   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
			   - der Inhalt
			   - die Größe des Arrays			-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="arrayinput" />
		<attribute name="ilevel" />	
		<![CDATA[	
			enableJava();
			var myArray = attributes.get("arrayinput");					
			var myLevel = attributes.get("ilevel");					
			if(myLevel<=0){
				
			}else{
			if(myArray===undefined) print("myarray = undefined");
			if(myArray==null) print("myarray = NULL");	
			
			//Typausgabe
			print("typeof myarray = " + typeof(myArray));
					
			
			var iSize=0;
			if(Array.isArray(myArray)){
				print("Array uebergeben bekommen");
				iSize = myArray.length;
				print("Arraygroesse="+iSize);
				
				//TODO: Die gleichen Ausgaben wie im KEIN ARRAY Fall.
				//- Werte
			}else{
				print("kein Array uebergeben bekommen.");
				
				var icount=0;					
				if(typeof(myArray)=="object"){
					print("Object uebergeben bekommen.");
					
					if(myLevel>=2){
					//das listet alle Methoden des objekts auf.... scheint ein String zu sein....
					//print("ALLE METHODEN DES OBJEKTS:");
					//for(x in myArray){
					//	print(x);		
					//};	
					
					print("#################################");
					print("ALLE METHODEN UND CODEINHALT DES OBJEKTS:");
					for(xx in myArray){
						print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
						print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
					};
					};//myLevel>=2;
					
					debugArrayAsString(myArray);
				}else{
					print("kein Objekt");
					debugArrayAsString(myArray);					
				};
			};
			};//myLevel <= 0;
			
			
			function debugArrayAsString(myArray){
					print("#################################");
					print("myArray ist jetzt leider ein String ='"+ myArray +"'");
					//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
					
					print("splitte diesen String nach Komma.");
					var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
					for(x in objectArray){
						print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					};
					
					//var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
					//for(x2 in objectArray02){
					//	print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
					//};
					
					//var objectArrayString = myArray.toString();
					//var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
					//for(z in objectArray03){
					//	print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
					//};
					
					print("#################################");
					print("Versuch die Werte auszugeben: ");	
					//Merke: Voraussetzung ist:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 for(yy in objectArray){
							print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
						};
			}
			
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
			
		]]>
	</scriptdef>
	
	 <!-- ########################### -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="ireturn" />
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iReturn = -1;
										
			//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
			var icount=0;
			var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
			if(typeof(objectArray)=="object"){
			for(x in objectArray){
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				}else{
					icount++;
				};				
			}							
			}else{
				iReturn=0;
			}
			
			iReturn = icount;
			
			project.setProperty(attributes.get("ireturn"), iReturn);
		]]>
	</scriptdef>
			
	<!-- ########################### -->	
	<scriptdef name="arrayGetJsZZZ" language="javascript">
		<!-- Hiermit holt man den Wert an einer Indexposition (beginnend mit 0)
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	-->
				
		<!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<attribute name="arrayinput" />
		<attribute name="index" />
		<attribute name="arrayget" />
		<attribute name="sflagcontrol" /><!-- sflagcontrol werte: raw=mache kein unescape. -->
		<![CDATA[
			var lista = attributes.get("arrayinput");		 
			var iIndex = attributes.get("index");
			var mysFlagControl = attributes.get("sflagcontrol");
			var objReturn="<#!!FGLUNDEFINED!!#>";
			main:{
				if(iIndex <= -1) break main;
				
				//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
				var icount=-1;
				var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				if(typeof(objectArray)=="object"){
				for(x in objectArray){
					//print("x="+x);
					//print("objectArray[x]="+objectArray[x]);
					
					//Undefinierte, d.h. nur initialisierte Arrays abfangen
					//Sie haben die Groesse 0 und an erster Stelle das <#!!FGLUNDEFINED!!#>
					if(objectArray.length<=1 && objectArray[x]=="<#!!FGLUNDEFINED!!#>"){						
						break main;
					}else{
						icount++;
						if(icount==iIndex){
							//Per Schalter das unescapen abstellbar machen. Also auf Wunsch also die 'raw Werte' zurückliefern.
							if(mysFlagControl=='raw'){
							    objReturn = objectArray[x];
							}else{
								var textUnescaped = unescape(objectArray[x]); //Merke: In ArrayAppendJsZZZ werden die Strings nur noch encoded angehängt.
								objReturn = textUnescaped;								
							}
							break main;
						}				
					}; //end if
					}; //end for
				}; //end if(typeof(objectArray)=="object")				
			}; //end main:
			project.setProperty(attributes.get("arrayget"), objReturn);
		]]>
	</scriptdef>
			
	<!-- ############################################################-->		
	<scriptdef name="arrayInitJsZZZ" language="javascript">
		<!-- Hiermit faked man die Erstellung eines Arrays.
			 Da scheinbar kein "call by reference" gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="isize" />
		<attribute name="arrayreturn" />		
		<![CDATA[										 
			var mySize = attributes.get("isize");	
			//print("iSize = '" + mySize + "'");
			
			//Prüfen, ob mySize eine Zahl ist. 
			//Merke: Ist z.B. die Flaka - Variable nicht oder leer deklariert, kommt hier der Variablenname '${irgendwas}' an.
			//           Das bewirkt, dass dieses '${irgendwas}' als erstes Element in´s Array kommt und das Array sofort die Größe 1 hat, was in dem Fall nicht beabsichtigt ist.
			if(isNumber(mySize)){
				//print("eine Zahl");
				var myArrayReturn = new Array(); //Merke: Egal was man hier als Groesse angiebt [irgendwas] wird als Wert übernommen genauso wie leiglich: irgendwas
				
				if(mySize==0){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
				}
				if(mySize>=1){
					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					for(icount=0; icount<=mySize-1; icount++){
						myArrayReturn[icount]="<#!!FGLEMPTY!!#>";
					}												
				}								
			}else{
				//print("KEINE Zahl");
				var myArrayReturn = new Array();

				//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
				myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
			}
						
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
		]]>
	</scriptdef>
				
	<!-- ############################################################-->	
	<scriptdef name="arrayLeftBackStringJsZZZ" language="javascript">
		<!-- Hiermit schneodet man von den Werten eines Arrays einen Stringwert ab. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="sinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'before' von vorne bzw. 'behind' von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("sinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			//   UND erweitere jeden Arrayeintrag um den gewünschten String.
			//   TODO: sFlagControl auswerten, zum unterscheiden ob der String vorangestellt oder angehängt wird.
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					print("Wert wird kopiert und abgeschnitten: '" + objectArray[x]+ "' leftback von '" + myValue + "'");
					myArrayReturn[icount]=getStrLeftBackStr(objectArray[x], myValue);
				}else{
					//nix
				}
			}
						
													
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);			
			
			//äquivalent zu JSZ - Kernel
			//@LeftBack equivalent, !!! casesensitive
			function getStrLeftBackStr(sourceStr, keyStr){
				arr = sourceStr.split(keyStr);
				//arr.pop();		//entfernt das letzte Element aus dem Array
				arr.shift();		//entfernt das erste Element aus dem Array
				return (keyStr==null | keyStr=='') ? '' : arr.join();		
			}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->	
	<scriptdef name="arrayPlusStringJsZZZ" language="javascript">
		<!-- Hiermit häng man an die Werte eines Arrays einen Stringwert an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="sinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'before' von vorne bzw. 'behind' von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("sinput");
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			//   UND erweitere jeden Arrayeintrag um den gewünschten String.
			//   TODO: sFlagControl auswerten, zum unterscheiden ob der String vorangestellt oder angehängt wird.
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					print("Wert wird kopiert und erweitert: '" + objectArray[x]+ "' plus '" + myValue + "'");
					myArrayReturn[icount]=objectArray[x] + myValue;
				}else{
					//nix
				}
			}
						
													
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
		]]>
	</scriptdef>
	
   <!-- ########################### -->
  <scriptdef name="arrayStringImplodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="sDirRepositoryJsscriptdef" /><!-- Falls mal der Name des Verzeichnisses der Bibliothek überschrieben werden soll -->
				
	<!-- Fügt die Strings eines Arrays zusammen. Dabei untere / oberen Indes als Grenze der zu verarbeitenden Arraywerte angeben. -1 ist jeweils min / max. -->
	<attribute name="inputarraystring" />
	<attribute name="inputdelimiter"/>
	<attribute name="inputindexlow"/>
	<attribute name="inputindexhigh"/>

    <attribute name="returnstring" /> 
	<attribute name="returncontrol" /> 
	<attribute name="returncontrolString" />
	
	
    <![CDATA[
		//normalerweise verwendet man join, wie in dem Beispiel:
		//var str_to_split = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z";
		//var myarray = str_to_split.split(",");
		//var output=myarray.join("");
		//
		//Aber hier soll nur ein bestimmter Bereich von... bis... gejoint werden. 
		//Sinnvoll um vom Array vorne oder hinten etwas abzuschneiden.
	    
		var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
		
		var myArrayString = attributes.get("inputarraystring");		
		var myDelimiter = attributes.get("inputdelimiter");
		var myiIndexLow = attributes.get("inputindexlow");
		var myiIndexHigh = attributes.get("inputindexhigh");
		print("myiIndexLow=" + myiIndexLow);
		print("myiIndexHigh=" + myiIndexHigh);
		
		
		//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var sReturn="";
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";
				
			//Die benoetigten Kernel-Funktionen laden
			var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
			var objControlCaller=new Object();
			var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCaller);			
			if(!objControlCaller.bReturnControl){								
				bReturnControl=false;
				sReturn="";
			}else{				
				sReturn=arrayStringImplodeJs(objKernelLibs, myArrayString, myDelimiter, myiIndexLow, myiIndexHigh, objControlCaller);				
				if(!objControlCaller.bReturnControl){									
					bReturnControl=false;
					sReturn="";
				}else{					
				}
			}	
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			//###################################################################
            //#### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verfügung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
			
			
		
		
		 //####################################################################################################					
		function arrayStringImplodeJs(objKernelLibs, myArrayString, myDelimiter, myiIndexLow, myiIndexMax, objControl){	 	
			var sScript = "arrayStringImplodeJs: ";
			print(sScript + "START");
				
			var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
			var bReturnControl=false;
			var sReturnControl="Fehler";	
				
			try{															
				//IN JEDER FUNKTION DAS LADERN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG					
				if(objKernelLibs==undefined || objKernelLibs==null){
					print("Keine Kernel Ant Js Libs uebergeben.");
				} else {						
					if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
						print("Keine Kernel Ant Js Libs vorhanden zum Laden");
					} else {
						print(sScript+"Loading Kernel Ant Js Libs: " + objKernelLibs.length);
						for (var i = 0; i < objKernelLibs.length; i++) { 	
							print("Lib: " + objKernelLibs[i]["Alias"]);					
							print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
							//funktioniert: 
							eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
							//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
							}
						}
					}
				print("#######################");
				var objControlCaller=new Object();				
				sReturn=arrayStringImplodeZZZ(objKernelLibs,myArrayString,myDelimiter,myiIndexLow,myiIndexHigh,objControlCaller);
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
					
				bReturnControl=objControlCaller.bReturnControl;
				sReturnControl=objControlCaller.sReturnControl;
				bReturnControl=true;
			}catch(err){	
				//#### SIMPLES ERROR HANDLING #######
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;	

				//#### ERROR HANDLING #######
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl = false;
					sReturnControl= myErrorString;				
				}catch(e){
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler im ErrorHandling. "+ e;
				}
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;			
			return sReturn;
		}			
     ]]>
	</scriptdef>
	
   <!-- ########################### -->
  <scriptdef name="arrayStringTrimJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
				
	<!-- Entfernt leere Strings aus einem Array. bReturnControl=true, wenn etwas entfernt wurde. -->
	<!-- Controlstring: "trim = die einzelnen Strings sollen einem trim zur Pruefung unterzogen werden. Keine Veraenderung des Werts"
						 trimmed = wie trim, aber Veraenderung des Werts.-->
	<attribute name="inputarraystring" />
	<attribute name="inputcontrolstring" /> <!-- so mögliche Erweiterungen wie 'fulltrim' realisieren. -->
	
    <attribute name="returnarraystring" /> 
	<attribute name="returncontrol" /> 
	
    <![CDATA[
		var myArrayString = attributes.get("inputarraystring");		
		var myControlString = attributes.get("inputcontrolstring");	
	
		var myArrayReturn = new Array();			
		var bReturnControl = false;
		
		if(myArrayString===undefined){
			//print("myString = undefined");
			bReturnControl = false;
		}else if(myArrayString===null){
			//print("myString = null");			
			bReturnControl = false;
		}else{
						
				//Merke: Versuche so ein 'echtes' Array zu machen, sonst geht man Buchstabe für Buchstabe vor.
				var objectArray = myArrayString.split(',');  
														
				//Falsch: damit geht man Buchstabe für Buchstabe vor: 
				//for (var i = myiIndexLow, len = myiIndexHigh; i<len; i++){
				//	print("myArrayString[i]="+myArrayString[i]);
				//	myStringReturn+=myArrayString[i];
				//	print("myStringReturn="+myStringReturn);
				//}	

			
				
				
				var iIndexCount = -1;
				for(x in objectArray){
					print("objectArray[x]="+objectArray[x]);
					var sCheckValue = objectArray[x];
					var sValue = objectArray[x];
					if(myControlString=="trimmed"){
						sCheckValue = objectArray[x].trim();
						sValue= objectArray[x].trim();						
					}else if(myControlString=="trim"){	
						sCheckValue = objectArray[x].trim();
						//Keine Veraenderung des Werts
					};	
					
					//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
					if(sCheckValue=="<#!!FGLUNDEFINED!!#>"){
						//mache nix... myArrayReturn[icount]="<#!!FGLUNDEFINED!!#>";		//Wenn undefiniert, dann bleibt der Wert undefiniert.
						bReturnControl=true;
					}else if(sCheckValue=="<#!!FGLEMPTY!!#>"){
						//mache nix... myArrayReturn[icount]="Neuer Wert "+ icount; 		//Leere Werte werden automatisch erzeugt.
						bReturnControl=true;
					}else if(sCheckValue==""){
						//mache nix...
						bReturnControl=true;
					}else{						
						iIndexCount++;
						myArrayReturn[iIndexCount]=sValue; //Bestehende Werte werden nur kopiert.
						if(sValue==objectArray[x]){
							//mache nix...
						}else{	
							bReturnControl=true;
						};
					};		
				}								
			}	
			
			//abschliessende Pruefung
			if(myArrayReturn.lenght==0){
				print("Setze undefined Dummy - Wert.");
				myArrayReturn[0]="<#!!FGLUNDEFINED!!#>";
			};	
		project.setProperty(attributes.get("returnarraystring"), myArrayReturn);
		project.setProperty(attributes.get("returncontrol"), bReturnControl);
				
     ]]>
	</scriptdef>	
	
	<!-- ############################################################-->	
	<scriptdef name="arrayValueTestFillJsZZZ" language="javascript">
		<!-- Hiermit füllt man ein Array mit default-Werten. Zu Testzwecken.
			 TODO: Die Paramter ilbound und iubound müssen noch ausprogrammiert werden.
				   Damit soll das Auffüllen der Testwerte auf einen bestimmten Indexbereich beschränkt werden. -->
		
		<!-- Merke: Da scheinbar kein "call by reference" gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="arrayinput" />
		<attribute name="ilbound" />
		<attribute name="iubound" />
		<attribute name="arrayreturn" />
		<attribute name="ireturn" /><!-- true, false -->
		<![CDATA[
			enableJava();
			var myArray = attributes.get("arrayinput");		 
			var iReturn = false;
			var myArrayReturn = new Array();
								
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			for(x in objectArray){
				//print("Wert vorher: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
					myArrayReturn[icount]="<#!!FGLUNDEFINED!!#>";		//Wenn undefiniert, dann bleibt der Wert undefiniert.
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					myArrayReturn[icount]="Neuer Wert "+ icount; 		//Leere Werte werden automatisch erzeugt.
				}else{
					myArrayReturn[icount]=objectArray[x]+ " " + icount; //Bestehende Werte werden verändert.
				};				
			}	

			//for(x in myArrayReturn){
			//	print("Wert nachher: '" + myArrayReturn[x]+ "'");
			//}														
			iReturn = true;											
		
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			project.setProperty(attributes.get("ireturn"), iReturn);
			
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
		]]>
	</scriptdef>
					
	<!-- ########################### -->
	<scriptdef name="isArrayEmptyJsZZZ" language="javascript">
		<!-- Hiermit prueft man, ob das Array nur Werte hat, die aber als Leerwert gekennzeichet ist. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="arrayinput" />
		<attribute name="returnboolean" />
		<attribute name="sflagcontrol" />
		<![CDATA[		   		  
		   var bReturn = true;		   
		   var myArrayInput = attributes.get("arrayinput");
		   //print("myArrayInput='"+myArrayInput+"'");		   			
			
			//Das Array in einer Schleife durchgehen			
			main:{				
				//Merke: arrayinput ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
			
				var icount=-1;
				var objectArray = myArrayInput.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				//print('typeof(objectArray)=' + typeof(objectArray));
				if(typeof(objectArray)=="object"){
					if(objectArray.length<=0)break main;
					
					var btemp=false;
					for(x in objectArray){
						//print("x="+x);
						//print("objectArray[x]="+objectArray[x]);
											
						//Prüfe alle Werte ab, ob man nicht doch noch einen definierten Wert im Array findet.
						if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
							btemp=true;							
						}else{							
							break main;
						}; //end if
					}; //end for
					bReturn=btemp;
				}; //end if(typeof(objectArray)=="object")				
			}; //end main:	
			project.setProperty(attributes.get("returnboolean"), bReturn);						
		 ]]>
	</scriptdef>	
	
	  <!-- ########################### -->
  <scriptdef name="stringExplodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
	<attribute name="inputdelimiter"/>

    <attribute name="returnarraystring" /> 
	<attribute name="returncontrol" /> 
	
    <![CDATA[
		var myString = attributes.get("inputstring");
		var myDelimiter = attributes.get("inputdelimiter") ;
		
		var myArrayReturn = new Array();
		var bReturnControl = true;
		if(myString===undefined){
			print("myString = undefined");
			bReturnControl = false;
		}else if(myString===''){
			print("myString = leer");			
			bReturnControl = false;
		}else{
			if(myDelimiter===undefined){
				print("myDelimiter = 'undefined'");
				myArrayReturn[0]=myString;
				bReturnControl = false;
			}else if(myDelimiter===''){
				print("myDelimiter = 'leer'");
				myArrayReturn[0]=myString;
				bReturnControl = false;
			}else{	
				var myStringEncoded = encodeMyHtml(myString);
				var myDelimiterEncoded = encodeMyHtml(myDelimiter);
		
				 values = myStringEncoded.split(myDelimiterEncoded);
				 for(i=0; i<values.length; i++) {
					//So wird ein Array künstlich erzeugt.... project.setNewProperty(attributes.get("inputprefix")+i, values[i]);
					myArrayReturn[i]=unescape(values[i]);//Das encoden wieder rueckgaengig machen.
				 }				 		
			}
		}				 
		project.setProperty(attributes.get("returnarraystring"), myArrayReturn);
		project.setProperty(attributes.get("returncontrol"), bReturnControl);
		
			//TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
	</scriptdef>
	
 <!-- ########################### -->
 <scriptdef name="stringLeftStringZZZ" language="javascript">
 <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	   var text = attributes.get("text");
       var match = attributes.get("matchstring");
       
       sReturn = getStrLeftStr(text, match);
	   
       project.setProperty(attributes.get("returnstring"), sReturn);
	   
	   //aus JSZ - Kernel 
	   function getStrLeftStr(sourceStr, keyStr){
		return (sourceStr.indexOf(keyStr) == -1 | keyStr=='') ? '' : sourceStr.split(keyStr)[0];
		}
     ]]>
  </scriptdef>

  <!-- ########################### -->
  <scriptdef name="stringLeftBackStringZZZ" language="javascript">
   <!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
   <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
	<attribute name="text" />
    <attribute name="matchstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	  var text = attributes.get("text");
	  var match = attributes.get("matchstring");
       
      sReturn = getStrLeftBackStr(text, match);
	   
      project.setProperty(attributes.get("returnstring"), sReturn);
	   
	//äquivalent zu JSZ - Kernel
	//@LeftBack equivalent, !!! casesensitive
	function getStrLeftBackStr(sourceStr, keyStr){
		arr = sourceStr.split(keyStr)
		arr.pop();
		return (keyStr==null | keyStr=='') ? '' : arr.join(keyStr)
	}
  ]]>
  </scriptdef>
  
  <!-- ############################################################ -->
	<scriptdef name="stringSubStringZZZ" language="javascript">
	<!-- ### ScriptDefs, u.a für die Stringverarbeitung, MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem wg. der Übersicht die Camelcase Variante beibehalten. ###-->
		 <attribute name="text" />
		 <attribute name="start" />
		 <attribute name="end" />
		 <attribute name="property" />
		 <![CDATA[
		   var text = attributes.get("text");
		   var start = attributes.get("start");
		   var end = attributes.get("end") || text.length();
		   project.setProperty(attributes.get("property"), text.substring(start, end));
		 ]]>
	</scriptdef>

	
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
<!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
			 
<!-- TODO Test für isarrayEmptyJsZZZ -->			 
			 
<!-- <target name="compile" depends="-declaration,-myTestArrayInitJsZZZ,-myTestArrayDebugJsZZZ,-myTestArrayStringTrimJsZZZ,-myTestArrayStringImplodeJsZZZ-myTestArrayGetJsZZZ,-myTestArrayPlusStringJsZZZ,-myTestArrayLeftBackStringJsZZZ,-myTestArrayAppendJsZZZ, -myTestArrayAppendArrayJsZZZ"> -->
<target name="compile" depends="-declaration,-myTestArrayStringImplodeJsZZZ">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-declaration">
	  <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	  dies passiert hier durch flaka´s install-property handler task -->
	  <fl:install-property-handler />	
  </target>
  
  <target name="-myTestArrayAppendJsZZZ">
		<!-- Testen etwas an ein Array anzuhaengen -->
		
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayAppendJsZZZ:
		Meine Loesung: Scriptdef arrayAppendJsZZZ</fl:logo>	


		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 3 'initialisieren' -->
		<fl:let>
			myArraySize::=3; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Wert an das Array anhängen -->
		<fl:let>
			mySingleValue::= "angehängter Wert"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
		
		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 2 'initialisieren' -->	
		<fl:let>
			myArraySize::=2; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
	
		<!-- Wert an das Array anhängen -->
		<fl:let>
			mySingleValue::= "angehängter Wert"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
		
		
		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 1 'initialisieren' -->
		<fl:let>
			myArraySize::=1; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
	
		<!-- Wert an das Array anhängen -->
		<fl:let>
			mySingleValue::= "angehängter Wert"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
		
		
		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 0 'initialisieren' -->
		<fl:let>
			myArraySize::=0; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />	
	
		<!-- Wert an das Array anhängen -->
		<fl:let>
			mySingleValue::= "angehängter Wert"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
			
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
				
	<echo>###########################################################</echo>
		<!-- anderer Versuch: Array nur 'initialisieren' -->
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
		
		<!-- Wert an das Array anhängen -->
		<fl:let>
			mySingleValue::= "angehängter Wert"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
				
	</target>
	
	<target name="-myTestArrayAppendArrayJsZZZ">
		<!-- Testen etwas an ein Array anzuhaengen -->
		
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayAppendArrayJsZZZ:
		Meine Loesung: Scriptdef arrayAppendArrayJsZZZ</fl:logo>	


		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 3 'initialisieren' -->
		<fl:let>myArraySize::=3;</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<fl:let>myArraySize::=2;</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray2append"/>
		<echo>myArray nachher: ${myArray2append}</echo>
	
		<arrayValueTestFillJsZZZ arrayinput="${myArray2append}" ilbound="0" iubound="" arrayreturn="myArray2appendNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArray2appendNew}" arrayreturn="myArray2append" sflagcontrol="" />
		
		<!-- Wert des zweiten Arrays an das erste Array anhängen -->		
		<arrayAppendArrayJsZZZ arrayinput="${myArray}" array2append="${myArray2append}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>				
	</target>
  
	<target name="-myTestArrayGetJsZZZ">
		<!-- Teste einen Wert aus dem Array auszulesen. -->
		
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayGetJsZZZ:
		Meine Loesung: Scriptdef arrayGetJsZZZ</fl:logo>	

		<echo>### 1. Testaufbau: Array blanko 'initialisieren' ########################################################</echo>
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArrayNew"/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Hole Wert an den Stellen -1, 0, 1 -->
		<arrayGetJsZZZ arrayinput="${myArray}" index="-1" arrayget="myValue" sflagcontrol=""/>
		<echo>-1: Geholter Wert: ${myValue}</echo> 
		
		<arrayGetJsZZZ arrayinput="${myArray}" index="0" arrayget="myValue" sflagcontrol=""/>
		<echo> 0: Geholter Wert: ${myValue}</echo>
		
		<arrayGetJsZZZ arrayinput="${myArray}" index="1" arrayget="myValue" sflagcontrol=""/>
		<echo> 1: Geholter Wert: ${myValue}</echo>
			
		<echo>###  2. Testaufbau: Array mit 3 'initialisieren'  ########################################################</echo>
		<fl:let>
			myArraySize::=3; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Hole Wert an Stelle 1 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="1" arrayget="myValue" sflagcontrol=""/>
		<echo> 1: Geholter Wert: ${myValue}</echo>
	
		<echo>### 3. Testaufbau: Werte eingeben ########################################################</echo>
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->
	
		<!-- Hole Wert an Stelle 1 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="1" arrayget="myValue"/>
		<echo> 1: Geholter Wert: ${myValue}</echo>
		
		<echo>###  4. Testaufbau: Wert an das Array anhängen ########################################################</echo>
		<fl:let>
			mySingleValue::= "angehängter Wert"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->
		
		<!-- Hole Wert an Stelle 3 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="3" arrayget="myValue" sflagcontrol=""/>
		<echo> 3: Geholter Wert: ${myValue}</echo>	
				
		<!-- Hole Wert an Stellen 4 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="4" arrayget="myValue" sflagcontrol=""/>
		<echo> 4: Geholter Wert: ${myValue}</echo>
		
		<echo>###  5. Testaufbau: Wert 'mit BACKSLASH am Ende' an das Array anhängen ########################################################</echo>
		<fl:let>
			mySingleValue::= "angehängte Endung beachten\\"; 
		</fl:let>
		<arrayAppendJsZZZ arrayinput="${myArray}" valueinput="${mySingleValue}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/><!-- Ausgabe des neuen Arrays -->
		
		<echo>###  5a. Fall unescape ########################################################</echo>
		<!-- Hole Wert an Stelle 4 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="4" arrayget="myValue" sflagcontrol=""/>
		<echo> 4: Geholter Wert: ${myValue}</echo>	
				
		<!-- Hole Wert an Stellen 4 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="5" arrayget="myValue" sflagcontrol=""/>
		<echo> 5: Geholter Wert: ${myValue}</echo>
		
		
		<echo>###  5b. Fall raw. ########################################################</echo>		
		<!-- Hole Wert an Stelle 4 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="4" arrayget="myValue" sflagcontrol="raw"/>
		<echo> 4: Geholter Wert: ${myValue}</echo>	
				
		<!-- Hole Wert an Stellen 5 -->		
		<arrayGetJsZZZ arrayinput="${myArray}" index="5" arrayget="myValue" sflagcontrol="raw"/>
		<echo> 5: Geholter Wert: ${myValue}</echo>
		
	</target>

	<target name="-myTestArrayDebugJsZZZ">
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayDebugJsZZZ:
		Meine Loesung: Scriptdef arrayDebugJsZZZ</fl:logo>		
		<fl:let>
			myArraySize::=2; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
	
		<!-- TODO : Kopiere den wert in den ursprünglichen Variablennamen -->
	
		<!-- Unterschiedliche Debug - Level testen -->	
		<arrayDebugJsZZZ arrayinput="${myArrayNew}" ilevel="0"/>
		
		<arrayDebugJsZZZ arrayinput="${myArrayNew}" ilevel="1"/>
		
		<arrayDebugJsZZZ arrayinput="${myArrayNew}" ilevel="2"/>
		
	</target> 
	
	
  <target name="-myTestArrayInitJsZZZ">
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayInitJsZZZ:
			Meine Loesung: Scriptdef arrayInitJsZZZ</fl:logo>		
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<arrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
		<arrayElementCountJsZZZ arrayinput="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von arrayElementCountJsZZZ: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss <#!!FGLUNDEFINED!!#> drin stehen. -->
		
		<echo>#################################</echo>
		<fl:let>
			myArraySize::=0; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<arrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
		<arrayElementCountJsZZZ arrayinput="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von arrayElementCountJsZZZ: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss <#!!FGLUNDEFINED!!#> drin stehen. -->
		
		<echo>#################################</echo>
		
			<fl:let>
			myArraySize::=1; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<arrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
		<arrayElementCountJsZZZ arrayinput="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von arrayElementCountJsZZZ: ${iSize}</echo><!-- Diese Methode darf nur 1 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss 1x <#!!FGLEMPTY!!#> drin stehen. -->
		
		<echo>#################################</echo>
		
				<fl:let>
			myArraySize::=2; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<arrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode arrayElementCountJsZZZ aufgerufen -->
		<arrayElementCountJsZZZ arrayinput="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von arrayElementCountJsZZZ: ${iSize}</echo><!-- Diese Methode darf nur 2 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss 1x <#!!FGLEMPTY!!#> drin stehen. -->
		
		<echo>#################################</echo>
		
	</target>
	
	<target name="-myTestArrayLeftBackStringJsZZZ">
		<!-- Teste einen String an die Werte eines Arrays anzuhaengen -->
		
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayLeftBackStringJsZZZ:
		Meine Loesung: Scriptdef arrayLeftBackStringJsZZZ</fl:logo>	


		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 3 'initialisieren' -->
		<fl:let>myArraySize::=3;</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<fl:let>myValue2Append::=".txt";</fl:let>
		
		<!-- Wert anhängen -->		
		<arrayPlusStringJsZZZ arrayinput="${myArray}" sinput="${myValue2Append}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>

		<!-- NUN ERST DAS ABZIEHEN DES WERTS TESTE -->
		<arrayLeftBackStringJsZZZ arrayinput="${myArray}" sinput=".txt" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
	</target>
	
	<target name="-myTestArrayPlusStringJsZZZ">
		<!-- Teste einen String an die Werte eines Arrays anzuhaengen -->
		
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayPlusStringJsZZZ:
		Meine Loesung: Scriptdef arrayPlusStringJsZZZ</fl:logo>	


		<echo>###########################################################</echo>
		<!-- anderer Versuch: Array mit 3 'initialisieren' -->
		<fl:let>myArraySize::=3;</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<fl:let>myValue2Append::="_angehaengt";</fl:let>
		
		<!-- Wert anhängen -->		
		<arrayPlusStringJsZZZ arrayinput="${myArray}" sinput="${myValue2Append}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
	
		<!-- Ausgabe des neuen Arrays -->	
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>				
	</target>
  
  <target name="-myTestArrayStringImplodeJsZZZ">
		<fl:let>sScript::='-myTestArrayStringImplodeJsZZZ: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		<fl:logo>${sScript}Start
		Meine Loesung: Scriptdef arrayStringImplodeJsZZZ</fl:logo>
		<echo> </echo>
		<echo>#### Eingabewert ohne Backslash, Delimiter ohne Backslash ##############################</echo>
		<fl:let>myArraySize::=3;</fl:let>
		<echo>${sScript}ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>${sScript}myArray vorher: ${myArray}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray}" ilbound="0" iubound="" arrayreturn="myArrayNew" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArrayNew}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>
				
		<fl:let>sDelimiter::="x"</fl:let>
		<arrayCopyJsZZZ arrayinput="${myArray}" arrayreturn="myArrayNew" sflagcontrol="" />
		<arrayStringImplodeJsZZZ inputarraystring="${myArrayNew}" inputdelimiter="${sDelimiter}" inputindexlow="-1" inputindexhigh="-1" returnstring="myReturnString" returncontrol="myReturnControl" returncontrolstring="myReturnControlString"/>
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo>${sScript}Ergebnisstring: ${myReturnString}</echo>

		<echo> </echo>
		<echo>#### Eingabewert ohne Backslash, Delimiter MIT Backslash ##############################</echo>
		<fl:let>myArraySize::=3;</fl:let>
		<echo>${sScript}ArrayGroesse: ${myArraySize}</echo>
		<arrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray2"/>
		<echo>${sScript}myArray vorher: ${myArray2}</echo>
	
		<!-- Werte eingeben -->
		<arrayValueTestFillJsZZZ arrayinput="${myArray2}" ilbound="0" iubound="" arrayreturn="myArray2New" ireturn=""/>
		<arrayCopyJsZZZ arrayinput="${myArray2New}" arrayreturn="myArray2" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray2}" ilevel="1"/>
				
		<fl:let>sDelimiter2::="\\"</fl:let><!-- Backslash muss maskiert werden -->
		<arrayCopyJsZZZ arrayinput="${myArray2}" arrayreturn="myArray2New" sflagcontrol="" />
		<arrayStringImplodeJsZZZ inputarraystring="${myArray2New}" inputdelimiter="${sDelimiter2}" inputindexlow="-1" inputindexhigh="-1" returnstring="myReturnString2" returncontrol="myReturnControl" returncontrolstring="myReturnControlString"/>
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo>${sScript}Ergebnisstring: ${myReturnString2}</echo>	

		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
		</trycatch>				
	</target>

  <target name="-myTestArrayStringTrimJsZZZ">
		<fl:let>sScript::='-myTestArrayStringTrimJsZZZ: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		<fl:logo>${sScript}Start
		Meine Loesung: Scriptdef arrayStringTrimJsZZZ</fl:logo>
		<echo> </echo>
		<echo>#### Eingabewert mit abschliessendem Leerstring, Delimiter Backslash ==> Erzeugt leeres letzes Arrayelement ##############</echo>		
		<fl:let>sValue::='c:\test\directory\nocheins\ '</fl:let><!-- Der Backslash muss maskiert werden --><!-- Leerzeichen angehängt -->
		<echoproperties prefix="sValue"/>
		<!--<echo>${sScript}sString2escape=${sString2escape}</echo>-->
		<fl:let>sDelimiter::="\\"</fl:let>
		<arrayInitJsZZZ isize="0" arrayreturn="myReturnArray"/>	<!-- Das Testarray wieder neu initialisieren -->
		<stringExplodeJsZZZ inputstring="${sValue}" inputdelimiter="${sDelimiter}" returnarraystring="myReturnArray" returncontrol="myReturnControl"/>
		<arrayCopyJsZZZ arrayinput="${myReturnArray}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>			
		<echo> </echo>
		<echo>${sScript}# Nun inputcontrolstring='trim' ##############</echo>
		<arrayStringTrimJsZZZ inputarraystring="${myArray}" inputcontrolstring="trim" returnarraystring="myReturnArray2" returncontrol="myReturnControl2"/>
		<echo>${sScript}# myReturnControl2 nach arrayStringTrimJsZZZ=${myReturnControl2}</echo>
		<arrayCopyJsZZZ arrayinput="${myReturnArray2}" arrayreturn="myArray2" sflagcontrol="" />		
		<arrayDebugJsZZZ arrayinput="${myArray2}" ilevel="1"/>
		<echo> </echo>
		<echo>${sScript}# Nun inputcontrolstring='trimmed' ##############</echo>
		<arrayStringTrimJsZZZ inputarraystring="${myArray}" inputcontrolstring="trimmed" returnarraystring="myReturnArray2" returncontrol="myReturnControl2"/>
		<echo>${sScript}# myReturnControl2 nach arrayStringTrimJsZZZ=${myReturnControl2}</echo>
		<arrayCopyJsZZZ arrayinput="${myReturnArray2}" arrayreturn="myArray2" sflagcontrol="" />		
		<arrayDebugJsZZZ arrayinput="${myArray2}" ilevel="1"/>
		<echo> </echo>			

		<echo> </echo>			
		<echo>#### Eingabewert mit abschliessendem trimmbaren String, Delimiter Backslash ==> Erzeugt trimmbares letzes Arrayelement ##############</echo>
		<fl:let>sValue::='c:\test\directory\nocheins\\ xyz '</fl:let><!-- Der Backslash muss maskiert werden --><!-- Leerzeichen angehängt -->
		<echoproperties prefix="sValue"/>
		<!--<echo>${sScript}sString2escape=${sString2escape}</echo>-->
		<fl:let>sDelimiter::="\\"</fl:let>
		<arrayInitJsZZZ isize="0" arrayreturn="myReturnArray"/>	<!-- Das Testarray wieder neu initialisieren -->
		<stringExplodeJsZZZ inputstring="${sValue}" inputdelimiter="${sDelimiter}" returnarraystring="myReturnArray" returncontrol="myReturnControl"/>
		<arrayCopyJsZZZ arrayinput="${myReturnArray}" arrayreturn="myArray" sflagcontrol="" />
		<arrayDebugJsZZZ arrayinput="${myArray}" ilevel="1"/>			
		<echo> </echo>
		<echo>${sScript}# Nun inputcontrolstring='trim' ##############</echo>
		<arrayStringTrimJsZZZ inputarraystring="${myArray}" inputcontrolstring="trim" returnarraystring="myReturnArray2" returncontrol="myReturnControl2"/>
		<echo>${sScript}# myReturnControl2 nach arrayStringTrimJsZZZ=${myReturnControl2}</echo>
		<arrayCopyJsZZZ arrayinput="${myReturnArray2}" arrayreturn="myArray2" sflagcontrol="" />		
		<arrayDebugJsZZZ arrayinput="${myArray2}" ilevel="1"/>
		<echo> </echo>
		<echo>${sScript}# Nun inputcontrolstring='trimmed' ##############</echo>
		<arrayStringTrimJsZZZ inputarraystring="${myArray}" inputcontrolstring="trimmed" returnarraystring="myReturnArray2" returncontrol="myReturnControl2"/>
		<echo>${sScript}# myReturnControl2 nach arrayStringTrimJsZZZ=${myReturnControl2}</echo>
		<arrayCopyJsZZZ arrayinput="${myReturnArray2}" arrayreturn="myArray2" sflagcontrol="" />		
		<arrayDebugJsZZZ arrayinput="${myArray2}" ilevel="1"/>
		<echo> </echo>

		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
		</trycatch>		
	</target>

	
	
		<!-- Beispiel für JAVA Arrays
		<scriptdef name="validateTimeZone" language="javascript">
    <attribute name="zone" />
    <![CDATA[
        importClass(java.util.TimeZone);
        importClass(java.util.Arrays);
        var tz = attributes.get("zone"); //get attribute defined for scriptdef
        println("    got attribute: " + tz);
        var result = Arrays.asList(TimeZone.getAvailableIDs()).contains(tz); //testing if timezone is known
        project.setProperty("zoneIsValid", result);
    ]]> 
</scriptdef> 
-->
		
 </project>