<?xml version="1.0" encoding="UTF-8" ?>  
<project name="test_ReflectionHandlingJsZZZ"   default="compile" basedir=".."
	xmlns:fl="antlib:it.haefelinger.flaka" 
	xmlns:ac="antlib://net/sf/antcontrib"><!-- damit definiert man für antcontrib , bzw. FLAKA einen eigenen Namespace. Antcontrib wird hier per taskdef (siehe unten) hinzugefügt. -->

	<!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!-- <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" />
	taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" />
	<taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" /> -->
 
	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	
<!-- ######## Scriptdefs ############################################################################--> 
<!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_errorHandlingJs" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnstring" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[			
			//Einfaches TryOut, wie man einen Fehler aus JavaScript zurückgeben kann.
			//Dabei wird in Java7 generell kein Stacking Objekt erzeugt und die Infos (z.B. die Zeilennummer) sind nicht so direkt abrufbar.
			//###############################################################################################################################
		
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var sReturn="";
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";
				
			//Die benoetigten Kernel-Funktionen laden
			var objKernelLibs = new Array();
			var objControlCaller=new Object();
			var bReturn = enableKernelAntJs(objKernelLibs, objControlCaller);
			if(!objControlCaller.bReturnControl){								
				bReturn=false;
				sReturn="";
			}else{			
				var sInputFilepath=attributes.get("inputfilepath");				
				sReturn=tryout_errorHandling(sInputFilepath, objKernelLibs, objControlCaller);		
				if(!objControlCaller.bReturnControl){									
					bReturn=false;
					sReturn="";
				}else{					
					bReturn=true;
				}
			}	
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			function enableKernelAntJs(objKernelLibs, objControl){
				var sScript = "enableKernelAntJs: ";
				
			    //Erstelle eine Array der grundlegenden JavaScript-Kernel Funktionen.
				//und lies dieses Array ein.
				var bReturn=false; 
				var bReturnControl=false;
				var sReturnControl="Fehler";						
				try{					
					objKernelLibs[0] = new Object();
					objKernelLibs[0]["ALIAS"] = "ReflectCode";
					objKernelLibs[0]["DIRECTORY"] = "jsscriptdef";
					objKernelLibs[0]["FILE"] = "ZAnt.basic.zBasic.ReflectCodeZZZ.js";

					objKernelLibs[1] = new Object();
					objKernelLibs[1]["ALIAS"] = "HandleError";
					objKernelLibs[1]["DIRECTORY"] = "jsscriptdef"; 
					objKernelLibs[1]["FILE"] = "ZAnt.basic.zBasic.HandleErrorZZZ.js";

					//REM Das Original aus dem grundlegendne Import-Tryout.
					//eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( 'tryoutAnt_ImportJavascriptJs.js' ) ) );
					for (var i = 0; i < objKernelLibs.length; i++) { 									
						//print("Lies Kernel Ant Js Bibliothek ein: '" + objKernelLibs[i]["ALIAS"]+"'"); 
						//for (var objEigenschaft in objKernelLibs[i]) {
						//	print("Eigenschaft: '" + objEigenschaft + " = " + objKernelLibs[i][objEigenschaft] + "'"); 							
						//}	
						
						//Merke: basedir im Ant-Projekt ist auf ".." gesetzt.
						//print("'../" + objKernelLibs[i]["DIRECTORY"] + "/" + objKernelLibs[i]["FILE"] +"'");																
						objKernelLibs[i]["LOADINGSTRING"] = "org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader(\"../"+objKernelLibs[i]["DIRECTORY"] + "/" + objKernelLibs[i]["FILE"]+"\"))";
						//print("objKernelLibs[i][LOADINGSTRING] = " + objKernelLibs[i]["LOADINGSTRING"]);
						objKernelLibs[i]["LOADER"] = eval(objKernelLibs[i]["LOADINGSTRING"]); //Der LOADER kann dann mit eval('' + eval(objKernelLibs[i]["LOADER"])) ausgeführt werden
						//Das ist dann etwas zuviel und funktioniert nicht... objKernelLibs[i]["CODEEXECUTED"] = eval('' + eval(objKernelLibs[i]["LOADER"])) ;						
					}
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k."
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
			
            //####################################################################################
			function tryout_errorHandling(sInputFilepath,objKernelLibs,objControl){																
				var sReturn="TEST sReturn";		
				var bReturnControl=false;
				var sReturnControl="Fehler";	
				try{
					//HIER DAS EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						eval('' + eval(objKernelLibs[i]["LOADER"])); //Man muss 2mal eval kombinieren, um den Loader-String einzusetzen.
					}
					var objControlCaller = new Object();
					var sScript = reflectMethodCurrent_Name(null, objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCallingName: " + objControlCaller.sReturnControl);
					sScript=sScript+": ";
					sReturnControl=sScript+"Fehler";
					print(sScript+"START");
				
					var sInputfilePath=attributes.get("inputfilepath");
					print("Startparameter: "+sInputFilepath);				
									
					if(sInputFilepath==''){
						var myError = new Error("Mein Testfehler aus JS wegen leerem Startparamter.");
						throw myError;
					}
					
					sReturn = "Test gefuellter Eingabeparameter.";
					bReturnControl=true;
					sReturnControl="Alles o.k.";
				}catch(err){
					//Funktioniert nicht mit Java7 (RHINO) gibt dort 0 zurück.
					print("TEST, neues ErrorObjekt erzeugen und direkt die Zeilennummer ausgeben: "  + (new Error).lineNumber);	
				
					//#### SIMPLES ERROR HANDLING #######									
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
		    }			
	      ]]>
  </scriptdef>				

  <!-- ############################################################-->
	<scriptdef name="tryout_reflectMethodCallingNameJs" language="javascript">		 
		 <attribute name="returnstring" />
		 <attribute name="returncontrol" />
		 <attribute name="returncontrolstring" />
		<!-- Hiermit testet man das Reflection Handling.
             Es wird ein Error Objekt erzeugt und daraus der Name der aktuellen Methode geholt.
			 Dies ist z.B. wichtig um genauere Log-Ausgaben zu erzeugen und den Code generisch zu halten -->
				
		<![CDATA[		
		    //attributes.get("inputParameter_denEsHierNichtGibt");
			
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var sReturn="";
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";
				
			//Die benoetigten Kernel-Funktionen laden
			var objKernelLibs = new Array();
			var objControlCaller=new Object();
			var bReturn = enableKernelAntJs(objKernelLibs, objControlCaller);
			if(!objControlCaller.bReturnControl){								
				bReturn=false;
				sReturn="";
			}else{				
				sReturn=tryout_reflectMethodCallingName(objKernelLibs, objControlCaller);
				if(!objControlCaller.bReturnControl){									
					bReturn=false;
					sReturn="";
				}else{					
					bReturn=true;
				}
			}	
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			function enableKernelAntJs(objKernelLibs, objControl){
				var sScript = "enableKernelAntJs: ";
				
			    //Erstelle eine Array der grundlegenden JavaScript-Kernel Funktionen.
				//und lies dieses Array ein.
				var bReturn=false; 
				var bReturnControl=false;
				var sReturnControl="Fehler";						
				try{					
					objKernelLibs[0] = new Object();
					objKernelLibs[0]["ALIAS"] = "ReflectCode";
					objKernelLibs[0]["DIRECTORY"] = "jsscriptdef";
					objKernelLibs[0]["FILE"] = "ZAnt.basic.zBasic.ReflectCodeZZZ.js";

					objKernelLibs[1] = new Object();
					objKernelLibs[1]["ALIAS"] = "HandleError";
					objKernelLibs[1]["DIRECTORY"] = "jsscriptdef"; 
					objKernelLibs[1]["FILE"] = "ZAnt.basic.zBasic.HandleErrorZZZ.js";

					//REM Das Original aus dem grundlegendne Import-Tryout.
					//eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( 'tryoutAnt_ImportJavascriptJs.js' ) ) );
					for (var i = 0; i < objKernelLibs.length; i++) { 									
						//print("Lies Kernel Ant Js Bibliothek ein: '" + objKernelLibs[i]["ALIAS"]+"'"); 
						//for (var objEigenschaft in objKernelLibs[i]) {
						//	print("Eigenschaft: '" + objEigenschaft + " = " + objKernelLibs[i][objEigenschaft] + "'"); 							
						//}	
						
						//Merke: basedir im Ant-Projekt ist auf ".." gesetzt.
						//print("'../" + objKernelLibs[i]["DIRECTORY"] + "/" + objKernelLibs[i]["FILE"] +"'");																
						objKernelLibs[i]["LOADINGSTRING"] = "org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader(\"../"+objKernelLibs[i]["DIRECTORY"] + "/" + objKernelLibs[i]["FILE"]+"\"))";
						//print("objKernelLibs[i][LOADINGSTRING] = " + objKernelLibs[i]["LOADINGSTRING"]);
						objKernelLibs[i]["LOADER"] = eval(objKernelLibs[i]["LOADINGSTRING"]); //Der LOADER kann dann mit eval('' + eval(objKernelLibs[i]["LOADER"])) ausgeführt werden
						//Das ist dann etwas zuviel und funktioniert nicht... objKernelLibs[i]["CODEEXECUTED"] = eval('' + eval(objKernelLibs[i]["LOADER"])) ;						
					}
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k."
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
			//#####################################################################################################			
			function tryout_reflectMethodCallingName(objKernelLibs, objControl){	               
				var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
				var bReturnControl=false;
				var sReturnControl="Fehler";	
				
				try{
					var objControlCaller=new Object();	
										
					//HIER DAS EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						eval('' + eval(objKernelLibs[i]["LOADER"])); //Man muss 2mal eval kombinieren, um den Loader-String einzusetzen.
					}		
					print("################################");
					print("### versuche reflectMethodCurrentName HIER auszufuehren");							
					var sScript = reflectMethodCurrent_Name(null, objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCallingName: " + objControlCaller.sReturnControl);
					sScript=sScript+": ";
					sReturnControl=sScript+"Fehler";		
					print("Ausgefuehrt. Name der aktuellen Funktion: "+sScript);
					print("################################");
					
					print("################################");
					print("### versuche reflectMethodCallingName IN EINER UNTERFUNKTION auszufuehren");		
					sReturn = tryout_Sub01_Calling(objKernelLibs, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
					print("Ausgefuehrt. Name der aktuellen Funktion, aus der Unterfunkton ermittelt: "+sReturn);
					print("################################");
					
					sReturnControl="Alles o.k."
					bReturnControl=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}
			
			function tryout_Sub01_Calling(objKernelLibs, objControl){
				var sReturn="nix"; //Ziel: Den Namen der aufrufenden funktin (also nicht dier dieser tryout_Sub01 Funktion) auf Ant-Script Ebene zu erhalten.
				var bReturnControl=false;
				var sReturnControl="Fehler";
				try{
					var objControlCaller=new Object();
									
                    //HIER DAS EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG					
					for (var i = 0; i < objKernelLibs.length; i++) { 						
						eval('' + eval(objKernelLibs[i]["LOADER"])); //Man muss 2mal eval kombinieren, um den Loader-String einzusetzen.
					}		
					
					var sScript = reflectMethodCurrent_Name(null, objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCurrentName: " + objControlCaller.sReturnControl);
					sScript=sScript+": ";
					sReturnControl=sScript+"Fehler";						
					print("Name der aktuellen (Unter-)Funktion: "+sScript);			
								
					print("Namen der aufrufenden Funktion holen...");
					var sCalling = reflectMethodCalling_Name(null, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					print("Name der aufrufenden Funktion: "+sCalling);	
					
					sReturn=sCalling;
					bReturnControl=true;
					sReturnControl="Alles o.k.";
				}catch(err){
					//Funktioniert nicht mit Java7 (RHINO) gibt dort 0 zurück.
					print("TEST, neues ErrorObjekt erzeugen und direkt die Zeilennummer ausgeben: "  + (new Error).lineNumber);	

				
					//#### SIMPLES ERROR HANDLING #######									
					print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}			
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}
		]]>
	</scriptdef>
  
<!-- ############################################################-->
	 <scriptdef name="tryout_reflectMethodCurrentNameJs" language="javascript">		 
		 <attribute name="returnstring" />
		 <attribute name="returncontrol" />
		 <attribute name="returncontrolstring" />
		<!-- Hiermit testet man das Reflection Handling.
             Es wird ein Error Objekt erzeugt und daraus der Name der aktuellen Methode geholt.
			 Dies ist z.B. wichtig um genauere Log-Ausgaben zu erzeugen und den Code generisch zu halten -->
				
		<![CDATA[		
		    //attributes.get("inputParameter_denEsHierNichtGibt");
			
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objControl=new Object();
			var sReturn=tryout_reflectMethodCurrentName(objControl);			
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),objControl.bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),objControl.sReturnControl);
						
			function tryout_reflectMethodCurrentName(objControl){	
                var sScript ="tryout_reflectMethodCurrentName"; //Falls in diesem Test ein Fehler auftritt wird trotzdem die Scriptfunkton als Name ausgegeben.			
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";				
				try{
					print("#######################");
					
					//dito.. in Java7
					//var objError = errorTraced();
					//var caller_line = objError.stack.split("\n")[1];
					
					//dito.. in Java7
					//var stack_trace=stackTrace();
					//var caller_line = stack_trace.split("\n")[1];
				
					//Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					//var stack_trace=createStackTrace();
					//var caller_line = stack_trace[0];
					//print("yyyyyyyyyy" + caller_line);
					
					//Java7: Weil es kein Error objekt mit Stactrace gibt, kann man es sich sparen 
					//sReturn = reflectMethodCurrent_Name(objError, objControl);					
					
					
					var objError = new Error();	//Das bekommt keinen Stacktrace Java 7. Bei der weiteren Verarbeitung beachten
					sReturn=reflectMethodCurrent_Name(objError, objControl);					
					if(!objControl.bReturnControl) throw new Error("tryout_reflectMethodCurrentName: " + objControl.sReturnControl);
					
					sReturnControl="Alles o.k."
					bReturnControl=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}
			
		//###############################################################
			//### REFLECTION 
			//###############################################################
			function reflectMethodCurrent_Name(myError, objControl){
				var sScript="reflectMethodCurrent_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				try{	                    
					var objControlCaller = new Object();
					var sLine=reflectMethodCurrent_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					//print(sScript +"sLine="+sLine);
												
					var sMethod=reflectMethod_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
				
			//#################################################################
			function reflectMethodCurrent_StackLine(myError, objControl){
				var sScript="reflectMethodCurrent_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";				
				try{
					var objControlCaller = new Object();
				    //Java7 funktioniert -	var sCallerLine=reflectMethod_StackLine(myError, 3, objControlCaller);
					//Java8 Fall, ohne übergebenen Error Objekt. Dann muss nämlich der Stack erst errechnet werden: funktioniert mit zwei weiteren Indexpositionen mehr!
					//                                                                 var sCallerLine=reflectMethod_StackLine(myError, 5, objControlCaller);					
					var iIndex = getStackLineIndexCurrent(objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					var sCallerLine=reflectMethod_StackLine(myError, iIndex, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
			function getStackLineIndexCurrent(objControl){
				var sScript="getStackLineIndex: ";
				var iReturn=-1;
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";				
				try{
					var objControlCaller = new Object();
				   var bIsJava7 = isJava7(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//Die Indexposition ist verschieden, sowohl wg. eines anders aussehenden Stacktraces als auch wg. mehr aufgerufener Funktionen, diesen auszuwerten.
					if(bIsJava7){
						iIndex=3;
					}else{
						iIndex=5;
					}
					print(sScript+"iIndex="+iIndex);
					iReturn=iIndex;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return iReturn;
			
			}
			
			
			//#################################################################
			function reflectMethodCalling_Name(myError, objControl){
				var sScript="reflectMethodCalling_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				var objControlCaller = new Object();
				try{	
                    var sMethod="";							
					
					var sLine=reflectMethodCalling_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					//print(sScript +"sMethodCallingLine="+sLine);
												
					sMethod=reflectMethod_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
			
			//#################################################################
			function reflectMethodCalling_StackLine(myError, objControl){
				var sScript="reflectMethodCalling_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
				try{
					var objControlCaller = new Object();
				    //Java7: funktioniert? var sCallerLine=reflectMethod_StackLine(myError,4, objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					//Java8 Fall funktioniert, ohne übergebenen Error Objekt. Dann muss nämlich der Stack erst errechnet werden: funktioniert mit zwei weiteren mehr? 
					//                                                                                   var sCallerLine=reflectMethod_StackLine(myError,6,objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					
					var iIndex = getStackLineIndexCurrent(objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					var iIndexCalling = iIndex + 1;
					
					var sCallerLine=reflectMethod_StackLine(myError,iIndexCalling, objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
										
					//print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
						
	//#####################################################################
	//### REFLECTION-COMMON Funktionen, sowohl für current als auch für calling Methodennamen
	//#####################################################################
			function reflectMethod_StackLine(myError, iIndex, objControl){
				var sScript="reflectMethod_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
								
				try{
				    var sCallerLine="";
					
					if(iIndex=='undefined' || iIndex==null){
						iIndex=3;//-1 wg. Index an sich, -1 weil es eine Unterfunktion entweder von ....current oder ...calling ist, -2 wg. der Tatsache, dass man DIESE Funktion nicht haben will, sondern die aufrufende.
					}					
				
					var objControlCaller = new Object();
					var bIsJava7=isJava7(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//Merke Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					//ACHTUNG: Wir Suchen als Funktion das VORLETZTE Element in dem Array
					if(bIsJava7){		
						print(sScript+"7: Ausfuehrung unter Java7");					
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								print(sScript+"7: Stack im Error Objekt vorhanden");
								var saStacktrace = myError.stack.split("\n");						
								//print(sScript + "7: Vorhandener StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								//print(sScript + "7: iuBound="+iuBound);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}
								sCallerLine = saStacktrace[(iIndex)];
							} else {
								//Normal in Java7, da kein Stacktrace im error-objekt vorhanden ist.
								print(sScript+"7: KEIN Stack im Error Objekt vorhanden");
								var saStacktrace=createStackTrace();
								//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								//print(sScript + "7: iuBound="+iuBound);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}
								sCallerLine = saStacktrace[(iIndex)];
							}				
						}else{
							print(sScript+"7: KEIN Error Objekt vorhanden");
							var saStacktrace=createStackTrace();
							//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
							var iuBound=saStacktrace.length-1;
							//print(sScript + "7: iuBound="+iuBound);
							if(iIndex>iuBound){
								iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
							}
							sCallerLine = saStacktrace[(iIndex)];
						}					
					}else{
						print(sScript+"8: Ausfuehrung unter Java8");
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								//Java 8, NASHORN funktioniert.
								print(sScript + "8: Error Stack vorhanden");
								//print(sScript + "8: Error Stack=" + myError.stack);
								var saStacktrace = myError.stack.split("\n");
								print(sScript + "8: Gefundener StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}			
								var iIndexToBeUsed=1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
								sCallerLine = saStacktrace[(iIndexToBeUsed)];
							} else {
								//Ungewöhnlich in Java 8 - wenn kein error-objekt vorhanden ist, vermutlich wurde kein Error Objekt übergeben.
								print(sScript + "8: KEIN Error Stack vorhanden OBWOHL Error Objekt vorhanden ist.");														
								var stack=createStackTrace();
								var saStacktrace = stack.split("\n");
								print(sScript + "8: Erstellter StackTrace=" + saStacktrace);	
								var iuBound=saStacktrace.length-1;									
								print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}									
								var iIndexToBeUsed=iIndex+1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
								sCallerLine = saStacktrace[(iIndexToBeUsed)];
							}				
						}else{
							//Vermutlich Java7, da kein Stacktrace im error-objekt vorhanden ist.
							print(sScript + "8 ohne ErrorObjekt");
							
							var stack=createStackTrace();
							var saStacktrace = stack.split("\n");
							print(sScript + "8 ohne ErrorObjekt=" + saStacktrace);	
							var iuBound=saStacktrace.length-1;
							print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
							if(iIndex>iuBound){
								iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
							}								
							var iIndexToBeUsed=iIndex;
							print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
							sCallerLine = saStacktrace[(iIndexToBeUsed)];
						}
					}
					print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethod_StackLine
	
	//#################################################################
	function reflectMethod_StackMethodFromLine(sStackLine, objControl){
		var sScript="reflectMethod_StackMethodFromLine: ";
		var sReturn = sStackLine;					
		var bReturnControl=false;
		var sReturnControl=sScript+"Fehler";
		try {
			if(undefined==sStackLine || null==sStackLine) throw new Error(sScript+"Parameter Stacktrace-Zeile fehlt.");
												
			var objControlCaller=new Object();
			var bJava7=isJava7(objControlCaller);					
			if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
			
			var clean2="";
			if(bJava7){
				//print(sScript+"Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf(" (");
				var clean = sStackLine.slice(index+2, sStackLine.length);
				
				var index2 = clean.indexOf(")");							
				if(index2>=1){
					clean2 = clean.substring(0,index2).trim();
				}else{
					clean2 = clean.trim();
				}			
			} else {
				//Java8
				//print(sScript+"NICHT Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf("at ");
				//print(sScript+"index="+index);
				var clean = sStackLine.slice(index+2, sStackLine.length);						
				//print(sScript+"clean="+clean);
				
				
				index = clean.indexOf(" (");
				var clean = clean.substring(0,index);
				//print(sScript+"clean="+clean);
				
				clean2 = clean.trim();
			}
			sReturn=clean2;					
			bReturnControl=true;
			sReturnControl=sScript + "Alles o.k.";
		}catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		objControl.bReturnControl=bReturnControl;
		objControl.sReturnControl=sReturnControl;								
		print(sScript+"sReturn="+sReturn);
		return sReturn;
	}//End function reflectMethod_StackMethodFromLine
			
    //#########################################
	//### Hilfsfunktion zur Generierung eines Stacktraces. Als Workaround für Java7. 
	//#########################################			
	function createStackTrace() {
	  var sScript="createStackTrace: ";
	  var callstack = [];
	  var isCallstackPopulated = false;
	  try{
		var objControlCaller=new Object();
		var bJava7=isJava7(objControlCaller);					
		if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
		
if(bJava7){		
	   print(sScript+"Java7 Fall");
	  //+++ Java7 Fall
	  try {
		i.dont.exist+=0; //doesn't exist- that's the point
	  } catch(e) {
		if (e.stack) { //Firefox
			//print("ffox");
			//print(e.stack);
		  var lines = e.stack.split('\n');
		  for (var i=0, len=lines.length; i<=len-1; i++) {
			//print(i + ": '" + lines[i].trim() +"'");
			//klappt hier nicht....  if (lines[i].trim().match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			if (lines[i].trim()!=''){
			  //print("line used");
			  callstack.push(lines[i]);
			}else		 {
			  //print("empty line NOT used");  				
			}
		  }
		  
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
		else if (window.opera && e.message) { //Opera
			print("opera  untested");
		  var lines = e.message.split('\n');
		  for (var i=0, len=lines.length; i<len; i++) {
			if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			  var entry = lines[i];
			  //Append next line also since it has the file info
			  if (lines[i+1]) {
				entry += ' at ' + lines[i+1];
				i++;
			  }
			  callstack.push(entry);
			}
		  }
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
	  }
	  if (!isCallstackPopulated) { //IE and Safari
		print("ie untested");
		var currentFunction = arguments.callee.caller;
		while (currentFunction) {
		  var fn = currentFunction.toString();
		  var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('')) || 'anonymous';
		  callstack.push(fname);
		  currentFunction = currentFunction.caller;
		}
	  }
	  //+++ ENDE Java7 Fall
	  //+++ START Java8 Fall
	  }else{
		print(sScript+"Java8 Fall");
		try {
			var objError = new Error();
			callstack=objError.stack;
		} catch(e) {
		
		}
	  
	  
	  }
	  }catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		//+++ ENDE Java8 Fall
	  
	  output(sScript, callstack);
	  return callstack;
	}

	function output(sScript, arr) {
	  //Optput however you want
	  //alert(arr.join('\n\n'));
	  print(sScript +"arr="+ arr);
	  //print(arr.join('\n\n'));
	}			
			
			
			
	//#############################################
    //### Hilfsfunktion JAVA
	//#############################################	
		function isJava7(objControl){	
			var sScript="isJava7: ";
			var bReturn = false;
			var bReturnControl=false;
			var sReturnControl=sScript+"Fehler";
			try {			
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				if(version.substring(0,3)=="1.7"){
					bJava7found=true;
				}else {
					bJava7found=false;
				}
				
				bReturn=bJava7found;
				bReturnControl=true;
				sReturnControl=sScript + "Alles o.k.";
			}catch(err){
				//#### SIMPLES ERROR HANDLING #######
				//print(err);					
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;					
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;								
			return bReturn;
		}//End function isJava7
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
					print("Verwende das alte Rhino unter Java 8");
				}catch(e){
					print("Verwende Standard JavaScript Engine dieser Java Vesion.");
				}
			}//End function enableJava
			
								
				//##################################################################
				//### Tryouts den Stacktrace vom Error objekt zu bekommen
				//##################################################################

				//produziert in Java7 KEINEN Stacktrace
				function errorTraced() {
				  try {
					var err = new Error("test01");
					throw err;
				  } catch (err) {
					print("ddddd " + err);
					//print(err.rhinoException.printStackTrace());
					print(err.stack);
					return err;
				  }
				}
				
				//produziert in Java7 KEINEN Stacktrace
				function stackTrace() {
				  try {
					var err = new Error("test02");
					throw err;
				  } catch (err) {
					print("eeee " + err);
					//print(err.rhinoException.printStackTrace());
					print(err.stack);
					return err.stack;
				  }
				}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="tryout_reflectMethodCurrentNameFromSubJs" language="javascript">		 
		 <attribute name="returnstring" />
		 <attribute name="returncontrol" />
		 <attribute name="returncontrolstring" />
		<!-- Hiermit testet man das Reflection Handling.
             Es wird ein Error Objekt erzeugt und daraus der Name der aktuellen Methode geholt.
			 Dies ist z.B. wichtig um genauere Log-Ausgaben zu erzeugen und den Code generisch zu halten -->
				
		<![CDATA[		
		    //attributes.get("inputParameter_denEsHierNichtGibt");
			
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objControl=new Object();
			var sReturn=tryout_reflectMethodCurrentNameFromSub(objControl);			
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),objControl.bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),objControl.sReturnControl);
						
			function tryout_reflectMethodCurrentNameFromSub(objControl){	               
				var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
				var bReturnControl=false;
				var sReturnControl="Fehler";						
				try{
					print("#######################");
					var objControlCaller=new Object();				
					var sScript = reflectMethodCurrent_Name(null, objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCurrentName: " + objControlCaller.sReturnControl);
					sScript=sScript+": ";
					sReturnControl=sScript+"Fehler";		
					print("Name der aktuellen Funktion: "+sScript);
					
					sReturn = tryout_Sub01_Current(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCurrentName: " + objControlCaller.sReturnControl);
					
					sReturnControl="Alles o.k."
					bReturnControl=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}
			
			function tryout_Sub01_Current(objControl){
				var sReturn="nix"; //Ziel: Den Namen der aufrufenden funktin (also nicht dier dieser tryout_Sub01 Funktion) auf Ant-Script Ebene zu erhalten.
				var bReturnControl=false;
				var sReturnControl="Fehler";						
				try{
					print("#######################");
					var objControlCaller=new Object();
					var sScript = reflectMethodCurrent_Name(null, objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCurrentName: " + objControlCaller.sReturnControl);
					sScript=sScript+": ";
					sReturnControl=sScript+"Fehler";		
					print("Name der aktuellen (Unter-)Funktion: "+sScript);			
													
					sReturn=sScript;
					bReturnControl=true;
					sReturnControl="Alles o.k.";
				}catch(err){
					//Funktioniert nicht mit Java7 (RHINO) gibt dort 0 zurück.
					print("TEST, neues ErrorObjekt erzeugen und direkt die Zeilennummer ausgeben: "  + (new Error).lineNumber);	

				
					//#### SIMPLES ERROR HANDLING #######									
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
					
				
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}
			
			//###############################################################
			//### REFLECTION 
			//###############################################################
			function reflectMethodCurrent_Name(myError, objControl){
				var sScript="reflectMethodCurrent_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				try{	                    
					var objControlCaller = new Object();
					var sLine=reflectMethodCurrent_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					//print(sScript +"sLine="+sLine);
												
					var sMethod=reflectMethod_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
				
			//#################################################################
			function reflectMethodCurrent_StackLine(myError, objControl){
				var sScript="reflectMethodCurrent_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";				
				try{
					var objControlCaller = new Object();
				    //Java7 funktioniert -	var sCallerLine=reflectMethod_StackLine(myError, 3, objControlCaller);
					//Java8 Fall, ohne übergebenen Error Objekt. Dann muss nämlich der Stack erst errechnet werden: funktioniert mit zwei weiteren Indexpositionen mehr!
					//                                                                 var sCallerLine=reflectMethod_StackLine(myError, 5, objControlCaller);					
					var iIndex = getStackLineIndexCurrent(objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					var sCallerLine=reflectMethod_StackLine(myError, iIndex, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
			function getStackLineIndexCurrent(objControl){
				var sScript="getStackLineIndex: ";
				var iReturn=-1;
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";				
				try{
					var objControlCaller = new Object();
				   var bIsJava7 = isJava7(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//Die Indexposition ist verschieden, sowohl wg. eines anders aussehenden Stacktraces als auch wg. mehr aufgerufener Funktionen, diesen auszuwerten.
					if(bIsJava7){
						iIndex=3;
					}else{
						iIndex=5;
					}
					print(sScript+"iIndex="+iIndex);
					iReturn=iIndex;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return iReturn;
			
			}
			
			
			//#################################################################
			function reflectMethodCalling_Name(myError, objControl){
				var sScript="reflectMethodCalling_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				var objControlCaller = new Object();
				try{	
                    var sMethod="";							
					
					var sLine=reflectMethodCalling_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					//print(sScript +"sMethodCallingLine="+sLine);
												
					sMethod=reflectMethod_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
			
			//#################################################################
			function reflectMethodCalling_StackLine(myError, objControl){
				var sScript="reflectMethodCalling_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
				try{
					var objControlCaller = new Object();
				    //Java7: funktioniert? var sCallerLine=reflectMethod_StackLine(myError,4, objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					//Java8 Fall funktioniert, ohne übergebenen Error Objekt. Dann muss nämlich der Stack erst errechnet werden: funktioniert mit zwei weiteren mehr? 
					//                                                                                   var sCallerLine=reflectMethod_StackLine(myError,6,objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					
					var iIndex = getStackLineIndexCurrent(objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					var iIndexCalling = iIndex + 1;
					
					var sCallerLine=reflectMethod_StackLine(myError,iIndexCalling, objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
										
					//print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
						
	//#####################################################################
	//### REFLECTION-COMMON Funktionen, sowohl für current als auch für calling Methodennamen
	//#####################################################################
			function reflectMethod_StackLine(myError, iIndex, objControl){
				var sScript="reflectMethod_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
								
				try{
				    var sCallerLine="";
					
					if(iIndex=='undefined' || iIndex==null){
						iIndex=3;//-1 wg. Index an sich, -1 weil es eine Unterfunktion entweder von ....current oder ...calling ist, -2 wg. der Tatsache, dass man DIESE Funktion nicht haben will, sondern die aufrufende.
					}					
				
					var objControlCaller = new Object();
					var bIsJava7=isJava7(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//Merke Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					//ACHTUNG: Wir Suchen als Funktion das VORLETZTE Element in dem Array
					if(bIsJava7){		
						print(sScript+"7: Ausfuehrung unter Java7");					
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								print(sScript+"7: Stack im Error Objekt vorhanden");
								var saStacktrace = myError.stack.split("\n");						
								//print(sScript + "7: Vorhandener StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								//print(sScript + "7: iuBound="+iuBound);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}
								sCallerLine = saStacktrace[(iIndex)];
							} else {
								//Normal in Java7, da kein Stacktrace im error-objekt vorhanden ist.
								print(sScript+"7: KEIN Stack im Error Objekt vorhanden");
								var saStacktrace=createStackTrace();
								//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								//print(sScript + "7: iuBound="+iuBound);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}
								sCallerLine = saStacktrace[(iIndex)];
							}				
						}else{
							print(sScript+"7: KEIN Error Objekt vorhanden");
							var saStacktrace=createStackTrace();
							//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
							var iuBound=saStacktrace.length-1;
							//print(sScript + "7: iuBound="+iuBound);
							if(iIndex>iuBound){
								iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
							}
							sCallerLine = saStacktrace[(iIndex)];
						}					
					}else{
						print(sScript+"8: Ausfuehrung unter Java8");
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								//Java 8, NASHORN funktioniert.
								print(sScript + "8: Error Stack vorhanden");
								//print(sScript + "8: Error Stack=" + myError.stack);
								var saStacktrace = myError.stack.split("\n");
								print(sScript + "8: Gefundener StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}			
								var iIndexToBeUsed=1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
								sCallerLine = saStacktrace[(iIndexToBeUsed)];
							} else {
								//Ungewöhnlich in Java 8 - wenn kein error-objekt vorhanden ist, vermutlich wurde kein Error Objekt übergeben.
								print(sScript + "8: KEIN Error Stack vorhanden OBWOHL Error Objekt vorhanden ist.");														
								var stack=createStackTrace();
								var saStacktrace = stack.split("\n");
								print(sScript + "8: Erstellter StackTrace=" + saStacktrace);	
								var iuBound=saStacktrace.length-1;									
								print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}									
								var iIndexToBeUsed=iIndex+1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
								sCallerLine = saStacktrace[(iIndexToBeUsed)];
							}				
						}else{
							//Vermutlich Java7, da kein Stacktrace im error-objekt vorhanden ist.
							print(sScript + "8 ohne ErrorObjekt");
							
							var stack=createStackTrace();
							var saStacktrace = stack.split("\n");
							print(sScript + "8 ohne ErrorObjekt=" + saStacktrace);	
							var iuBound=saStacktrace.length-1;
							print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
							if(iIndex>iuBound){
								iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
							}								
							var iIndexToBeUsed=iIndex;
							print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
							sCallerLine = saStacktrace[(iIndexToBeUsed)];
						}
					}
					print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethod_StackLine
	
	//#################################################################
	function reflectMethod_StackMethodFromLine(sStackLine, objControl){
		var sScript="reflectMethod_StackMethodFromLine: ";
		var sReturn = sStackLine;					
		var bReturnControl=false;
		var sReturnControl=sScript+"Fehler";
		try {
			if(undefined==sStackLine || null==sStackLine) throw new Error(sScript+"Parameter Stacktrace-Zeile fehlt.");
												
			var objControlCaller=new Object();
			var bJava7=isJava7(objControlCaller);					
			if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
			
			var clean2="";
			if(bJava7){
				//print(sScript+"Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf(" (");
				var clean = sStackLine.slice(index+2, sStackLine.length);
				
				var index2 = clean.indexOf(")");							
				if(index2>=1){
					clean2 = clean.substring(0,index2).trim();
				}else{
					clean2 = clean.trim();
				}			
			} else {
				//Java8
				//print(sScript+"NICHT Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf("at ");
				//print(sScript+"index="+index);
				var clean = sStackLine.slice(index+2, sStackLine.length);						
				//print(sScript+"clean="+clean);
				
				
				index = clean.indexOf(" (");
				var clean = clean.substring(0,index);
				//print(sScript+"clean="+clean);
				
				clean2 = clean.trim();
			}
			sReturn=clean2;					
			bReturnControl=true;
			sReturnControl=sScript + "Alles o.k.";
		}catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		objControl.bReturnControl=bReturnControl;
		objControl.sReturnControl=sReturnControl;								
		print(sScript+"sReturn="+sReturn);
		return sReturn;
	}//End function reflectMethod_StackMethodFromLine
			
    //#########################################
	//### Hilfsfunktion zur Generierung eines Stacktraces. Als Workaround für Java7. 
	//#########################################			
	function createStackTrace() {
	  var sScript="createStackTrace: ";
	  var callstack = [];
	  var isCallstackPopulated = false;
	  try{
		var objControlCaller=new Object();
		var bJava7=isJava7(objControlCaller);					
		if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
		
if(bJava7){		
	   print(sScript+"Java7 Fall");
	  //+++ Java7 Fall
	  try {
		i.dont.exist+=0; //doesn't exist- that's the point
	  } catch(e) {
		if (e.stack) { //Firefox
			//print("ffox");
			//print(e.stack);
		  var lines = e.stack.split('\n');
		  for (var i=0, len=lines.length; i<=len-1; i++) {
			//print(i + ": '" + lines[i].trim() +"'");
			//klappt hier nicht....  if (lines[i].trim().match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			if (lines[i].trim()!=''){
			  //print("line used");
			  callstack.push(lines[i]);
			}else		 {
			  //print("empty line NOT used");  				
			}
		  }
		  
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
		else if (window.opera && e.message) { //Opera
			print("opera  untested");
		  var lines = e.message.split('\n');
		  for (var i=0, len=lines.length; i<len; i++) {
			if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			  var entry = lines[i];
			  //Append next line also since it has the file info
			  if (lines[i+1]) {
				entry += ' at ' + lines[i+1];
				i++;
			  }
			  callstack.push(entry);
			}
		  }
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
	  }
	  if (!isCallstackPopulated) { //IE and Safari
		print("ie untested");
		var currentFunction = arguments.callee.caller;
		while (currentFunction) {
		  var fn = currentFunction.toString();
		  var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('')) || 'anonymous';
		  callstack.push(fname);
		  currentFunction = currentFunction.caller;
		}
	  }
	  //+++ ENDE Java7 Fall
	  //+++ START Java8 Fall
	  }else{
		print(sScript+"Java8 Fall");
		try {
			var objError = new Error();
			callstack=objError.stack;
		} catch(e) {
		
		}
	  
	  
	  }
	  }catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		//+++ ENDE Java8 Fall
	  
	  output(sScript, callstack);
	  return callstack;
	}

	function output(sScript, arr) {
	  //Optput however you want
	  //alert(arr.join('\n\n'));
	  print(sScript +"arr="+ arr);
	  //print(arr.join('\n\n'));
	}			
			
			
			
	//#############################################
    //### Hilfsfunktion JAVA
	//#############################################	
		function isJava7(objControl){	
			var sScript="isJava7: ";
			var bReturn = false;
			var bReturnControl=false;
			var sReturnControl=sScript+"Fehler";
			try {			
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				if(version.substring(0,3)=="1.7"){
					bJava7found=true;
				}else {
					bJava7found=false;
				}
				
				bReturn=bJava7found;
				bReturnControl=true;
				sReturnControl=sScript + "Alles o.k.";
			}catch(err){
				//#### SIMPLES ERROR HANDLING #######
				//print(err);					
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;					
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;								
			return bReturn;
		}//End function isJava7
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
					print("Verwende das alte Rhino unter Java 8");
				}catch(e){
					print("Verwende Standard JavaScript Engine dieser Java Vesion.");
				}
			}//End function enableJava
			
								
				//##################################################################
				//### Tryouts den Stacktrace vom Error objekt zu bekommen
				//##################################################################

				//produziert in Java7 KEINEN Stacktrace
				function errorTraced() {
				  try {
					var err = new Error("test01");
					throw err;
				  } catch (err) {
					print("ddddd " + err);
					//print(err.rhinoException.printStackTrace());
					print(err.stack);
					return err;
				  }
				}
				
				//produziert in Java7 KEINEN Stacktrace
				function stackTrace() {
				  try {
					var err = new Error("test02");
					throw err;
				  } catch (err) {
					print("eeee " + err);
					//print(err.rhinoException.printStackTrace());
					print(err.stack);
					return err.stack;
				  }
				}
		]]>
	</scriptdef>

	   
       
     
<!-- ################################################################################# -->
	<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!-- <target name="compile" depends="-myTestStringExplode,-myTestStringSubstring,-myTestStringLeftString,-myTestStringRightString,-myTestStringLeftBackString,-myTestStringContainsString,-myTestStringCountString"> -->
 <!-- TODO Test für stringUnencodeJsZZZ und stringEncodeJsZZZ -->
 <!--<target name="compile" depends="-myTestReflectMethodCurrentNameJs,-myTestReflectMethodCurrentNameFromSubJs,-myTestReflectMethodCallingNameJs,-myTryoutJavaScript_ErrorHandling, ">-->
 <target name="compile" depends="-myTryoutJavaScript_ErrorHandling">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-myTryoutJavaScript_ErrorHandling">
		<fl:let>sScript::='-myTryoutJavaScript_ErrorHandling: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		 <fl:let>myInputFilepath::="c:\\temp"</fl:let>
		 <echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_errorHandlingJs inputfilepath="${myInputFilepath}" returnstring="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		  <fl:let>myInputFilepath::=""</fl:let>
		  <echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_errorHandlingJs inputfilepath="${myInputFilepath}" returnstring="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
		</trycatch>		
	</target>
  
  
  <target name="-myTestReflectMethodCurrentNameJs">
		<fl:let>sScript::='-myTestReflectMethodCurentNameJs: '</fl:let>
		<echo>${sScript}Start</echo>
		<!--<ac:var name="myReturnControl" value="false" unset="true"/>-->
		<!--<ac:var name="myReturnControlString" value="Fehler" unset="true"/>-->
		<fl:let>myReturnControl::=false</fl:let>
		<fl:let>myReturnControlString::="Fehler"</fl:let>
		<echo message="1. myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->		
		<tryout_reflectMethodCurrentNameJs returnstring="myReturnString" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" />
		<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="Ermittelter Methodenname = ${myReturnString}" />
		<echo message="############################" />
				
	</target> 
	
	<target name="-myTestReflectMethodCurrentNameFromSubJs">
		<fl:let>sScript::='-myTestReflectMethodCurrentNameFormSubNameJs: '</fl:let>
		<echo>${sScript}Start</echo>
		<!--<ac:var name="myReturnControl" value="false" unset="true"/>-->
		<!--<ac:var name="myReturnControlString" value="Fehler" unset="true"/>-->
		<fl:let>myReturnControl::=false</fl:let>
		<fl:let>myReturnControlString::="Fehler"</fl:let>
		<echo message="1. myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->		
		<tryout_reflectMethodCurrentNameFromSubJs returnstring="myReturnString" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" />
		<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="In der Unterfunktion ermittelter Methodenname der aufrufenden Funktion= ${myReturnString}" />
		<echo message="############################" />
				
	</target> 
	
	<target name="-myTestReflectMethodCallingNameJs">
		<fl:let>sScript::='-myTestReflectMethodCallingNameJs: '</fl:let>
		<echo>${sScript}Start</echo>
		<!--<ac:var name="myReturnControl" value="false" unset="true"/>-->
		<!--<ac:var name="myReturnControlString" value="Fehler" unset="true"/>-->
		<fl:let>myReturnControl::=false</fl:let>
		<fl:let>myReturnControlString::="Fehler"</fl:let>
		<echo message="1. myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->		
		<tryout_reflectMethodCallingNameJs returnstring="myReturnString" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" />
		<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="In der Unterfunktion ermittelter Name der aktuellen Funktion= ${myReturnString}" />
		<echo message="############################" />
				
	</target> 
 </project>