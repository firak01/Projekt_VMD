<?xml version="1.0" encoding="UTF-8" ?>  
<project name="test_ReflectionHandlingJsZZZ"   default="compile" basedir=".."
	xmlns:fl="antlib:it.haefelinger.flaka" 
	xmlns:ac="antlib://net/sf/antcontrib"><!-- damit definiert man für antcontrib , bzw. FLAKA einen eigenen Namespace. Antcontrib wird hier per taskdef (siehe unten) hinzugefügt. -->

	<!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!-- <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" />
	taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" />
	<taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" /> -->
 
	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	
<!-- ######## Scriptdefs ############################################################################--> 
<!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_errorHandlingJs" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnstring" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[			
			//Einfaches TryOut, wie man einen Fehler aus JavaScript zurückgeben kann.
			//Dabei wird in Java7 generell kein Stacking Objekt erzeugt und die Infos (z.B. die Zeilennummer) sind nicht so direkt abrufbar.
			var sInputFilepath=attributes.get("inputfilepath");
			print("Startparameter: "+sInputFilepath);
			var bReturnControl=attributes.get("returncontrol");
			var sReturnControl=attributes.get("returncontrolstring");
			
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objControl=new Object();
			objControl.sReturnControl=sReturnControl;
			objControl.bReturnControl=bReturnControl;
						
			var sReturn=tryout_errorHandling(sInputFilepath,objControl);		
			
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),objControl.bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),objControl.sReturnControl);	

			function tryout_errorHandling(sInputFilepath,objControl){
				print("Start (jetzt ohne sScript zu definieren. Dies soll ja errechnet werden).");
				sInputfilePath=attributes.get("inputfilepath");
				print("Startparameter: "+sInputFilepath);				
				var sReturn="TEST sReturn";		
				var bReturnControl=false;
				var sReturnControl="Fehler.";		
				try{			
					if(sInputFilepath==''){
						var myError = new Error("Mein Testfehler aus JS");
						throw myError;
					}else{
						sReturn = "Test gefuellter Eingabeparameter.";
						bReturnControl=true;
						sReturnControl="Alles o.k.";
					}
				}catch(anErr){
					//Funktioniert nicht mit Java7 (RHINO) gibt dort 0 zurück.
					print("TEST, neues ErrorObjekt erzeugen und direkt die Zeilennummer ausgeben: "  + (new Error).lineNumber);	
					bReturnControl=false;
					sReturnControl=anErr;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
		    }			
	      ]]>
  </scriptdef>				

<!-- ############################################################-->
	 <scriptdef name="tryout_reflectMethodCurrentNameJs" language="javascript">		 
		 <attribute name="returnstring" />
		 <attribute name="returncontrol" />
		 <attribute name="returncontrolstring" />
		<!-- Hiermit testet man das Reflection Handling.
             Es wird ein Error Objekt erzeugt und daraus der Name der aktuellen Methode geholt.
			 Dies ist z.B. wichtig um genauere Log-Ausgaben zu erzeugen und den Code generisch zu halten -->
				
		<![CDATA[		
		    var bReturnControl=project.getProperty(attributes.get("returncontrol"));
			var sReturnControl=project.getProperty(attributes.get("returncontrolstring"));
			
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objControl=new Object();
			objControl.sReturnControl=sReturnControl;
			objControl.bReturnControl=bReturnControl;
			var sReturn=tryout_reflectMethodCurrentName(objControl);			
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),objControl.bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),objControl.sReturnControl);
						
			function tryout_reflectMethodCurrentName(objControl){
				print("Start (jetzt ohne sScript zu definieren. Dies soll ja errechnet werden.");
				var sReturn="";				
				try{
					
					//dito.. in Java7
					//var objError = errorTraced();
					//var caller_line = objError.stack.split("\n")[1];
					
					//dito.. in Java7
					//var stack_trace=stackTrace();
					//var caller_line = stack_trace.split("\n")[1];
				
					//Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					//var stack_trace=createStackTrace();
					//var caller_line = stack_trace[0];
					//print("yyyyyyyyyy" + caller_line);
					
					//Java7: Weil es kein Error objekt mit Stactrace gibt, kann man es sich sparen 
					//sReturn = reflectMethodCurrent_Name(objError, objControl);					
					
					
					var objError = new Error();	//Das bekommt keinen Stacktrace Java 7. Bei der weiteren Verarbeitung beachten
					sReturn=reflectMethodCurrent_Name(objError, objControl);					
					if(!objControl.bReturnControl) throw new Error("tryout_reflectMethodCurrentName: " + objControl.sReturnControl);
				}catch(err){	
					print(err);
					try{
						objControl.sReturnControl=err;				
						objControl.bReturnControl=false;
					} catch(e){
						print(e);
						objControl.sReturnControl="Error im Errorhandling";				
						objControl.bReturnControl=false;
					}
				}
				return sReturn;
			}
			
			//###############################################################
			//### REFLECTION 
			//###############################################################
			function reflectMethodCurrent_Name(myError, objControl){
				var sScript="reflectMethodCurrentName: ";				
				var sReturn="";				
				try{			
					//Merke Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					if('undefined'!=myError && null!=myError){					
						var sLine=reflectMethodCurrent_StackLine(myError, objControl);
						if(!objControl.bReturnControl)	throw new Error(objControl.sReturnControl);

						var sMethod=reflectMethodCurrent_StackMethodFromLine(sLine, objControl);
						if(!objControl.bReturnControl)	throw new Error(objControl.sReturnControl);
						
						objControl.bReturnControl=true;
						objControl.sReturnControl=sScript+"Alles o.k.";
						sReturn=sMethod;
					}else{						
						//Java V7 liegt wahrscheinlich vor
						var sLine=reflectMethodCurrent_StackLine(null, objControl);
						if(!objControl.bReturnControl)	throw new Error(objControl.sReturnControl);
						
						var sMethod=reflectMethodCurrent_StackMethodFromLine(sLine, objControl);
						if(!objControl.bReturnControl)	throw new Error(objControl.sReturnControl);

						objControl.bReturnControl=true;
						objControl.sReturnControl=sScript+"Alles o.k.";
						sReturn=sMethod;
					}	
				}catch(err){
					print(err);					
					objControl.sReturnControl=sScript+"Kein Methodenname berechenbar. "+ err;					
					objControl.bReturnControl=false;					
				}
				return sReturn;
			}//End function reflectMethodCurrentName		
					
			function reflectMethodCurrent_StackLine(myError, objControl){
				var sScript="reflectMethodCurrent_StackLine: ";
				var sReturn="";
				var sReturnControl="Alles o.k.";
				var bReturnControl=true;
				try{
					if('undefined'!=myError && null!=myError){					
						if(undefined!=myError.stack){		
							//Java 8, NASHORN funktioniert.
							//print(myError.stack);
							var sCallerLine = myError.stack.split("\n")[1];						
							sReturn=sCallerLine;
						} else {
							//Vermutlich Java7, da kein Stacktrace im error-objekt vorhanden ist.
							var saStacktrace=createStackTrace();
							var sCallerLine = saStacktrace[2]; //Da ich den Stacktrace später als in der Java8 VErsion erzeuge, muss der Index um 1 höher sein.							
							sReturn=sCallerLine;
						}				
					}else{
						//Vermutlich Java7, da kein Stacktrace im error-objekt vorhanden ist.
						var saStacktrace=createStackTrace();
						var sCallerLine = saStacktrace[2]; //Da ich den Stacktrace später als in der Java8 VErsion erzeuge, muss der Index um 1 höher sein.						
						sReturn=sCallerLine;
					}					
				}catch(err){
					print(err);
					sReturnControl = sScript+"Keine Stacktrace-Zeile berechenbar." + err;
					bReturnControl = false;
				}
				objControl.sReturnControl=sReturnControl;					
				objControl.bReturnControl=bReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
			//#########################################
			//### Hilfsfunktion zur Generierung eines Stacktraces. Als Workaround für Java7. 
			//#########################################			
			function createStackTrace() {
			  var callstack = [];
			  var isCallstackPopulated = false;
			  try {
				i.dont.exist+=0; //doesn't exist- that's the point
			  } catch(e) {
				if (e.stack) { //Firefox
					//print("ffox");
					//print(e.stack);
				  var lines = e.stack.split('\n');
				  for (var i=0, len=lines.length; i<=len-1; i++) {
					//print(i + ": '" + lines[i].trim() +"'");
					//klappt hier nicht....  if (lines[i].trim().match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
					if (lines[i].trim()!=''){
					  //print("line used");
					  callstack.push(lines[i]);
					}else		 {
					  //print("empty line NOT used");  				
					}
				  }
				  
				  //Remove call to printStackTrace()
				  callstack.shift();
				  isCallstackPopulated = true;
				}
				else if (window.opera && e.message) { //Opera
					print("opera  untested");
				  var lines = e.message.split('\n');
				  for (var i=0, len=lines.length; i<len; i++) {
					if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
					  var entry = lines[i];
					  //Append next line also since it has the file info
					  if (lines[i+1]) {
						entry += ' at ' + lines[i+1];
						i++;
					  }
					  callstack.push(entry);
					}
				  }
				  //Remove call to printStackTrace()
				  callstack.shift();
				  isCallstackPopulated = true;
				}
			  }
			  if (!isCallstackPopulated) { //IE and Safari
				print("ie untested");
				var currentFunction = arguments.callee.caller;
				while (currentFunction) {
				  var fn = currentFunction.toString();
				  var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('')) || 'anonymous';
				  callstack.push(fname);
				  currentFunction = currentFunction.caller;
				}
			  }
			  //output(callstack);
			  return callstack;
		}

		function output(arr) {
		  //Optput however you want
		  //alert(arr.join('\n\n'));
		  //print("aaaaaaa " + arr);
		  print(arr.join('\n\n'));
		}
		
		

		//#####################################################################
		//### Den Funktionsnamen von einer Fehlerzeile bekommen
		//#####################################################################
		function reflectMethodCurrent_StackMethodFromLine(sStackLine, objControl){
			var sScript="reflectMethodCurrent_StackMethodFromLine: ";
			var sReturn = sStackLine;					
			var sReturnControl="Alles o.k.";
			var bReturnControl=true;
			try {
				if(undefined==sStackLine || null==sStackLine) throw new Error("Parameter Stacktrace-Zeile fehlt.");
			
					//TODO: Einzelne Informationen zerlegen, um die Ausgabe schöner zu machen.
					//var index = caller_line.indexOf("at ").trim();
					//var clean = caller_line.slice(index+2, caller_line.length);
					//print("TESTE caller_line" + clean );
					
					var index = sStackLine.indexOf(" (");
					var clean = sStackLine.slice(index+2, sStackLine.length);
					
					var index2 = clean.indexOf(")");							
					if(index2>=1){
						var clean2 = clean.substring(0,index2);
					}else{
						var clean2 = clean;
					}							
					sReturn=clean2;			
			}catch(err){
				print(err);
				sReturnControl = sScript+"Kein Methodenname aus Stacktrace-Zeile berechenbar." + err;
				bReturnControl = false;
			}
			objControl.sReturnControl=sReturnControl;					
			objControl.bReturnControl=bReturnControl;
			return sReturn;
		}//End function reflectMethodCurrent_StackMethodFromLine
			
								
				//##################################################################
				//### Tryouts den Stacktrace vom Error objekt zu bekommen
				//##################################################################

				//produziert in Java7 KEINEN Stacktrace
				function errorTraced() {
				  try {
					var err = new Error("test01");
					throw err;
				  } catch (err) {
					print("ddddd " + err);
					//print(err.rhinoException.printStackTrace());
					print(err.stack);
					return err;
				  }
				}
				
				//produziert in Java7 KEINEN Stacktrace
				function stackTrace() {
				  try {
					var err = new Error("test02");
					throw err;
				  } catch (err) {
					print("eeee " + err);
					//print(err.rhinoException.printStackTrace());
					print(err.stack);
					return err.stack;
				  }
				}
		]]>
	</scriptdef>

	   
       
     
<!-- ################################################################################# -->
	<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!-- <target name="compile" depends="-myTestStringExplode,-myTestStringSubstring,-myTestStringLeftString,-myTestStringRightString,-myTestStringLeftBackString,-myTestStringContainsString,-myTestStringCountString"> -->
 <!-- TODO Test für stringUnencodeJsZZZ und stringEncodeJsZZZ -->
 <!--<target name="compile" depends="-myTryoutJavaScript_ErrorHandling, -myTestReflectMethodCurentNameJs">-->
 <target name="compile" depends="-myTryoutJavaScript_ErrorHandling">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="-myTryoutJavaScript_ErrorHandling">
		<fl:let>sScript::='-myTryoutJavaScript_ErrorHandling: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		 <fl:let>myInputFilepath::="Test01-keinBackslash"</fl:let>
		 <echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_errorHandlingJs inputfilepath="${myInputFilepath}" returnstring="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		  <fl:let>myInputFilepath::=""</fl:let>
		  <echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_errorHandlingJs inputfilepath="${myInputFilepath}" returnstring="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
		</trycatch>		
	</target>
  
  
  <target name="-myTestReflectMethodCurentNameJs">
		<fl:let>sScript::='-myTestReflectMethodCurentNameJs: '</fl:let>
		<echo>${sScript}Start</echo>
		<!--<ac:var name="myReturnControl" value="false" unset="true"/>-->
		<!--<ac:var name="myReturnControlString" value="Fehler" unset="true"/>-->
		<fl:let>myReturnControl::=false</fl:let>
		<fl:let>myReturnControlString::="Fehler"</fl:let>
		<echo message="1. myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->		
		<tryout_reflectMethodCurrentNameJs returnstring="myReturnString" returncontrol="myReturnControl" returncontrolstring="myReturnControlString" />
		<echo message="myReturnControl | myReturnConstrolString = ${myReturnControl} | ${myReturnControlString} " />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="Ermittelter Methodenname = ${myReturnString}" />
		<echo message="############################" />
				
	</target> 
 </project>