<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
   xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man fue FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen moechte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so waehlen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	 <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
		  <!-- ######## Scriptdefs ############################################################################--> 		
 	   <!-- ########################### -->		
	<scriptdef name="isBooleanZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie boolean interpretiert werden kann. -->
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->
				
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isboolean" />
		<![CDATA[		   		  
		   var bBooleanValue = null;
		   var bIsBoolean = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   print("myValueInput='"+myValueInput+"'");		   			
			if(isNumber(myValueInput)){
				print("boolean liegt als Zahl vor.");	
				if (myValueInput=='1') {			   
					bBooleanValue = true;
					bIsBoolean = true;
				}else if(myValueInput=='0'){
					bBooleanValue = false;
					bIsBoolean = true;
				}else{
					bBooleanValue = null;
					bIsBoolean = false;
				};
			}else{			
				print("boolean liegt als String vor.");	
				if (myValueInput=='true') {			   
				   bBooleanValue = true;
				   bIsBoolean = true;
				}else if(myValueInput=='false') {
					bBooleanValue = false;
					bIsBoolean = true;				
				}else{					
					bIsBoolean = false;
				};			
			}
						
			project.setProperty(attributes.get("valuereturn"), bBooleanValue);
			project.setProperty(attributes.get("isboolean"), bIsBoolean);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			//TODO: Diese Funktion in JSZ-Kernel Bibliotheken packen. 
			//TODO: In einer entsprechenden Scriptdef Funktion nutzen.
			function convertBoolToInt()
			{
				var testBool = true;
				result = (testBool)?1:0;
				alert(result);
			}
		 ]]>
	</scriptdef>
	   
	   
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafuer sorgen dass die Deklaration vor allen anderen Targets ausgefuehrt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
	 <!-- um EL referencen zusatzlich zu den normalen Ant Referencen anzustellen (ausserhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaksss install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
</target>
  
  <!-- ################################################################################# -->
 <target name="compile" depends="declaration, init,myTestIsBoolean,myTestAntcontribIf,myTestFlakaChoose">

	<!-- WIRD NICHT BENOETIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
 </target>
 
  <target name="init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
  
 <!-- ######################################################### -->  
<target name="myTestIsBoolean">
	<fl:logo>
		myTestIsBoolean
	</fl:logo>
	<fl:let>mytestBool ::= 'true'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValue = ${myBooleanValue} | myValueIsBoolean = ${myValueIsBoolean} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValue}" valuereturn="myBooleanValue02" isboolean="myValueIsBoolean02" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02 = ${myBooleanValue02} | myValueIsBooleanß2 = ${myValueIsBoolean02} </echo>
	
	<echo>---------------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= 'bloedsinn'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueA" isboolean="myValueIsBooleanA" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueA = ${myBooleanValueA} | myValueIsBooleanA = ${myValueIsBooleanA} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueA}" valuereturn="myBooleanValue02A" isboolean="myValueIsBoolean02A" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02A = ${myBooleanValue02A} | myValueIsBoolean02A = ${myValueIsBoolean02A} </echo>
	
	<echo>---------------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= '1'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueB" isboolean="myValueIsBooleanB" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueB = ${myBooleanValueB} | myValueIsBooleanB = ${myValueIsBooleanB} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueB}" valuereturn="myBooleanValue02B" isboolean="myValueIsBoolean02B" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02B = ${myBooleanValue02B} | myValueIsBoolean02B = ${myValueIsBoolean02B} </echo>
	
	<echo>---------------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= 'eins'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueC" isboolean="myValueIsBooleanC" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueC = ${myBooleanValueC} | myValueIsBooleanC = ${myValueIsBooleanC} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueC}" valuereturn="myBooleanValue02C" isboolean="myValueIsBoolean02C" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02C = ${myBooleanValue02C} | myValueIsBoolean02C = ${myValueIsBoolean02C} </echo>
	
	<echo>---------------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= '0'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueD" isboolean="myValueIsBooleanD" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueD = ${myBooleanValueD} | myValueIsBooleanD = ${myValueIsBooleanD} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueD}" valuereturn="myBooleanValue02D" isboolean="myValueIsBoolean02D" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02D = ${myBooleanValue02D} | myValueIsBoolean02D = ${myValueIsBoolean02D} </echo>
	
	<!-- TODO: Ein Untertarget machen, in dem über paramter die Variablen übergeben werden. 
	           Dann dieses Target in einer Schleife aufrufen, für die einzelnen Testwerte. -->
 </target>
  
 <!-- ######################################################### -->  
<target name="myTestAntcontribIf">
<fl:logo>
		myTestAntcontribIf
  </fl:logo>	
	<fl:let>mytest01 ::= '0'</fl:let>
	<fl:let>mytest02 ::= '1'</fl:let>
	<fl:let>mytest02 ::= '0'</fl:let>
	<if>
		<equals arg1="${mytest01}" arg2="0" />
		<then>
			<echo>mytest01 ist 'null' </echo>
		</then>
		<else>						
			<echo>mytest01 ist ungleich 'null' </echo>
			
			<!-- AntContrib if duerfen verschachtelt sein  -->						
			<if>
				<equals arg1="${mytest02}" arg2="0" />
				<then>
					<echo>mytest02 ist 'null' </echo>
				</then>
				<else>
					<echo>mytest02 ist ungleich 'null' </echo>
					
					<if>
						<equals arg1="${mytest03}" arg2="0" />
						<then>
							<echo>mytest03 ist 'null' </echo>
						</then>
						<else>
							<echo>mytest03 ist ungleich 'null' </echo>
						</else>						
					</if>
				</else>
			</if>	
		</else>
	</if>		
 </target>
 
 
  
<!-- ######################################################### -->  
<target name="myTestFlakaChoose">
	<fl:logo>
		myTestFlakaChoose
  </fl:logo>
  <fl:install-property-handler />
	
	<!-- 1. Einfaches 'when' testen und die true(...) Funktion ausprobieren mit einem echten boolean - Wert. -->
	<fl:let>mytestBool ::= 'true'</fl:let>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueX" isboolean="myValueIsBooleanX" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueX = ${myBooleanValueX} | myValueIsBooleanX = ${myValueIsBooleanX} </echo>
	
	<!-- TODO GOON Warum funktioniert hier die funktion(true) nicht ???-->	
	<fl:echo>true(...) = '#{true('${myValueIsBooleanX}')}'</fl:echo>
	<fl:echo>nativetype = '#{nativetype(true)}'</fl:echo>
	<fl:echo>nativetype = '#{nativetype(${myValueIsBooleanX})}'</fl:echo>
	<fl:echo>nativetype = '#{nativetype(true(${myValueIsBooleanX})}'</fl:echo>
	
	<fl:when test="true('${myValueIsBooleanX}')">
			<echo>When:  Ein boolean Wert wurde gefunden.</echo>
			
			<!-- die Verschachtelung innerhalb der When's testen -->
<!-- 			<fl:when test="true('${myValueIsBooleanX}')">
			<echo>When:  Ein boolean 'true' Wert wurde gefunden.</echo>
			</fl:when>
			<fl:when test="false('${myValueIsBooleanX}')">
					<echo>When:  Ein boolean 'false' Wert wurde gefunden.</echo>
			</fl:when> -->
			
	</fl:when>
	<fl:when test="false('${myValueIsBooleanX}')">
			<echo>When:  KEIN boolean Wert gefunden.</echo>
	</fl:when>
	
	
	
	<!-- 2. Verschachtelung von 'choose' testen. -->
	<fl:let>mytest01 ::= '0'</fl:let>
	<fl:let>mytest02 ::= '1'</fl:let>
	<fl:let>mytest02 ::= '0'</fl:let>
	
	<!-- Merke: nur antrib - If darf darin enthalten sein, kein weiteres Flaka - Choose-->
 	<fl:choose>
		<when test=" '${mytest01}' == '0' ">
			<echo>mytest01 ist 'null' </echo>	
		</when>
		<otherwise>
				<echo>mytest01 ist ungleich'null' </echo>
				<!-- <fl:fail message="Datei existiert NICHT: ${conf.copyLocalFilePath}"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird.  -->
		</otherwise>
	</fl:choose>

</target>

</project>