<?xml version="1.0" encoding="UTF-8" ?>  
<project name="FGLVmdGitPrepareHost" default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">
	
   <!-- ### Einbinden von flaka ### -->
   <!--xmlns:fl="antlib:it.haefelinger.flaka"> --><!-- damit definiert man fuer FLAKA einen eigenen Namespace -->

   <!-- ### Einbinden von Ant-Contrib ### -->
   <!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen moechte, 
            z.B. <if-contrib> verwenden statt <if> UND das Einbinden des Namespace von AntContrib nicht macht.### -->
	<!--    <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	 <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" />
	 <taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/../lib/ant-contrib-1.0b3.jar" /> -->
	 
	 
	 <!-- man kann Ant-Contrib auch mit einem Namespace definieren, trotzdem kann man die ant-contrib Tasks auch ohne Namespace ansprechen.-->
	 <!-- xmlns:ac="antlib://net/sf/antcontrib">

    <taskdef resource="net/sf/antcontrib/antlib.xml"
         uri="antlib://net/sf/antcontrib">
        <classpath>
            <fileset dir="${basedir}/antlib/antcontrib"/>
        </classpath>
    </taskdef> -->
	 
	 
 
	  <!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so waehlen, wie sie in der ant-contrib Doku benannt sind ### -->
	  <!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	 <taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
		
	<!-- ######## Scriptdefs ############################################################################--> 		
 	<!-- ############################################################ -->		
	<scriptdef name="isBooleanZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie boolean interpretiert werden kann. -->
		<!-- Es werden Ausdrücke wie null, eins nicht in boolean umgesetzt.
		
		    In boolean umgesetzt werden:
			- Strings 0, 1 
			- Strings true, false
			
			TODO: 
			- Zahlen 0, 1
		-->
			
			
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isboolean" />
		<![CDATA[		   		  
		   var bBooleanValue = null;
		   var bIsBoolean = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   print("myValueInput='"+myValueInput+"'");		   			
			if(isNumber(myValueInput)){
				//print("boolean liegt als Zahl vor: " + myValueInput);	
				if (myValueInput=='1') {			   
					bBooleanValue = true;
					bIsBoolean = true;
				}else if(myValueInput=='0'){
					bBooleanValue = false;
					bIsBoolean = true;
				}else{
					bBooleanValue = null;
					bIsBoolean = false;
				};
			}else{			
				//print("boolean liegt als String vor: " + myValueInput);	
				if (myValueInput=='true') {			   
				   bBooleanValue = true;
				   bIsBoolean = true;
				}else if(myValueInput=='false') {
					bBooleanValue = false;
					bIsBoolean = true;				
				}else{					
					bIsBoolean = false;
				};			
			}			
			project.setProperty(attributes.get("valuereturn"), bBooleanValue);
			project.setProperty(attributes.get("isboolean"), bIsBoolean);
			
			function isNumber(n) {
				return !isNaN(parseFloat(n)) && isFinite(n);
			}
			
			//TODO: Diese Funktion in JSZ-Kernel Bibliotheken packen. 
			//TODO: In einer entsprechenden Scriptdef Funktion nutzen.
			function convertBoolToInt()
			{
				var testBool = true;
				result = (testBool)?1:0;
				alert(result);
			}
		 ]]>
	</scriptdef>
	
	
	<!-- ########################### -->
<scriptdef name="isSetZZZ" language="javascript">
		<!-- Hiermit prueft man, ob der Wert irgendwie als gesetzt interpretiert werden kann. -->
		<!-- Es werden Ausdrücke, die ${ } entsprechen als nicht gesetzt angesehen.
		     
		-->
			
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->			
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
												
		<attribute name="valueinput" />
		<attribute name="valuereturn" />
		<attribute name="isset" />
		<![CDATA[		   		  
		   var bIsSetValue = null;
		   var bIsSet = null;
		   
		   var myValueInput = attributes.get("valueinput");
		   print("myValueInput='"+myValueInput+"'");		   			
			
			//Die ersten beiden Zeichen und das letze Zeichen prüfen.
		    var sBeginning = myValueInput.substring(0, 2);
			print("ermittelter Anfang="+sBeginning);
			
			var version = java.lang.System.getProperty("java.version");
			print("Java Version:" + version);
			load("nashorn:mozilla_compat.js");//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
		   importPackage(Packages.basic.zBasic.util.datatype.string);	   
			//var test = java.lang.System.getProperty("java.class.path");
			//println("classpath="+test);			  
			var sEnding = StringZZZ.right(myValueInput,1);
			print("Per JAZ-Kernel ermitteltes Stringende (aus '" + myValueInput + "'): '" + sEnding +"'");
			   			   
						
			if(sBeginning=="${" && sEnding=="}") {
				bIsSet=false;
			}else{
				bIsSet=true;
				bIsSetValue=myValueInput;
			}
						
			project.setProperty(attributes.get("valuereturn"), bIsSetValue);
			project.setProperty(attributes.get("isset"), bIsSet);
		 ]]>
	</scriptdef>
	
	
<!-- ########################### -->
<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
			Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
 <scriptdef name="stringSubStringZZZ" language="javascript">
     <attribute name="text" />
     <attribute name="start" />
     <attribute name="end" />
     <attribute name="property" />
     <![CDATA[
       var text = attributes.get("text");
       var start = attributes.get("start");
       var end = attributes.get("end") || text.length();
       project.setProperty(attributes.get("property"), text.substring(start, end));
     ]]>
  </scriptdef>
	   
  <!-- ######### AntContrib: Callback Targets, quasi als ausgelagerte Unterfunktionen ################################-->
  <target name="-booleanDebugCallbackZZZ"><!-- das target dient nur als callback und soll so nicht aufgerufen werden -->
	<!-- Merke: Property Werte sind nicht veränderbar, egal wie oft man den Callback aufruft <property name="retValue" value="${lineFromFile}xxxxxx"/>
				Darum: Mach folgendes in dem aufrufenden Target, dann klappts <var name="returnBooleanValue" unset="true"/> -->   
   <var name="myInputBooleanValue" value="${inputBooleanValue}" />
     	
	<!-- ein wenig Hintergrundinformationen --> 
	<fl:echo>true -> nativetype = '#{nativetype(true)}'</fl:echo>
	<fl:echo>myInputBooleanValue -> nativetype = '#{nativetype(${myInputBooleanValue})}'</fl:echo><!-- Merke: Bei einem undefinierten myInputBooleanValue wird das zweite Hochkomma nicht ausgegeben -->	
	 		
   <!-- Auswertung der Rückgabewerte von isBooleanZZZ -->
   <!-- Prüfe zuerst ab, ob die Variable gesetzt ist, Kombination aus antcontrib und standard ant -->
	<ac:if>
	  <!-- TODO: isset funktioniert nicht im callback. Dort sind die Variablen immer gesetzt, auch mit dem unset-Attribut -->	  
      <isset property="myInputBooleanValue"/><!-- dieser isset - teil funktioniert nicht im Callback -->
      <ac:then>
        <echo message="myInputBooleanValue exists: '${myInputBooleanValue}'" />
		
		<!-- Hier noch auf den Wert prüfen. Wenn es mit $ beginnt, dann ist der Wert auch in einem antcallback als 'undefined' anzusehen -->		
		<stringSubStringZZZ text="${myInputBooleanValue}" start="0" end="1" property="subtext" /><!-- Es wird die scriptdef Methode substring aufgerufen -->
		<echo message="Pruefe auf $ am Anfang: subtext = ${subtext}" />
		<ac:if>
			<equals arg1="${subtext}" arg2="$" />
			<ac:then>
				<!-- TODO: es müsste noch auf eine Laenge >=2 geprueft werden -->
				<echo message="$ am Anfang -> undefined Wert" />				
				<fl:let>myResult ::= 'undefined'</fl:let>
			</ac:then>
			<ac:else>
				<echo message="kein $ am Anfang -> defined Wert" />
				
				<!-- Danach erst kann der test auf den Property Wert funktionieren -->
				<!-- Merke: die Property muss für den test in einfache Hochkommata, sonst funktioniert nix -->
				<!-- <fl:when test="'${myInputBooleanValue}'==true"> -->
				<fl:when test="${myInputBooleanValue}==true">
				<echo>true Fall erkannt.</echo>
				<fl:let>myResult ::= 'true'</fl:let>
				</fl:when>
				<!-- <fl:when test="'${myInputBooleanValue}'!=true"> -->
				<fl:when test="${myInputBooleanValue}!=true">
					<echo>false Fall erkannt.</echo>
					<fl:let>myResult ::= 'false'</fl:let>
				</fl:when>
			</ac:else>
		</ac:if>
				
      </ac:then>
      <ac:else>
        <echo message="myInputBooleanValue does NOT exist -> undefined Wert"/>	
		<fl:let>myResult ::= 'undefined'</fl:let>		
      </ac:else>
    </ac:if>
    <var name="returnBooleanValue" value="${myResult}" />
 </target>
	 
  <!-- ######### Set global properties for this build ####################################################-->
  <!-- Example for using an environment variable, which is defined e.g. in windows: 
       <property name="build" value="${BUILDTARGET}"/> -->
  <!-- Beispiele fuer relative Pfade
  <property name="dest" value="target"/>
  <property name="src" value="src"/>
  -->
  
  <target name="-declaration"><!-- damit dies nicht z.B. beim Aufruf jedes ant-callback erneut gemacht wird, die Property Dekalarationen in ein eigenes target packen. Aber: Dafuer sorgen dass die Deklaration vor allen anderen Targets ausgefuehrt wird. -->
    <!-- An dieser Stelle Argumente entgegennehmen, entweder aus der Batch oder unter Eclipse aus der "external Configuration" des AntScripts  -->
  	<!-- Merke: You can define an argument with the property file name to the build in the 'Arguments' section of the Run > External Tools > External Tools Configuration for your Ant Build. Something like:
  	-Dproperties=Buildfile_test.properties

  	You use this in your build.xml like this:
  	<property file="${properties}"/>
  	-->
  	
	 <!-- um EL referencen zusatzlich zu den normalen Ant Referencen anzustellen (ausserhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	       dies passiert hier durch flaksss install-property handler task -->
	<fl:install-property-handler />  	
  	<property environment="env" /> <!-- ist voraussetzung um mit 'env' auf die Umgebungsvariablen zuzugreifen -->
  	
  	<!-- TODO GOON: Hier eine Fallunterscheidung machen, ob durch Eclipse oder durch Batch gestartet wurde !!! -->
  	<echo>VMD Properties Datei= ${env.VMD}</echo>
	<echo>TRYOUT= ${env.TRYOUT_ANT}</echo>
  	<echo>ECLIPSE ARGUMENTS= ${vmd}</echo>
</target>
  
  <!-- ################################################################################# -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!-- <target name="compile" depends="-declaration, -init,-myTestIsBoolean,-myTestAntcontribIf,-myTestFlakaChoose"> -->
 <target name="compile" depends="-declaration, -init,-myTestIsSet">

	<!-- WIRD NICHT BENOETIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
 </target>
 
  <target name="-init">
    <!-- Create the time stamp -->
	<echo>Receiving timestamp:</echo>
    <!--<tstamp/>-->
	<tstamp>
	<format property="current.time" pattern="yyyyMMdd_HHmmss" locale="en,GB"/>
	<!--<format property="backup_archive.name" pattern="'EinArchiv'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>-->
	<format property="backup_RepositoryArchive.name" pattern="'${dest.dirRepositoryVmdArchive}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	<format property="backup_RepositoryMisc.name" pattern="'${dest.dirRepositoryVmdMisc}'yyyyMMdd_HHmmss'.zip'" locale="en,GB"/>
	</tstamp>
	<echo>Current Timestamp: ${current.time}</echo>
	<echo>Backup-Filenames: ${backup_RepositoryArchive.name}, ${backup_RepositoryMisc.name}</echo>
</target>
  
 <!-- ######################################################### -->  
<target name="-myTestIsBoolean">
	<!-- Merke: Eine Funktion true(...) funktioniert in Ant gar nicht. gibt´s gar nicht, weiss nicht woher sie kommen soll ! -->
	<!-- Merke2: <fl:fail message="blablabla"/> --><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
	
	<!-- TODO: Ein Untertarget machen, in dem über paramter die Variablen übergeben werden. 
	                  Dann dieses Target in einer Schleife aufrufen, für die einzelnen Testwerte.
                      Die Testwerte kämen dann aus einem Array.  -->
					  
	<!-- TODO: Den Test auf den Boolean-Wert in eine zentrale Unterfunktion auslagern, wie ? -->
	<fl:logo>myTestIsBoolean</fl:logo>
	
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>-- true Fall -------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= 'true'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValue = ${myBooleanValue} | myValueIsBoolean = ${myValueIsBoolean} </echo>
	
	<!-- ein wenig Hintergrundinformationen -->
	<fl:echo>true -> nativetype = '#{nativetype(true)}'</fl:echo>
	<fl:echo>myBooleanValue -> nativetype = '#{nativetype(${myBooleanValue})}'</fl:echo>	
	<fl:echo>myValueIsBoolean -> nativetype = '#{nativetype(${myValueIsBoolean})}'</fl:echo>
	
	<!-- Test zur Auswertung der Rückgabewerte von isBooleanZZZ:
         Wenn die Property nicht gesetzt wurde oder NULL ist, wird der Wert SOOO als TRUE erkannt. DAS DARF NICHT SEIN. -->	
	<fl:when test="'${myBooleanValueGIBTSNICHT}'==true">
		<echo>ungesetzte property: true Fall erkannt.</echo>
	</fl:when>
	<fl:when test="'${myBooleanValueGIBTSNICHT}'!=true">
		<echo>ungesetzte property: false oder undefiniert Fall erkannt.</echo><!-- dieses wird eben nicht ausgeführt -->
	</fl:when>
		
	<!-- Auswertung der Rückgabewerte von isBooleanZZZ, per antcallback, wg. der Wiederverwertbarkeit und Reduzierung der Codezeilen -->
	<var name="returnBooleanValue" unset="true"/><!-- Merke: In einem Callback sind ohne das unset die Werte nicht veränderbar-->
	<var name="inputBooleanValue" unset="true"/>
	<antcallback target="-booleanDebugCallbackZZZ" return="returnBooleanValue">
		<param name="inputBooleanValue" value="${myBooleanValue}"/>		
	</antcallback>
	<echo>antcallback ermittelt Wert: '${returnBooleanValue}'</echo>
	
		
	<isBooleanZZZ valueinput="${myBooleanValue}" valuereturn="myBooleanValue02" isboolean="myValueIsBoolean02" /><!-- Anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02 = ${myBooleanValue02} | myValueIsBoolean02 = ${myValueIsBoolean02} </echo>
	
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>-- false Fall ------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= 'false'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- Anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValue = ${myBooleanValue} | myValueIsBoolean = ${myValueIsBoolean} </echo>
	
	<!-- ein wenig Hintergrundinformationen -->
	<fl:echo>true -> nativetype = '#{nativetype(true)}'</fl:echo>
	<fl:echo>myBooleanValue -> nativetype = '#{nativetype(${myBooleanValue})}'</fl:echo>	
	<fl:echo>myValueIsBoolean -> nativetype = '#{nativetype(${myValueIsBoolean})}'</fl:echo>
	
	<!-- Auswertung der Rückgabewerte von isBooleanZZZ, per antcallback, wg. der Wiederverwertbarkeit und Reduzierung der Codezeilen -->
	<var name="returnBooleanValue" unset="true"/><!-- Merke: In einem Callback sind ohne das unset die Werte nicht veränderbar-->
	<var name="inputBooleanValue" unset="true"/>
	<ac:antcallback target="-booleanDebugCallbackZZZ" return="returnBooleanValue">
		<param name="inputBooleanValue" value="${myBooleanValue}"/>		
	</ac:antcallback>
	<echo>antcallback ermittelt Wert: '${returnBooleanValue}'</echo>
	
		
	<isBooleanZZZ valueinput="${myBooleanValue}" valuereturn="myBooleanValue02" isboolean="myValueIsBoolean02" /><!-- Anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02 = ${myBooleanValue02} | myValueIsBoolean02 = ${myValueIsBoolean02} </echo>
		
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>----bloedsinn Fall -------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= 'bloedsinn'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueA" isboolean="myValueIsBooleanA" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueA = ${myBooleanValueA} | myValueIsBooleanA = ${myValueIsBooleanA} </echo>
	
	<!-- ein wenig Hintergrundinformationen -->
	<fl:echo>myBooleanValueA -> nativetype = '#{nativetype(${myBooleanValueA})}'</fl:echo>	<!-- Merke: Das hinterste Hochkomma wird nicht angezeigt. Flaka bricht vorher ab. -->	
	<fl:echo>myValueIsBooleanA -> nativetype = '#{nativetype(${myValueIsBooleanA})}'</fl:echo>
	
	<!-- Merke: Weil in dem bloedsinn Fall, der Rückgabewert der Variablen nicht gesetzt ist, ist die Auswertung besonders interessant -->	
	<!-- Auswertung der Rückgabewerte von isBooleanZZZ, per antcallback, wg. der Wiederverwertbarkeit und Reduzierung der Codezeilen -->
	<var name="returnBooleanValue" unset="true"/><!-- Merke: In einem Callback sind ohne das unset die Werte nicht veränderbar-->
	<var name="inputBooleanValue" unset="true"/>
	<ac:antcallback target="-booleanDebugCallbackZZZ" return="returnBooleanValue">
		<param name="inputBooleanValue" value="${myBooleanValueA}"/>
	</ac:antcallback>
	<echo>antcallback ermittelt Wert: '${returnBooleanValue}'</echo>
		
	<!-- ACHTUNG: Hier wird eine nicht existierende Property an die isBooleanZZZ Funktion übergeben -->
	<isBooleanZZZ valueinput="${myBooleanValueA}" valuereturn="myBooleanValue02A" isboolean="myValueIsBoolean02A" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02A = ${myBooleanValue02A} | myValueIsBoolean02A = ${myValueIsBoolean02A} </echo>
	
	<!-- Merke: Weil eine nicht existierende Property an die isBooleanZZZ Funktion überben wurde, ist die Auswertung besonders interessant -->
	<!-- Auswertung der Rückgabewerte von isBooleanZZZ -->
	<!-- Prüfe zuerst ab, ob die Variable gesetzt ist, Kombination aus antcontrib und standard ant -->
	<ac:if>
      <isset property="myBooleanValue02A"/><!-- Merke: An dieser Stelle (ausserhalb des antcallback) funktioniert isset wieder. -->
      <ac:then>
        <echo message="myBooleanValue02A exists"/>
		
		<!-- Danach erst kann der test auf den Property Wert funktionieren -->
		<!-- Merke: die Property muss für den test in einfache Hochkommata, sonst funktioniert nix -->
		<fl:when test="'${myBooleanValue02A}'==true">
		<echo>ohne antcallback: true Fall erkannt.</echo>
		</fl:when>
		<fl:when test="'${myBooleanValue02A}'!=true">
			<echo>ohne antcallback: false oder undefiniert Fall erkannt.</echo>
		</fl:when>
      </ac:then>
      <ac:else>
        <echo message="ohne antcallback: myBooleanValue02A does NOT exist"/>		
      </ac:else>
    </ac:if>
	
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>---1 Fall          -------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= '1'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueB" isboolean="myValueIsBooleanB" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueB = ${myBooleanValueB} | myValueIsBooleanB = ${myValueIsBooleanB} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueB}" valuereturn="myBooleanValue02B" isboolean="myValueIsBoolean02B" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02B = ${myBooleanValue02B} | myValueIsBoolean02B = ${myValueIsBoolean02B} </echo>
	
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>----eins Fall  ------------------------wird nicht als boolean erkannt ----------------------------</echo>
	<fl:let>mytestBool ::= 'eins'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueC" isboolean="myValueIsBooleanC" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueC = ${myBooleanValueC} | myValueIsBooleanC = ${myValueIsBooleanC} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueC}" valuereturn="myBooleanValue02C" isboolean="myValueIsBoolean02C" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02C = ${myBooleanValue02C} | myValueIsBoolean02C = ${myValueIsBoolean02C} </echo>
	
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>---0 Fall ----------------------------------------------------------------------------------------</echo>
	<fl:let>mytestBool ::= '0'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueD" isboolean="myValueIsBooleanD" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueD = ${myBooleanValueD} | myValueIsBooleanD = ${myValueIsBooleanD} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueD}" valuereturn="myBooleanValue02D" isboolean="myValueIsBoolean02D" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02D = ${myBooleanValue02D} | myValueIsBoolean02D = ${myValueIsBoolean02D} </echo>
	
	<echo>--------------------------------------------------------------------------------------------------</echo>
	<echo>----null Fall  -------------------------- wird nicht als boolean erkannt -------------------------</echo>
	<fl:let>mytestBool ::= 'null'</fl:let>
	<echo>mytestBool, String = ${mytestBool}</echo>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValueE" isboolean="myValueIsBooleanE" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValueE = ${myBooleanValueE} | myValueIsBooleanE = ${myValueIsBooleanE} </echo>
	
	<isBooleanZZZ valueinput="${myBooleanValueE}" valuereturn="myBooleanValue02E" isboolean="myValueIsBoolean02E" /><!-- anwenden der oben definierten scriptdef funktion -->	
	<echo>es gilt: myBooleanValue02E = ${myBooleanValue02E} | myValueIsBoolean02E = ${myValueIsBoolean02E} </echo>
 </target>
  
  <!-- ######################################################### -->  
  <target name="-myTestIsSet">
	<fl:logo>myTestIsBoolean</fl:logo>
	
	<echo>- isset: Normale, funktioniert ----------------------------------------------------</echo>
	<property name="controlstring" value="${nothing}"/>
	<echo message="Wert fuer controlstring=${controlstring}"/>
	<ac:if>
      <isset property="controlstring"/><!-- Merke: An dieser Stelle (ausserhalb des antcallback) funktioniert isset wieder. -->
      <ac:then>
		<fl:let>myControlstring::="${controlstring}"</fl:let>
		<echo>Property gesetzt. MyControlstring=${myControlstring}</echo>
	  </ac:then>
	  <ac:else>
		<echo>Property NICHT gesetzt.</echo>
	  </ac:else>
	 </ac:if>	
	<echo>----------------------------------------------------------------------------------</echo>
	
	<echo>- isset, ohne dass die Property deklariert worden ist, funktioniert auch. --------</echo>	
	<ac:if>
      <isset property="neverever"/><!-- Merke: An dieser Stelle (ausserhalb des antcallback) funktioniert isset wieder. -->
      <ac:then>	
		<echo>Property gesetzt. neverever=${neverever}</echo>
	  </ac:then>
	  <ac:else>
		<echo>Property NICHT gesetzt.</echo>
	  </ac:else>
	 </ac:if>	
	<echo>-----------------------------------------------------------------------------------</echo>
		
	<echo>- teste isSetZZZ ---------- </echo>
	<property name="myProperty" value="${nothing}"/>
	<echo message="Wert fuer myProperty=${myProperty}"/>
	<isSetZZZ valueinput="${myProperty}" valuereturn="myIsSetValue" isset="myValueIsSet" />
	
	<!-- Das Ergebnis von isSetZZZ prüfen -->
	<isBooleanZZZ valueinput="${myValueIsSet}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<ac:if>
	  <equals arg1="${myValueIsBoolena}" arg2="true" />
      <ac:then>		
		<echo>Property war gesetzt.</echo>
	  </ac:then>
	  <ac:else>
		<echo>Property war NICHT gesetzt.</echo>
	  </ac:else>
	 </ac:if>	
	
	<echo>-----------------------------------------------------------------------------------</echo>
	
	<!-- TODO GOON: Funktioniert das auch in einem ant-callback ? Falls nein, isSetZZZ bereitstellen. -->
	
	<echo>-----------------------------------------------------------------------------------</echo>
	
 </target>
  
 <!-- ######################################################### -->  
<target name="-myTestAntcontribIf">
<fl:logo>
		myTestAntcontribIf
  </fl:logo>	
	<fl:let>mytest01 ::= '0'</fl:let>
	<fl:let>mytest02 ::= '1'</fl:let>
	<fl:let>mytest02 ::= '0'</fl:let>
	
	<!-- für if oder elseif gilt: 
	      and / or / not werden wie im condition task gemacht.
		  mehrere werden unter einem Tag zusammengefasst. mehrere <or> Tags  darf es nicht geben. Z.B.	
	<if>
	<or>
		<equals arg1="${var}" arg2="one"/>
		<equals arg1="${var}" arg2="two"/>
		<equals arg1="${var}" arg2="three"/>
		<equals arg1="${var}" arg2="four"/>
	</or>
   <then>
   -->
	<!-- es gibt zusätzlich zu <equals> noch weitere conditions in antcontrib, z.B.:   <isgreaterthan arg1="100" arg2="10"/> -->
	<if>
		<equals arg1="${mytest01}" arg2="0" />
		<then>
			<echo>mytest01 ist 'null' </echo>
		</then>
		<elseif><!-- dann ist eine nested condition Pflicht -->
			<equals arg1="${mytest01}" arg2="-1" />
		<then>
			<echo>mytest01 ist '-1'. Darf nicht sein. </echo>
		</then>			
		</elseif>
		<else>						
			<echo>mytest01 ist ungleich 'null' </echo>
			
			<!-- AntContrib if duerfen verschachtelt sein  -->						
			<if>
				<equals arg1="${mytest02}" arg2="0" />
				<then>
					<echo>mytest02 ist 'null' </echo>
				</then>
				<else>
					<echo>mytest02 ist ungleich 'null' </echo>
					
					<if>
						<equals arg1="${mytest03}" arg2="0" />
						<then>
							<echo>mytest03 ist 'null' </echo>
						</then>
						<else>
							<echo>mytest03 ist ungleich 'null' </echo>
						</else>						
					</if>
				</else>
			</if>	
		</else>
	</if>		
 </target> 
  
<!-- ######################################################### -->  
<target name="-myTestFlakaChoose">
	<fl:logo>
		myTestFlakaChoose
  </fl:logo>
  <fl:install-property-handler />
	
	<!-- 1. Einfaches 'when' testen und die true(...) Funktion ausprobieren mit einem echten boolean - Wert. -->
	<fl:let>mytestBool ::= 'true'</fl:let>
	<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
	<echo>es gilt: myBooleanValue = ${myBooleanValue} | myValueIsBoolean = ${myValueIsBoolean} </echo>
	<fl:when test="'${myValueIsBoolean}'==true">
			<echo>When:  Ein boolean Wert wurde gefunden.</echo>
			
			<!-- die Verschachtelung innerhalb der When's testen -->
			<fl:let>mytestBool ::= 'true'</fl:let>
			<isBooleanZZZ valueinput="${mytestBool}" valuereturn="myBooleanValue02" isboolean="myValueIsBoolean02" /><!-- anwenden der oben definierten scriptdef funktion -->
 			<fl:when test="'${myValueIsBoolean02}')==true">
				<echo>02 When:  Ein boolean 'true' Wert wurde gefunden.</echo>
			</fl:when>
			<fl:when test="'${myValueIsBoolean02}'!=true">
				<echo>02 When:  Ein boolean 'false' Wert oder 'undefiniert' wurde gefunden.</echo>
			</fl:when> 
			
	</fl:when>
	<fl:when test="'${myValueIsBoolean}'!=true">
			<echo>When:  KEIN boolean Wert oder undefiniert gefunden.</echo>
	</fl:when>
	
	
	
	<!-- 2. Verschachtelung von 'choose' testen. -->
	<fl:let>mytest01 ::= '0'</fl:let>
	<fl:let>mytest02 ::= '1'</fl:let>
	<fl:let>mytest02 ::= '0'</fl:let>	
 	<fl:choose>
		<fl:when test=" '${mytest01}' == '0' ">
			<echo>mytest01 ist 'null' </echo>	
			
			<!-- TODO: Verschachtelungsebenen einfügen -->
			
		</fl:when>
		<otherwise>		<!-- MERKE: otherwise gehört nicht zu flaka! -->
			<echo>mytest01 ist ungleich'null' </echo>				
			
			<!-- TODO: Verschachtelungsebenen einfügen -->
		</otherwise>
	</fl:choose>

</target>

</project>