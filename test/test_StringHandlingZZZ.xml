<?xml version="1.0" encoding="UTF-8" ?> 
<project  name="test_StringHandlingJsZZZ" default="compile" basedir=".."
		  xmlns:fl="antlib:it.haefelinger.flaka"
		  xmlns:ac="antlib://net/sf/antcontrib"><!-- damit definiert man für antcontrib , bzw. FLAKA einen eigenen Namespace. Antcontrib wird hier per taskdef (siehe unten) hinzugefügt. -->

<!-- ### Einbinden von Ant-Contrib, wenn man die verschiedenene Tasks mit einem eigenenen Namen versehen möchte, z.B. <if-contrib> verwenden statt <if> ### -->
	<!-- <taskdef name="if-contrib" classname="net.sf.antcontrib.logic.IfTask" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" />
	taskdef name="for-contrib" classname="net.sf.antcontrib.logic.ForTask" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" />
	<taskdef name="var-contrib" classname="net.sf.antcontrib.property.Variable" classpath="${basedir}/lib/ant-contrib-1.0b3.jar" /> -->
 
	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>
	
<!-- ##### Macrodefs, gesammelt in einem Target, das dann von den Untertargets eingebunden werden kann ##### -->
<target name="-initMacrodef">
 
	 <!-- ############## macrodefs ############################ -->
	 <macrodef name="mathMacroZZZ">
		 <!-- Verwende ein Macrodef für allgemeine mathematische operationen -->
		 <!-- Aufrufbeispiel: <math operation="/" operator1="${foo}" operator2="11" result="foooo" when=" ${foo} &lt; ${limit} "/> -->
	   <attribute name="operation"/>
	   <attribute name="operator1"/>
	   <attribute name="operator2"/>
	   <attribute name="result"/>
	   <attribute name="when"/>
	    
		<!-- Merke: Die Tags echo und math arbeiten nur innerhalb des sequential-Tags.
				Darin müssen die 'Variablen' mit @ angesprochen werden.-->
	   <sequential>
		<script language="javascript">
		<![CDATA[
		 // note => use attribute @{when} without ''  !
		 if(eval(@{when})) {    
			 //println("operator1="+@{operator1}+" | operator2="+@{operator2});
			 var tmp = 0;
			 switch ("@{operation}")
			 {
			  case "+" :
			   tmp = parseInt("@{operator1}") + parseInt("@{operator2}");
			   break;
			  case "-" :
			   tmp = parseInt("@{operator1}") - parseInt("@{operator2}");
			   break;
			  case "*" :
			   tmp = parseInt("@{operator1}") * parseInt("@{operator2}");
			   break;
			  case "/" :
			   tmp = parseInt("@{operator1}") / parseInt("@{operator2}");
			   break;
			  case "max" :
			   if(parseInt("@{operator1}") > parseInt("@{operator2}")){
					tmp=1;
				}else{
					tmp=0;
				};
				break;
			 case "min" :
				//Merke: Das 'kleiner Zeichen' kann hier in den Code nicht eingebaut werden. Wird als XML erkannt. Darum Negierung als Notlösung.
				//if(!(parseInt("@{operator1}") > parseInt("@{operator2}"))){
				//Wenn man ein cdata um den script-teil packt, klappt es auch mit den 'kleiner Zeichen'.
				if(parseInt("@{operator1}") < parseInt("@{operator2}")){
					tmp=1;
				}else{
					tmp=0;			
				}
				break;
			 }
			 //println("math result="+tmp);
			 project.setProperty("@{result}", tmp);
		   } else {
				//println("Condition: @{when} false !");
			}
		 ]]>
		</script>
	   </sequential>
	 </macrodef>
	 
	  <!-- probier mal ein macrodef zu verschachteln ... klappt -->
	  <macrodef name="greaterthanMacroZZZ">  
		   <attribute name="resultprop" default="NOT SET"/>
		   <attribute name="arg1" default="NOT SET"/>
		   <attribute name="arg2" default="NOT SET"/>	
		    
		   <!-- Merke: Die Tags echo und math arbeiten nur innerhalb des sequential-Tags.
				Darin müssen die 'Variablen' mit @ angesprochen werden.-->
		  <sequential>
			<!--<echo>-greaterhan: arg1=@{arg1} | arg2=@{arg2}</echo>-->
			<mathMacroZZZ operation="max" operator1="@{arg1}" operator2="@{arg2}" result="resultgth" when="true"/>		
			 <!--<echo>-greaterthan: result=${resultgth}</echo>-->
			 <property name="@{resultprop}" value="${resultgth}" />         
		  </sequential>
		</macrodef>
		
		<!-- probier mal ein macrodef zu verschachteln ... klappt -->
	  <macrodef name="lessthanMacroZZZ">  
		   <attribute name="resultprop" default="NOT SET"/>
		   <attribute name="arg1" default="NOT SET"/>
		   <attribute name="arg2" default="NOT SET"/>	
		    
		   <!-- Merke: Die Tags echo und math arbeiten nur innerhalb des sequential-Tags.
				Darin müssen die 'Variablen' mit @ angesprochen werden.-->
		  <sequential>
			<echo>-lessthanMacroZZZ: arg1=@{arg1} | arg2=@{arg2}</echo>
			<mathMacroZZZ operation="min" operator1="@{arg1}" operator2="@{arg2}" result="resultgth" when="true"/>		
			 <echo>-lessthanMacroZZZ: result=${resultgth}</echo>		 
			 <property name="@{resultprop}" value="${resultgth}" />         
		  </sequential>
		</macrodef>
 
 </target>  	
	

<!-- ######## Hilfstargets ############################################-->
<target name ="-isLessThanZZZ" depends="-initMacrodef">
	<fl:let>sScript::='-isLessThanZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<!-- das isgreaterthan von antcontrib funktioniert nicht, darum diese Lösung -->
		
	<fl:let>myInputValue01::="${inputvalue01}"</fl:let>
	<fl:let>myInputValue02::="${inputvalue02}"</fl:let><!-- wichtig: In Hochkommata setzen. So wird ein call by value sichergestellt und die Referenzen gehen nicht verloren.-->
	<fl:let>returnBoolean::=false</fl:let>
		
	<!-- Wichtig: Das Makro muss in den Zeilen vorher definiert worden sein -->
	<lessthanMacroZZZ arg1="${myInputValue01}" arg2="${myInputValue02}" resultprop="myReturnValue" />   
	<echo>${sScript}${myReturnValue}</echo> 
	<ac:if>
		<ac:equals arg1="${myReturnValue}" arg2="1" />
		<ac:then>
			<fl:let>myReturnBoolean::=true</fl:let>
		</ac:then>
		<ac:else>
			<fl:let>myReturnBoolean::=false</fl:let>
		</ac:else>		
	</ac:if>
		 		
	<!-- Rueckgabebwerte -->			
	<ac:var name="returnBoolean" value="${myReturnBoolean}" />
	<fl:let>returnControl::=true</fl:let>
	<fl:let>returnTrace::="${sScript}Alles o.k. | ${sTrace}"</fl:let>
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->
</target>

<!-- ######## Hilfstargets ############################################################################--> 	
<target name="-stringEscapeBackslashZZZ">
	<fl:let>sScript::='-stringEscapeBackslashZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<!-- Escape den Backslash. Dies in ein Hilfstarget packen, das propertyRegex mit einer Property statt Variablen arbeitet.
							   Properties aendern aber nicht ihren Wert innerhalb eines Targets, was unguenstig fuer Schleifen ist.		-->	

<!-- Scheint ein Fehler in antcontrib zu sein. Vielleicht auch alternative Lösung durch FLAKA ....
	<project xmlns:fl="antlib:it.haefelinger.flaka">

  <property name="digitA" value="42"/>
  <property name="digitB" value="23"/>
  <property name="wordA"  value="abcd"/>
  <property name="wordB"  value="efgh"/>

  <!- compare of digits ->
  <fl:when test=" '${digitA}' > '${digitB}' ">
    <echo>${digitA} gt ${digitB}</echo>
  </fl:when>

  <!- example with string compare in switch ->
  <fl:switch value="${wordA}">
    <cmp gt="${wordB}">
      <echo>${wordA} gt ${wordB}</echo>
    </cmp>
    <cmp lt="${wordB}">
    <echo>${wordA} lt ${wordB}</echo>
    </cmp>
  </fl:switch>

</project>-->
							   
	<fl:let>mysString::="${stringInput}"</fl:let>
	<fl:let>myiNumber::="${intNumber}"</fl:let><!-- wichtig: in Hochkommata setzen. Nur so wird der Wert gerettet, weil call by value-->
	<fl:let>returnControl::=false</fl:let>
						
	<!--<echo message="${sScript}myiNumber=${myiNumber}" />-->
	<ac:if>
		<ac:equals arg1="${myiNumber}" arg2="0" />
		<ac:then>
			<!-- mache nix -->
			<fl:let>mysString::="${stringInput}"</fl:let>			
		</ac:then>
		<ac:elseif>
			<ac:equals arg1="${myiNumber}" arg2="1" />
			<ac:then>
				<echo message="${sScript}0:'mysString'=${mysString}" />
			
				<!--ac:for erwartet immer ungleiche Parameterwerte. D.h. Schleife ueber ein Element geht nicht. Darum hier separat aufrufen. --> 
				<!-- Hier: 1-mal Das eigentliche Escapen aufrufen. Man beachte die voranstehenden doppelten Minuszeichen. -->
				<antcallback target="--stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
						<param name="stringInput" value="${mysString}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
				</antcallback>
				
				<!--<fl:let>mysStringNormed::='${returnString}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
				<!--<echo>${sScript}Normierter Verzeichniseintrag: ${mysStringNormed}</echo>-->
				<fl:let>mysString::='${returnString}'</fl:let>
				
			</ac:then>
		</ac:elseif>
		<ac:else>
		    <!-- Merke: AntContib islessthan funktioniert nicht als condition in ac:if (weil Bug), darum meine eigene Methode nutzen -->
			<antcallback target="-isLessThanZZZ" return="returnBoolean,returnControl,returnTrace">
				<param name="inputvalue01" value="${myiNumber}"/>					
				<param name="inputvalue02" value="0"/>	
			</antcallback>				 
			<!--<echo>${sScript}returnBoolean=${returnBoolean}</echo>-->
			<!--<echo>${sScript}returnControl=${returnControl}</echo>-->
			<!--<echo>${sScript}returnTrace=${returnTrace}</echo>-->
			<fl:let>myLessThanZero::=${returnBoolean}</fl:let>
			<ac:if>
				<ac:equals arg1="${myLessThanZero}" arg2="true" />
				<ac:then>
					<fl:fail message="${sScript}Die Anzahl der Escape - Backslash kleiner 0. Unerwarteter Parameter"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>
					<!-- 3. Reduziere die Anzahl um -1 -->	
					<!-- TODO IDEE: Dieses in einen Dateibehandlungs Scriptdef packen -->
					<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
					<var name="op1" value="${myiNumber}"/>
					<var name="op2" value="1"/>
					<var name="op" value="-"/>
					<math result="myiNumberIndexed" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
					<!--<echo>${sScript}Errechneter ubound Wert: ${myiNumberIndexed}</echo>-->
					
					
					<ac:for param="icounter" end="${myiNumberIndexed}">			
						<sequential>
							<!--<echo>${sScript}icounter ist @{icounter}</echo>-->
							<echo message="${sScript}1:'mysString'=${mysString}" />
							
							<!-- Hier: x mal Das eigentliche Escapen aufrufen. Man beachte die voranstehenden doppelten Minuszeichen. -->
							<antcallback target="--stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
									<param name="stringInput" value="${mysString}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
							</antcallback>
							
							<!--<fl:let>mysStringNormed::='${returnString}'</fl:let>--><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
							<!--<echo>${sScript}Normierter Verzeichniseintrag: ${mysStringNormed}</echo>-->
							<fl:let>mysString::='${returnString}'</fl:let>
							
						</sequential>
					</ac:for>		
				</ac:else>		
			</ac:if>									
		</ac:else>
	</ac:if><!-- Gleichheitszeichen -->
	
	<!-- Rueckgabewerte -->
	<ac:var name="returnString" value="${mysString}" />
	<!--<echo message="${sScript}'returnString'=${returnString}" />-->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnTrace" value="${sScript} Alles ok.|${sTrace}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywertzurueck -->			
</target>

<target name="--stringEscapeBackslashZZZ">
	<fl:let>sScript::='--stringEscapeBackslashZZZ: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	
	<!-- Escape den Backslash. Dies in ein Hilfstarget gepackt, da propertyRegex mit einer Property statt Variablen arbeitet.
							   Properties aendern aber nicht ihren Wert innerhalb eines Targets, was unguenstig fuer Schleifen ist.		-->		
	<fl:let>mysString::="${stringInput}"</fl:let>
	<fl:let>returnControl::=false</fl:let>
	<fl:let>returnString::="${stringInput}"</fl:let>	

	<!-- Ggfs. ist der String durch JavaScript encoded worden, dies macht z.B. arrayAppend vom mir automatisch.
	hier also erst einmal unencoden -->
	<!--<stringUnencodeJsZZZ inputstring="${mysString}" returnstring="mysStringUnencoded" returncontrol="bcontrol" />-->
	<stringUnencodeJsZZZ inputstring="${mysString}" returnstring="mysStringUnencoded"/>
	<echo message="${sScript}mysStringUnecoded = ${mysStringUnencoded}" />
	
	<!-- Das eigentliche Escapen des Backslashs -->	
	<!-- Aufruf des propertyregex Targets: Hier zum vervierfachen der Backslashe -->	
	<!-- Merke: It is important to note that when doing a "replace" operation, if the input string does not match the regular expression, then the property is not set. You can change this behavior by supplying the "defaultValue" attribute. This attribute should contain the value to set the property to in this case. 
	            d.h. nutze 'defaultValue', sonst bleibt der Rueckgabewert leer, wenn durch die RegEx-Operation nichts gefunden wird. -->
	<propertyregex property="mytemp" input="${mysStringUnencoded}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" defaultValue="${mysString}"/><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
	<!--<echo message="${sScript}mytemp = ${mytemp}" />-->
	
	<!-- wegen der vielen Zwischenschritte reicht auch das vervierfachen nicht.-->
	<!-- Aufruf des propertyregex Targets: Hier zum erneuten vervierfachen der Backslashe -->	
	<!-- Merke: It is important to note that when doing a "replace" operation, if the input string does not match the regular expression, then the property is not set. You can change this behavior by supplying the "defaultValue" attribute. This attribute should contain the value to set the property to in this case. 
	            d.h. nutze 'defaultValue', sonst bleibt der Rueckgabewert leer, wenn durch die RegEx-Operation nichts gefunden wird. -->
	<!--<propertyregex property="mytemp02" input="${mytemp}" regexp="\\" replace="\\\\\\\" global="true" />--><!-- das waere wieder verdoppeln -->
	<propertyregex property="mytemp02" input="${mytemp}" regexp="\\" replace="\\\\\\\\\\\\\\\" global="true" defaultValue="${mytemp}"/><!-- das funktioniert aber die Backslashe nur zu verdoppeln reicht nicht, hier: vervierfachen -->
	<!--<echo message="${sScript}mytemp02 = ${mytemp02}" />-->
	<fl:let>mysString::='${mytemp02}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<!--<echo message="${sScript}'mysString'=${mysString}" />-->
	
	<!-- TODO GOON 20160202, ggfs. je nachdem wie bcontrol aussieht (s. stringUnencodeJsZZZ) den String wieder in seine Encoded Form versetzten -->
	<!-- das ueber einen sFlagControl Parameter steuerbar machen. -->
	
	<!-- Rueckgabewerte -->
	<ac:var name="returnString" value="${mysString}" />
	<!--<echo message="${sScript}'returnString'=${returnString}" />-->
	<ac:var name="returnControl" value="true" />
	<ac:var name="returnTrace" value="${sScript}Alles ok.|${sTrace}" />
	<!-- <arrayCopyJsZZZ arrayinput="${myaError}" arrayreturn="returnaString" sflagcontrol="" /> --><!-- So gibt man einen Arraywert zurueck -->			
</target>

<!-- ######## Scriptdefs #############################################-->
 <!-- ########################### -->
	<scriptdef name="stringEncodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
    <attribute name="returnstring" /> 
	<attribute name="returncontrol" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
		print("Starte stringEncodeJsZZZ");
			  	
       var myString = attributes.get("inputstring");
       print("myString="+myString);
	   
	   var myReturnControl=false;

	   var textEncoded = encodeMyHtml(myString);
	   print("encoded textstring=" + textEncoded);
	  
	   //Feedback, ob etwas geändert worden ist.	  
	   if(textEncoded!=myString){			
			myReturnControl = true;
		};
	   	   	 
       project.setProperty(attributes.get("returnstring"), textEncoded);
	   project.setProperty(attributes.get("returncontrol"), myReturnControl);
	   
	   
	   //TODO: In den JSZ Kernel bringen
		function encodeMyHtml(htmlToEncode) {
		 var encodedHtml = escape(htmlToEncode);
		 encodedHtml = encodedHtml.replace(/\//g,"%2F");
		 encodedHtml = encodedHtml.replace(/\?/g,"%3F");
		 encodedHtml = encodedHtml.replace(/=/g,"%3D");
		 encodedHtml = encodedHtml.replace(/&/g,"%26");
		 encodedHtml = encodedHtml.replace(/@/g,"%40");
		 return encodedHtml;
		 //merke: mit unescape(...) bekommt man den korrekten String wieder zurück.
	   }
     ]]>
  </scriptdef>	
  
<!-- #### Scriptdefs ####################################################-->
<!-- ########################### -->
	<scriptdef name="stringUnencodeJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
	<attribute name="inputstring" />
    <attribute name="returnstring" />     
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
		print("Starte stringUnencodeJsZZZ");
		
	   //falls es die endswith funktion in dem Js noch nicht gibt hier hinzufuegen
	   //Merke: So bindet man per Prototype erzeugte, die Klassen erweiternde Methoden in dieses CDATA-Konstrukt ein.
	   //       ABER: Diese Methode darf z.B. nicht in der entsprechenden Java-Klasse vorhanden sein, sonst wird die Java-Methode gesucht, auch hinsichtlich der Methodenueberladung.
	   //             Darum heisst die Funktion hier nicht endsWith sonder endsWithPos !	   	   
	   //TODO: Dies in den ZKernel packen
	   if (!String.prototype.endsWithPos) {
		  String.prototype.endsWithPos = function(searchString, position) {
		      //position ist ein optionaler Parameter.
			  //position bedeutet, dass der String auf der Position mit dem String endet.
			  //print("typeof position: " + typeof position);
			  var mySearchString=new String(searchString);
			  var mySubjectString=this.toString();
			  if(typeof position!='undefined'){
				  if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > mySubjectString.length) {
					position = mySubjectString.length();
				  }
				  position -= mySearchString.length();
				  var lastIndex = mySubjectString.indexOf(mySearchString, position);
				  return lastIndex !== -1 && lastIndex === position;
			  }else{
				  //print("no position paramater available");
				  var myPosition = mySubjectString.length();
				  //print("mySubjectstring.length()="+myPosition);
				  //print("mySearchString="+mySearchString);
				  //print("mySearchString.length="+mySearchString.length);
				  var myPosition = mySubjectString.length()-mySearchString.length;//!!! hier duerfen keine Klammern () dies als funktion ausweisen.
				  var lastIndex = mySubjectString.indexOf(mySearchString, myPosition);
				  return lastIndex !== -1 && lastIndex === myPosition;			  
			  };
		  };
		}
	 
       var myString = attributes.get("inputstring");
       print("myString="+myString);
	  
	   //! FEHLER, BEI EINEM ENDENDEN BACKSLASH BEKOMMT MAN DEN WERT NICHT ZURUECK, darum verdoppeln.	  
		if(myString.endsWithPos('%5C')){
			print("myStringUnencoded. Abschliessenden Backslash gefunden. Verdopple ihn, sonst kann der Wert nicht zurueckgegeben werden.");
			print("myStringUnencoded. Abschliessenden Backslash gefunden. TEST: Keine Verdopplung des abschliessenden Backslashs.");
			//myString=myString+"%5C";
		};
	   
	   var myStringUnencoded=unescape(myString);	  
	   print("myStringUnencoded =" + myStringUnencoded);
	   
       project.setProperty(attributes.get("returnstring"), myStringUnencoded);
     ]]>
  </scriptdef>	
  
  <!-- ########################### -->
	<scriptdef name="stringEnsureAntValidityJsZZZ" language="javascript">
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
	<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 

	<!-- Strings duerfen keinen abschliessenden Backslash haben, sonst werden Sie beim 'antcallback' Aufruf nicht korrekt uebergeben. 
	     Darum sorgt diese Scriptdef-Methode dafür, dass ein einzelner abschliessender String 'vermehrt' wird. 
		 ABER: Verdoppeln reicht nicht, also vervierfachen! -->
	<attribute name="inputstring" />
    <attribute name="returnstring" /> 
	<attribute name="returncontrol" />    
     <![CDATA[
	 //TODO: Die Encoding Erweiterung in den JSZ - Kernel bringen.
		print("Starte EnsureAntValidityJsZZZ");
		
	   //falls es die endswith funktion in dem Js noch nicht gibt hier hinzufuegen
	   //Merke: So bindet man per Prototype erzeugte, die Klassen erweiternde Methoden in dieses CDATA-Konstrukt ein.
	   //       ABER: Diese Methode darf z.B. nicht in der entsprechenden Java-Klasse vorhanden sein, sonst wird die Java-Methode gesucht, auch hinsichtlich der Methodenueberladung.
	   //             Darum heisst die Funktion hier nicht endsWith sonder endsWithPos !	   	   
	   //TODO: Dies in den ZKernel packen
	   if (!String.prototype.endsWithPos) {
		  String.prototype.endsWithPos = function(searchString, position) {
		      //position ist ein optionaler Parameter.
			  //position bedeutet, dass der String auf der Position mit dem String endet.
			  //print("typeof position: " + typeof position);
			  var mySearchString=new String(searchString);
			  var mySubjectString=this.toString();
			  if(typeof position!='undefined'){
				  if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > mySubjectString.length) {
					position = mySubjectString.length();
				  }
				  position -= mySearchString.length();
				  var lastIndex = mySubjectString.indexOf(mySearchString, position);
				  return lastIndex !== -1 && lastIndex === position;
			  }else{
				  //print("no position paramater available");
				  var myPosition = mySubjectString.length();
				  //print("mySubjectstring.length()="+myPosition);
				  //print("mySearchString="+mySearchString);
				  //print("mySearchString.length="+mySearchString.length);
				  var myPosition = mySubjectString.length()-mySearchString.length;//!!! hier duerfen keine Klammern () dies als funktion ausweisen.
				  var lastIndex = mySubjectString.indexOf(mySearchString, myPosition);
				  return lastIndex !== -1 && lastIndex === myPosition;			  
			  };
		  };
		}
	 
	   var myReturnControl = false;
       var myString = attributes.get("inputstring");
       print("myString="+myString);
	  
	   //! FEHLER, BEI EINEM ENDENDEN BACKSLASH BEKOMMT MAN DEN WERT NICHT ZURUECK, darum verdoppeln.	  
		if(myString.endsWithPos('\\')){
			//print("myString. Abschliessenden Backslash gefunden. Verdopple ihn, sonst kann der Wert nicht zurueckgegeben werden.");
			//myString=myString+"\\";
			
			print("myString. Abschliessenden Backslash gefunden. Schneide ihn ab, sonst kann der Wert nicht zurueckgegeben werden.");
			myString=myString.substring(0,(myString.length()-1));
			myReturnControl = true;
		};
	   	   	 
	   print("myString=" + myString);
	   
       project.setProperty(attributes.get("returnstring"), myString);
	   project.setProperty(attributes.get("returncontrol"), myReturnControl);
     ]]>
  </scriptdef>	
  
<!-- ################################################################################# -->
	<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <target name="compile" depends="-myTestStringEscapeBackslash">
 <!--<target name="compile" depends="-myTestStringEscapeBackslash">-->
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
 </target>
 
<target name="-myTestStringEscapeBackslash">
	<fl:let>sScript::='-myTestStringEscapeBackslash: '</fl:let>
	<fl:let>sTrace::=""</fl:let>
	<echo>${sScript}Start</echo>
	
	<echo>##################################</echo>
	<echo>#####Fall 0 mal escapen ##########</echo>
	<echo>##################################</echo>
	<fl:let>sString2escape::='c:\test\directory\nocheins'</fl:let>
	<echo>${sScript}sString2escape=${sString2escape}</echo>
	<echo> </echo>
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escape}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="0" />					
	</antcallback>
	
	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeTemp::=${returnString}</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp): ${mysFiledirEscapeTemp}</echo>	
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo>
	
	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo>
	<!-- Beweis, dass jede Uebernahme mit Hochkommata einmal das Escapen mit Backslash wieder rueckgaengig macht. -->
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo>
	<echo> </echo>
	<echo>##################################</echo>
	<echo>#####Fall 1 mal escapen a) ohne Backslashes ##########</echo>
	<echo>##################################</echo>
	<fl:let>sString2escapeWithoutPattern::='das ist ein normaler text'</fl:let>	
	<echo>${sScript}sString2escapeWithoutPattern=${sString2escapeWithoutPattern}</echo>
	<echo> </echo>
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->	
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escapeWithoutPattern}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="1" />					
	</antcallback>
	
	<fl:let>mysFiledirEscapeTemp::=${returnString}</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp ohne byValue): ${mysFiledirEscapeTemp}</echo>	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo>	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	
	<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->

	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	<echo> </echo>
	
	<echo>##################################</echo>
	<echo>#####Fall 1 mal escapen b) mit zu escapenden Backslashes ##########</echo>
	<fl:let>sString2escape::='c:\test\directory\nocheins'</fl:let>
	<echo>${sScript}sString2escape=${sString2escape}</echo>
	<echo> </echo>
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escape}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="1" />					
	</antcallback>
	
	<fl:let>mysFiledirEscapeTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp): ${mysFiledirEscapeTemp}</echo>		<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->

	<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo>
	<!-- Beweis, dass jede Uebernahme mit Hochkommata einmal das Escapen mit Backslash wieder rueckgaengig macht. -->
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo>
	<echo> </echo>
	
	<echo>#####################################################################</echo>
	<echo>#####Fall 1 mal escapen c) mit abschliessendem Backslashes ##########</echo>
	<echo>#####                 Loesungsansatz: Zeichen abschneiden. ##########</echo>	
	<fl:let>sString2escapeEndingPattern::='c:\test\directory\nocheins\\'</fl:let><!-- muss hier mit doppeltem Backslash angegeben werden, sonst wird noch nicht mal die Variable korrekt initialisiert. -->	
	<echo>${sScript}sString2escapeEndingPattern=${sString2escapeEndingPattern}</echo>
	<echo> </echo>
	
	<!-- VOR DEM AUFRUF DES HILFSTARGETS SICHERSTELLEN, DASS DER STRINGPARAMETER VALIDE IST (fuer ant...) -->
	<stringEnsureAntValidityJsZZZ inputstring="${sString2escapeEndingPattern}" returnstring="stemp" returncontrol="btemp" />
	<echo>${sScript} btemp | stemp nach validitycheck=${btemp} | ${stemp}</echo>	
	<fl:let>sString2escapeEndingPattern::='${stemp}'</fl:let>
	<echo> </echo>
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->	
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escapeEndingPattern}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="1" />					
	</antcallback>
	
	<fl:let>mysFiledirEscapeTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp): ${mysFiledirEscapeTemp}</echo>	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo>	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	
	<ac:if>
		<ac:equals arg1="${btemp}" arg2="true" />
		<ac:then>
			<!--<fl:fail message="${sScript}Die Anzahl der Escape - Backslash kleiner 0. Unerwarteter Parameter"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
			<!-- nun wurde ein Backslash am Ende entfernt, daher wieder anhängen UND zwar verdoppelt -->
			<fl:let>mysFiledirEscapeByValueTemp::='${returnString}\\\\'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->			
		</ac:then>
		<ac:else>
			<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
		</ac:else>
	</ac:if>	
	
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	<echo> </echo>
	
	
	<echo>#####################################################################</echo>
	<echo>#####Fall 1 mal escapen c) mit abschliessendem Backslashes ##########</echo>
	<echo>#####                 Loesungsansatz: Unencoded lassen.    ##########</echo>	
	<fl:let>sString2escapeEndingPattern::='c:\test\directory\nocheins\\'</fl:let><!-- muss hier mit doppeltem Backslash angegeben werden, sonst wird noch nicht mal die Variable korrekt initialisiert. -->	
	<echo>${sScript}sString2escapeEndingPattern=${sString2escapeEndingPattern}</echo>
	<echo> </echo>
	
	<!-- der String wird per JavaScript-Def-Aufruf encoden. Das wird z.B. beim arrayAppend von mir automatisch gemacht. -->
	<stringEncodeJsZZZ inputstring="${sString2escapeEndingPattern}" returnstring="stemp" returncontrol="btemp" />
	<echo>${sScript} btemp | stemp nach stringEncode=${btemp} | ${stemp}</echo>	
	<fl:let>sString2escapeEndingPattern::='${stemp}'</fl:let>
	<echo> </echo>
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->	
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escapeEndingPattern}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="1" />					
	</antcallback>
	
	<fl:let>mysFiledirEscapeTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp): ${mysFiledirEscapeTemp}</echo>	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo>	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
		
	<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	<echo> </echo>
	
		
	<echo>###################################################################</echo>
	<echo>#####Fall 2 mal escapen a) mit zu escapenden Backslashes ##########</echo>
	<fl:let>sString2escape::='c:\test\directory\nocheins'</fl:let>
	<echo>${sScript}sString2escape=${sString2escape}</echo>
	<echo> </echo>
	
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escape}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="2" />					
	</antcallback>
	
	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeTemp::=${returnString}</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp ohne byValue): ${mysFiledirEscapeTemp}</echo>	
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo>
	
	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo>
	<!-- Beweis, dass jede Uebernahme mit Hochkommata einmal das Escapen mit Backslash wieder rueckgaengig macht. -->
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo>
	<echo> </echo>
		
	<echo>###################################################################</echo>
	<echo>#####Fall 2 mal escapen b) mit abschliessendem Backslash ##########</echo>
	<echo>#####               Loesungsansatz: Zeichen abschneiden. ##########</echo>
	
	<fl:let>sString2escapeEndingPattern::='c:\test\directory\beachteEndung\\'</fl:let><!-- muss hier mit doppeltem Backslash angegeben werden, sonst wird noch nicht mal die Variable korrekt initialisiert. -->	
	<echo>${sScript}sString2escapeEndingPattern=${sString2escapeEndingPattern}</echo>
	<echo> </echo>
	
	<!-- VOR DEM AUFRUF DES HILFSTARGETS SICHERSTELLEN, DASS DER STRINGPARAMETER VALIDE IST (fuer ant...) -->
	<stringEnsureAntValidityJsZZZ inputstring="${sString2escapeEndingPattern}" returnstring="stemp" returncontrol="btemp" />
	<echo>${sScript} btemp | stemp nach validitycheck=${btemp} | ${stemp}</echo>	
	<fl:let>sString2escapeEndingPattern::='${stemp}'</fl:let>
	<echo> </echo>
	
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escapeEndingPattern}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="2" />					
	</antcallback>
	
	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeTemp::=${returnString}</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp ohne byValue): ${mysFiledirEscapeTemp}</echo>
	
	<fl:let>mysFiledirEscapeValue::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeValue}</echo>
	
	<ac:if>
		<ac:equals arg1="${btemp}" arg2="true" />
		<ac:then>
			<!--<fl:fail message="${sScript}Die Anzahl der Escape - Backslash kleiner 0. Unerwarteter Parameter"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
			<!-- nun wurde ein Backslash am Ende entfernt, daher wieder anhängen UND zwar verdoppelt -->
			<fl:let>mysFiledirEscapeByValueTemp::='${returnString}\\\\\\\\'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo> 	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->			
		</ac:then>
		<ac:else>
			<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
			<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
			<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo>				
		</ac:else>
	</ac:if>	
	
	<!-- Beweis, dass jede Uebernahme mit Hochkommata einmal das Escapen mit Backslash wieder rueckgaengig macht. -->
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo>
	<echo> </echo>
	
	<echo>##################################</echo>
	<echo>##### Fehlerfall -1 mal escapen ###</echo>
	<!-- Hier wird das Hilfstarget aufgerufen -->
	<!-- Nur einmal escapen reicht nicht, intern es muss x-mal escaped werden, da bei der Umwandlung zu String immer ein escapender Backslash verloren geht.-->
	<antcallback target="-stringEscapeBackslashZZZ" return="returnControl,returnTrace,returnString">					
		<param name="stringInput" value="${sString2escape}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->	
		<param name="intNumber" value="-1" />					
	</antcallback>
	
	<!-- Beweis, dass die Referenz verloren geht ohne 'byValue' Übernahme durch Hochkommata. -->
	<fl:let>mysFiledirEscapeTemp::=${returnString}</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp): ${mysFiledirEscapeTemp}</echo>	
	<fl:let>mysFiledirEscapeValue::='${mysFiledirEscapeTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (ohne byValue): ${mysFiledirEscapeValue}</echo>
	
	<!-- Beweis, dass die Referenz erhalten bleibt durch 'byValue' Übernahme durch Hochkommata -->
	<fl:let>mysFiledirEscapeByValueTemp::='${returnString}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (temp mit byValue): ${mysFiledirEscapeByValueTemp}</echo>
	<!-- Beweis, dass jede Uebernahme mit Hochkommata einmal das Escapen mit Backslash wieder rueckgaengig macht. -->
	<fl:let>mysFiledirEscapeByValue::='${mysFiledirEscapeByValueTemp}'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
	<echo>${sScript}Escapeter Verzeichniseintrag (mit byValue): ${mysFiledirEscapeByValue}</echo>
</target> 

</project>