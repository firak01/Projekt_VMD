<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_JAZUsedByJavaScript"  default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">

	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<!-- gebraucht wird das z.B. für den <for> </for> Task. -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>

  <!-- ######## Scriptdefs ############################################################################--> 

 <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_import_javaScriptJs" language="javascript">
     <attribute name="inputtestvalue" />
     <attribute name="returnboolean" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[				        
			var myTestvalue = attributes.get("inputtestvalue");
		
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objControl=new Object();		
			var bReturn=tryout_import_javascript(myTestvalue,objControl);	
			project.setProperty(attributes.get("returnboolean"),bReturn);
			project.setProperty(attributes.get("returncontrol"),objControl.bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),objControl.sReturnControl);	
		
			function tryout_import_javascript(myTestvalue,objControl){
			try{											
				//#######################
				//#### FUNKTIONSRUMPF ######	 
				var objControlCaller=new Object();
				var sScript=reflectMethodCurrent_Name(null, objControlCaller);
				if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
				sScript=sScript+": ";
				print(sScript+"START");
				print(sScript+"Error objekt im Zusammenspiel mit JAVA");
				
				enableJava();
		
				//Weil im ErrorHandler ExceptionZZZ auftaucht, muss vorher diese Java Klasse importiert werden!
				//Allgemein für Import Statements gilt:
				//importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
				//                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
 
				//import statements, funktionieren beide
				//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
				//importPackage(basic.zBasic.util.datatype.string);
				importClass(Packages.basic.zBasic.ExceptionZZZ);
				importPackage(Packages.basic.zBasic.util.file);
				
				//########################
				//#### EINGABEPARAMETER ######	 				
				//var myTestvalue="";  ////NOCH KAPUTT 20160402: Damit wird der Fehler erzwungen
				print("myTestvalue="+myTestvalue);
		
				var bReturn = false;
				var bReturnControl = false; //Zumindest Fehler zurückgegen, wenn der Programmablauf (z.B. im Errorhandling) nicht so ist wie erwartet.
				var sReturnControl = sScript+"Fehler."; 
				
				//#####################
				//#### VERARBEITUNG ######	 

				//#### Java, etc.
				var bErg=false;
				//bErg = FileEasyZZZ.isRoot(myTestvalue);
							
				eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( 'tryoutAnt_ImportJavascriptJs.js' ) ) );
				bErg = tryoutFunctionForImport(myTestvalue);	
				print("bErg="+bErg);
				
				print("#######################");
				bReturn=bErg;
				bReturnControl = true;
				sReturnControl = "Alles o.k.";
         
					//Doku:
					//Von der Reihenfolge der catches wäre notwendig: Erst die genau definierten Fehler abfangen, dann die allgemeinen.
					//Da dies in einer einzelnen Funktion gekapselt werden soll, machen wir einen catch und darin if - Abfragen.
					//}catch (err if err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO, 
					//		myReturnControlString = "Error: " + err.javaException.getMessageLast();
					//.................................................	
					//}catch (err if err.instanceof ExceptionZZZ) {  // So geht das nur mit NASHORN, 
					//    myReturnControlString = "Error: " + err.getMessageLast();
					//}catch(err){
					// ................................................
					//}	
				
				
				}catch(err) {
					//#### ERROR HANDLING #######
					print("Fehler gefangen: " + err);
					try{																
						//Wende Funktion an, zur Ermittlung der aktuellen Funktion
						var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
						var myErrorString = handleError(err,objControlErrh);
						if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
						bReturnControl = false;
						sReturnControl= myErrorString;				
					}catch(e){
						print(e);					
						bReturnControl=false;
						sReturnControl=sScript+"Fehler im ErrorHandling. "+ e;
					}
				}
				print("zuruegegebener controlstring:" + sReturnControl);
				objControl.sReturnControl=sReturnControl;				
				objControl.bReturnControl=bReturnControl;	
				return bReturn;
			}//end function tryout...
						
			
			//#############################################
			//### ERROROHANDLING
			//#############################################		
			function handleError(err,objControl){				
				var sReturn="nix";
				var sReturnControl="Fehler im handleError";
				var bReturnControl=false;
				try{
					var objControlCaller=new Object();
					var sScript=reflectMethodCurrent_Name(null, objControlCaller);
					sScript = sScript + ": ";
					print("##### in " + sScript + " ############################");
				
					//TEST: Versuche aus dem uebergebenen Error-Objekt weitere Infos zu holen
					//PROBLEM: Bei einem geworfenen Java Fehler wird hier kein korrekter Stacktrace und damit auch kein Funktionsname gefunden.
					//                 Versuche also einen eigenen Stacktracktrace zu machen und hole davon dann den "Namen der aufrufenden Funktion".
					var myFunctionCallingName=reflectMethodCalling_Name(null,objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error("Fehler beim Ermittlen des aufrufenden Funktionnamens im ErrorHandling: " + objControlCaller.sReturnControl);					
					print("gefundener aufrufender Funktionsname: " + myFunctionCallingName);
					
					var myFunctionCurrentName = reflectMethodCurrent_Name(null, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error("Fehler beim Ermittlen des aktuellen Funktionnamens im ErrorHandling: " + objControlCaller.sReturnControl);					
					print("gefundener aktueller Funktionsname: " + myFunctionCurrentName);
					
					var myFunctionErrorFoundName="";
					if(err!='undefined' && err!=null){
						var myFunctionErrorName=reflectMethodCurrent_Name(err, objControlCaller);
						if(!objControlCaller.bReturnControl) throw new Error("Fehler beim Ermittlen des letzten Funktionnamens im ErrorHandling: " + objControlCaller.sReturnControl);					
						print("gefundener error Funktionsname: " + myFunctionErrorName);
						myFunctionErrorFoundName = myFunctionErrorName;
					}else {
						myFunctionErrorFoundName = myFunctionCallingName;
					}
					
					
				//TODO GOON TODO GOON NOCH KAPUT 20160402
				
				//JAVA 7 (Rhino), hier wird nichts ausgegeben, schade.	Stack ist undefined.
				//JAVA 8 (Nashorn), hier wird die Zeilenummer ausgegeben.
				//print("TEST, neues ErrorObjekt erzeugen und die Zeilennummer ausgeben: "  + (new Error).lineNumber);			
				
				print("##### in handle Error fuer den Java-Fehler");				
				print("Error Objekt: " + err);
				print("Fehlerobjekt Zeilennummer: " + err.lineNumber);
				print("Fehlerobjekt Dateiname: " + err.fileName);
																
				//Aber: Wir wollen auf ein ExceptionZZZ Objekt zugreifen. Seit Aenderung der Javascript Engine in Nashorn ist dies Unterschiedlich.
				//                                                                                       In Nashorn steht das Objekt direkter zur Verfügung.
				if(err instanceof ExceptionZZZ) {  //So geht das nur mit NASHORN.
					print("################################");
					print("ExceptionZZZ Fehler abgefangen (NASHORN, Java 8)");
					print("err.getMessageLast()="+ err.getMessageLast());  //DIE LÖSUNG MIT NASHORN !!!!
					print("err.getFunctionLast()="+ err.getFunctionLast());  //DIE LÖSUNG MIT NASHORN !!!!
							
					sReturn = myFunctionErrorFoundName + ": ExceptionZZZ: '" + err.getFunctionLast() + " - " + err.getMessageLast() + "'.";
					sReturnControl="Alles o.k."; //Das Errorhandling an sich ist o.k.
					bReturnControl=true;
				}else if(err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO !!!
					print("################################");
					print("ExceptionZZZ Fehler abgefangen (RHINO, Java 7)");
					print("err.javaException.getMessageLast()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
					print("err.javaException.getFunctionLast()="+ err.javaException.getFunctionLast());  //DIE LÖSUNG MIT NASHORN !!!!
							
					sReturn = myFunctionErrorFoundName + ": ExceptionZZZ: '" + err.javaException.getFunctionLast() + " - " + err.javaException.getMessageLast() + "'.";
					sReturnControl="Alles o.k."; //Das Errorhandling an sich ist o.k.
					bReturnControl=true;
										
				}else{
				   //weitere, unbestimmte Fehler abfangen
				   print("################################");
				   print("Unbestimmten Fehler abfangen.");
				   var version = java.lang.System.getProperty("java.version");
				   print("JavaVersion: " + version);
				   print("typeof err: "+typeof(err));					   
					if(version.substring(0,3)=="1.8"){
						print ("Javascript Engine: 'Nashorn'");
						print("Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
						
						sReturn = myFunctionErrorFoundName + ": " + typeof(err) + ": '" + err.message + "'.";												
						sReturnControl="Alles o.k."; //Das Errorhandling an sich ist o.k.
						bReturnControl=true;
					
					}else{
						print("################################");
						print ("Javascript Engine: 'Rhino'");
						print("err.contructor.name="+err.constructor.name);	//In Rhino wird der Fehler nicht direkt zurückgegeben.			
						if(err.constructor.name=='JavaException'){
							print("Error.name=" + err.name);
							print("Error=" + err);
							print("Error.getCause=" + err.getCause); //Ergebnis: undefined
							//print("Error.getCause()=" + err.getCause());
							print("Error.message: " + err.message);//Ergebnis der Ausgabe: basic.zBasic.ExceptionZZZ: null;
							//print("Error.message(): " + err.message());//Ergebnis: Es wird ein Fehler geworfen 'is not a function, it is "string"
							//print("Error: " + err.getMessageLast());//Ergebnis: Es wird ein Fehler geworfen 'cannot find function getMessageLast in object JavaException
							//print("Error: " + err.getMessageLast);//Ergebnis: dito, kein Unterschied zu getMessageLast()
							print("err.javaException.getMessage()="+ err.javaException.getMessage());  //DIE ALLGEMEINE LÖSUNG MIT RHINO !!!!
							print("err.rhinoExcption.getScriptStackTrace()="+err.rhinoException.getScriptStackTrace());
							
							sReturn = myFunctionErrorFoundName + ": JavaException: '" + err.javaException.getMessage() + "'.";
							sReturnControl="Alles o.k.";
							bReturnControl=true;
						}else{
							print("normaler Fehler.  Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							sReturn = myFunctionErrorFoundName + ": Error: " + err.message;
							sReturnControl="Alles o.k."; //Das Errorhandling an sich ist o.k.
							bReturnControl=true;
						}									
					}
				}		

					}catch(e){
						print(e);					
						bReturnControl=false;
						sReturnControl=sScript+"Fehler im ErrorHandling. "+ e;
					}	
				//print("zuruegegebener controlstring in JS-Unter-Funktion:" + sReturnControl);
				objControl.sReturnControl=sReturnControl;			
				objControl.bReturnControl=bReturnControl;	
				return sReturn;
		}//End function handleError	
			
			//###############################################################
			//### REFLECTION 
			//###############################################################
			function reflectMethodCurrent_Name(myError, objControl){
				var sScript="reflectMethodCurrent_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				try{	                    
					var objControlCaller = new Object();
					var sLine=reflectMethodCurrent_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					//print(sScript +"sLine="+sLine);
												
					var sMethod=reflectMethod_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
				
			//#################################################################
			function reflectMethodCurrent_StackLine(myError, objControl){
				var sScript="reflectMethodCurrent_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";				
				try{
					var objControlCaller = new Object();
				    //Java7 funktioniert? var sCallerLine=reflectMethod_StackLine(myError, 3, objControlCaller);
					//Java8 Fall, ohne übergebenen Error Objekt. Dann muss nämlich der Stack erst errechnet werden: funktioniert mit zwei weiteren mehr? 
					var sCallerLine=reflectMethod_StackLine(myError, 5, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
										
					//print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
			
			//#################################################################
			function reflectMethodCalling_Name(myError, objControl){
				var sScript="reflectMethodCalling_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				var objControlCaller = new Object();
				try{	
                    var sMethod="";							
					
					var sLine=reflectMethodCalling_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					//print(sScript +"sMethodCallingLine="+sLine);
												
					sMethod=reflectMethod_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
			
			//#################################################################
			function reflectMethodCalling_StackLine(myError, objControl){
				var sScript="reflectMethodCalling_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
				try{
					var objControlCaller = new Object();
				    //Java7: funktioniert? var sCallerLine=reflectMethod_StackLine(myError,4, objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					//Java8 Fall, ohne übergebenen Error Objekt. Dann muss nämlich der Stack erst errechnet werden: funktioniert mit zwei weiteren mehr? 
					var sCallerLine=reflectMethod_StackLine(myError,6, objControlCaller); //iIndex um einen mehr als bei ...MethodCurrent...
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
										
					//print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
						
	//#####################################################################
	//### REFLECTION-COMMON Funktionen, sowohl für current als auch für calling Methodennamen
	//#####################################################################
			function reflectMethod_StackLine(myError, iIndex, objControl){
				var sScript="reflectMethod_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
								
				try{
				    var sCallerLine="";
					
					if(iIndex=='undefined' || iIndex==null){
						iIndex=3;//-1 wg. Index an sich, -1 weil es eine Unterfunktion entweder von ....current oder ...calling ist, -2 wg. der Tatsache, dass man DIESE Funktion nicht haben will, sondern die aufrufende.
					}					
				
					var objControlCaller = new Object();
					var bIsJava7=isJava7(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//Merke Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					//ACHTUNG: Wir Suchen als Funktion das VORLETZTE Element in dem Array
					if(bIsJava7){		
						print(sScript+"7: Ausfuehrung unter Java7");					
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								print(sScript+"7: Stack im Error Objekt vorhanden");
								var saStacktrace = myError.stack.split("\n");						
								//print(sScript + "7: Vorhandener StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								//print(sScript + "7: iuBound="+iuBound);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}
								sCallerLine = saStacktrace[(iIndex)];
							} else {
								//Normal in Java7, da kein Stacktrace im error-objekt vorhanden ist.
								print(sScript+"7: KEIN Stack im Error Objekt vorhanden");
								var saStacktrace=createStackTrace();
								//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								//print(sScript + "7: iuBound="+iuBound);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}
								sCallerLine = saStacktrace[(iIndex)];
							}				
						}else{
							print(sScript+"7: KEIN Error Objekt vorhanden");
							var saStacktrace=createStackTrace();
							//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
							var iuBound=saStacktrace.length-1;
							//print(sScript + "7: iuBound="+iuBound);
							if(iIndex>iuBound){
								iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
							}
							sCallerLine = saStacktrace[(iIndex)];
						}					
					}else{
						print(sScript+"8: Ausfuehrung unter Java8");
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								//Java 8, NASHORN funktioniert.
								print(sScript + "8: Error Stack vorhanden");
								//print(sScript + "8: Error Stack=" + myError.stack);
								var saStacktrace = myError.stack.split("\n");
								print(sScript + "8: Gefundener StackTrace=" + saStacktrace);
								var iuBound=saStacktrace.length-1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}			
								var iIndexToBeUsed=1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
								sCallerLine = saStacktrace[(iIndexToBeUsed)];
							} else {
								//Ungewöhnlich in Java 8 - wenn kein error-objekt vorhanden ist, vermutlich wurde kein Error Objekt übergeben.
								print(sScript + "8: KEIN Error Stack vorhanden OBWOHL Error Objekt vorhanden ist.");														
								var stack=createStackTrace();
								var saStacktrace = stack.split("\n");
								print(sScript + "8: Erstellter StackTrace=" + saStacktrace);	
								var iuBound=saStacktrace.length-1;									
								print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
								if(iIndex>iuBound){
									iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
								}									
								var iIndexToBeUsed=iIndex+1;
								print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
								sCallerLine = saStacktrace[(iIndexToBeUsed)];
							}				
						}else{
							//Vermutlich Java7, da kein Stacktrace im error-objekt vorhanden ist.
							print(sScript + "8 ohne ErrorObjekt");
							
							var stack=createStackTrace();
							var saStacktrace = stack.split("\n");
							print(sScript + "8 ohne ErrorObjekt=" + saStacktrace);	
							var iuBound=saStacktrace.length-1;
							print(sScript + "8: iuBound="+iuBound+"; iIndex="+iIndex);
							if(iIndex>iuBound){
								iIndex=iuBound-2; //-1, weil der letzte Wert nicht interessiert, sondern der vorletzte, -1 weil wir in der UnterUnterfunkton sind.
							}								
							var iIndexToBeUsed=iIndex;
							print(sScript + "8: iuBound="+iuBound+"; iIndex to be used="+iIndexToBeUsed);								
							sCallerLine = saStacktrace[(iIndexToBeUsed)];
						}
					}
					print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethod_StackLine
	
	//#################################################################
	function reflectMethod_StackMethodFromLine(sStackLine, objControl){
		var sScript="reflectMethod_StackMethodFromLine: ";
		var sReturn = sStackLine;					
		var bReturnControl=false;
		var sReturnControl=sScript+"Fehler";
		try {
			if(undefined==sStackLine || null==sStackLine) throw new Error(sScript+"Parameter Stacktrace-Zeile fehlt.");
												
			var objControlCaller=new Object();
			var bJava7=isJava7(objControlCaller);					
			if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
			
			var clean2="";
			if(bJava7){
				//print(sScript+"Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf(" (");
				var clean = sStackLine.slice(index+2, sStackLine.length);
				
				var index2 = clean.indexOf(")");							
				if(index2>=1){
					clean2 = clean.substring(0,index2).trim();
				}else{
					clean2 = clean.trim();
				}			
			} else {
				//Java8
				//print(sScript+"NICHT Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf("at ");
				//print(sScript+"index="+index);
				var clean = sStackLine.slice(index+2, sStackLine.length);						
				//print(sScript+"clean="+clean);
				
				
				index = clean.indexOf(" (");
				var clean = clean.substring(0,index);
				//print(sScript+"clean="+clean);
				
				clean2 = clean.trim();
			}
			sReturn=clean2;					
			bReturnControl=true;
			sReturnControl=sScript + "Alles o.k.";
		}catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		objControl.bReturnControl=bReturnControl;
		objControl.sReturnControl=sReturnControl;								
		print(sScript+"sReturn="+sReturn);
		return sReturn;
	}//End function reflectMethod_StackMethodFromLine
			
    //#########################################
	//### Hilfsfunktion zur Generierung eines Stacktraces. Als Workaround für Java7. 
	//#########################################			
	function createStackTrace() {
	  var sScript="createStackTrace: ";
	  var callstack = [];
	  var isCallstackPopulated = false;
	  try{
		var objControlCaller=new Object();
		var bJava7=isJava7(objControlCaller);					
		if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
		
if(bJava7){		
	   print(sScript+"Java7 Fall");
	  //+++ Java7 Fall
	  try {
		i.dont.exist+=0; //doesn't exist- that's the point
	  } catch(e) {
		if (e.stack) { //Firefox
			//print("ffox");
			//print(e.stack);
		  var lines = e.stack.split('\n');
		  for (var i=0, len=lines.length; i<=len-1; i++) {
			//print(i + ": '" + lines[i].trim() +"'");
			//klappt hier nicht....  if (lines[i].trim().match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			if (lines[i].trim()!=''){
			  //print("line used");
			  callstack.push(lines[i]);
			}else		 {
			  //print("empty line NOT used");  				
			}
		  }
		  
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
		else if (window.opera && e.message) { //Opera
			print("opera  untested");
		  var lines = e.message.split('\n');
		  for (var i=0, len=lines.length; i<len; i++) {
			if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			  var entry = lines[i];
			  //Append next line also since it has the file info
			  if (lines[i+1]) {
				entry += ' at ' + lines[i+1];
				i++;
			  }
			  callstack.push(entry);
			}
		  }
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
	  }
	  if (!isCallstackPopulated) { //IE and Safari
		print("ie untested");
		var currentFunction = arguments.callee.caller;
		while (currentFunction) {
		  var fn = currentFunction.toString();
		  var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('')) || 'anonymous';
		  callstack.push(fname);
		  currentFunction = currentFunction.caller;
		}
	  }
	  //+++ ENDE Java7 Fall
	  //+++ START Java8 Fall
	  }else{
		print(sScript+"Java8 Fall");
		try {
			var objError = new Error();
			callstack=objError.stack;
		} catch(e) {
		
		}
	  
	  
	  }
	  }catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		//+++ ENDE Java8 Fall
	  
	  output(sScript, callstack);
	  return callstack;
	}

	function output(sScript, arr) {
	  //Optput however you want
	  //alert(arr.join('\n\n'));
	  print(sScript +"arr="+ arr);
	  //print(arr.join('\n\n'));
	}			
			
			
	//#############################################
    //### Hilfsfunktion JAVA
	//#############################################	
		function isJava7(objControl){	
			var sScript="isJava7: ";
			var bReturn = false;
			var bReturnControl=false;
			var sReturnControl=sScript+"Fehler";
			try {			
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				if(version.substring(0,3)=="1.7"){
					bJava7found=true;
				}else {
					bJava7found=false;
				}
				
				bReturn=bJava7found;
				bReturnControl=true;
				sReturnControl=sScript + "Alles o.k.";
			}catch(err){
				//#### SIMPLES ERROR HANDLING #######
				//print(err);					
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;					
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;								
			return bReturn;
		}//End function isJava7
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
					print("Verwende das alte Rhino unter Java 8");
				}catch(e){
					print("Verwende Standard JavaScript Engine dieser Java Vesion.");
				}
			}//End function enableJava
						
	      ]]>
  </scriptdef>        
  
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!--<target name="compile" depends=" -myTryoutImport_JavaScript,">-->
 <target name="compile" depends="-myTryoutImport_JavaScript">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>

	<target name="-myTryoutImport_JavaScript">
		<fl:let>sScript::='-myTryoutImport_JavaScript: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
			 
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		  <fl:let>myInputTestvalue::="Ein Testwert Mit Leerzeichen"</fl:let>
		 <echo>${sScript}myInputTestvalue='${myInputTestvalue}'</echo>
		<tryout_import_javaScriptJs inputtestvalue="${myInputTestvalue}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		 
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
	</trycatch>
		
		
	</target> 
 </project>