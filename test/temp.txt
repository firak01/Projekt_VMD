<target name = "snippet_b">

			<fl:choose>
		<fl:when test=" '${myaFilePathSize}'=='1'>">
			<!-- AB) Links Verzeichnis = Rechts nur ein Eintrag -->
			<echo>Rechts steht nur ein Wert... : ${myRightPart}</echo>
			<ac:if> 
				<ac:equals arg1="${myisdirectoryRightPart}" arg2="true" />
				<ac:then>
						<echo>Links Dateipfad / Rechts Verzeichnisname.</echo>
						
							<!-- Erst wenn der rechte Teil auch keinen Dateinamen hat: ABBRUCH -->
							<!-- TODO: Wenn der linke Teil ein Verzeichnis ist, alle Dateien darin kopieren, sofern der rechte Teil auch ein Verzeichnis ist. -->
							<echo>ABBRUCH: Keinen Dateinamen gefunden.</echo>
							<fl:fail message="Keinen Dateinamen gefunden. Linker Teil der Steuerungsanweisung ist ein Verzeichnis '${myLeftPart}' und rechter Teil ebenfalls '${myRightPart}'."  /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
				</ac:then>
				<ac:else>
						<echo>Links Dateipfad / Rechts Dateiname.</echo>																		
				</ac:else>
			</ac:if>
		</fl:when>
		<fl:otherwise>
			<!-- BBB) Links Dateipfad = Rechts Dateipfad -->
			<echo>Links Dateipfad / Rechts steht ein Dateiname inklusive Pfad: ${myRightPart}</echo>
													
			<!-- 3. Ermittle die letzte Indexposition und damit den Dateinamen -->
			<!-- TODO: Array Scriptdef, um den wert an einer Indexposition zu bekommen,
					   Array Scriptdef, um den Wert an der letzten Indexposition zu bekommen. -->													   
			<!-- von der Anzahl der Werte -1 abziehen, um den Index zu bekommen -->
			<var name="op1" value="${myaFilePathSize}"/>
			<var name="op2" value="1"/>
			<var name="op" value="-"/>
			<math result="index" operand1="${op1}" operation="${op}" operand2="${op2}" datatype="int"/>
			<echo>Errechneter wert fuer Index des letzten Pfadteils: #{index}</echo>
			<fl:let>
				xtractedvalue ::= split('${myLeftPart}','\\\\')[${index}]; <!-- man muss erneut split aufrufen. Das geht nicht <echo>An letzter Stelle gefundener wert: #{'${src.fileadir}[${index}]'}</echo> -->
			</fl:let>
			<echo>An letzter Stelle gefundener wert: #{xtractedvalue}</echo>	
			<fl:let>dest.filename ::= ${xtractedvalue}</fl:let>
														
			<!-- 4. Füge den Dateinamen hinter den Pfad, der von der linken Seite kommt hinzu, wenn auf der rechten Seite kein Pfad vorhanden ist. -->
														
			<!-- 4.1 mache aus dem linken Teil nun ein Array. -->
			<fl:let>src.fileapath ::= split('${myLeftPart}','\\\\')</fl:let>
			<echo>Nach dem split: ${src.fileapath}</echo>
																																	
			<!-- TODO: Array Aufaddieren von indexposition x bis zu einer anderen Indexposition
						arrayStringImplode mit den Parametern sSeparator, ilBound, iuBound -->
			<!-- TODO: An den so implodierten String das \\extractedvalue anhängen. -->
		</fl:otherwise>
	</fl:choose>											
											


</target>

<target name="FglCopyLocal_CopyUsingPropertyArrays">
<!-- START: codeschnipsel wieder eingefügt... -->
											
					
											
								   						   
<!-- ENDE: codeschnipsel wieder eingefügt... -->
</target>

<target name = "myCase_A">

    <!-- TODO: Hole den Dateinamen aus dem rechten Teil -->
													<!-- TODO GOON: Hole den Namen des Verzeichnisses (als Pfad), hole den Dateinamen -->
													<!-- TODO GOON: 20150622 HIER die Indexberechnung und ggfs. sogar das holen des letzten Werts als Scriptdef.
																				Momentan bestehende Scriptdefs anwenden -->													
													<fl:let>dest.fileapath ::= split('${myRightPart}','\\\\')</fl:let>													
													<echo>Nach dem split: ${dest.fileapath}</echo>
													
													<arrayElementCountJsZZZ arrayinput="${dest.fileapath}" ireturn="myaFilePathSize"/>
													<echo>Groesse dest.fileapath per scriptdef Aufruf: ${myaFilePathSize}</echo>
																						
													<!-- <fl:for var="mydir" in="split('${myLeftPart}','\\\\')"> -->
													<!-- <echo>Pfadbestandteil: #{mydir}</echo --><!-- Aufruf der Variablen als EL Expression -->
													<!-- </fl:for> -->
													
													<!-- snippet B hier einfügen -->

</target>

<target name="snippet_X">


													<!--	 Ermittle den Ausgangsdateipfad und den -namen -->
																											
														<!-- Prüfe, ob der rechte Teil ein Verzeichnis ist... -->
														<!-- Falls JA: Hole vom linken Teil den Dateinamen und hänge ihn an das Verzeichnis an -->
														<!-- Falls NEIN: Nimm das Verzeichnis, wie es ist. -->																												
														<isDirectoryZZZ text="${myRightPart}" property="myisdirectoryRightPart" /><!-- anwenden der oben definierten scriptdef funktion isdirectory -->
														<echo>Rechter Teil: isdirectory=${myisdirectoryRightPart}</echo>			
													
														<isBooleanZZZ valueinput="${myisdirectoryRightPart}" valuereturn="myBooleanValue" isboolean="myValueIsBoolean" /><!-- anwenden der oben definierten scriptdef funktion -->
														<ac:if>
															<ac:equals arg1="${myBooleanValue}" arg2="true"/>
															<ac:then>
																<!-- BA) Links Dateipfad = Rechts Verzeichnis -->
																<echo>Rechter Teil (nach...) ${myRightPart} ist ein Verzeichnis </echo>
																<fl:let>dest.filedir ::= ${myRightPart}</fl:let>
																<fl:let>dest.filename ::= ${src.filename}</fl:let>
															</ac:then>
															<ac:else>
																<!-- BB) Links Dateipfad = Rechts KEIN Verzeichnis (vermutlich Datei) -->
																<echo>Rechter Teil (nach...) ${myRightPart} ist KEIN Verzeichnis </echo>
															</ac:else>
														</ac:if>
																
			<fl:echo>dest.filedir => ${dest.filedir}</fl:echo>
			<fl:echo>dest.filename => ${dest.filename}</fl:echo>
														

													
									

</target>



