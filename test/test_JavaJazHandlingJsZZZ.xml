<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_JAZUsedByJavaScript"  default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">

	 <!-- ### Notepad++ Hotkeys:
        ALT + 0, ALT +1, .... XML Tags der Ebene zusammenklappen. -->
    
   	<!-- ### Einbinden der ZKernel - Ant Bibliotheken. Darin liegen die Scriptdefs an einer zentralen Stelle. ### -->
	<!--     Die Definiton von basedr in diesem aufrufenden Projekt hat scheinbar keine Auswirkung. Man muss ../ davorsetzen. -->
	<!--     Erstellt man in diesem importierenden Projekt ein importiertes Target, so wird das importierte Target überschrieben. -->
	<!--<import file="../scriptdef/ZAnt_basic_zBasic_util_datatype_arrayZZZ.xml"/>-->

	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<!-- gebraucht wird das z.B. für den <for> </for> Task. -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>

  <!-- ######## Scriptdefs ############################################################################--> 

 <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_string_camelcase" language="javascript">
     <attribute name="inputstring" />
	 <attribute name="returnstring" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[
				var myString = attributes.get("inputstring");
			
			var sReturn=""; 
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";
		
			//Die benoetigten Kernel-Funktionen laden
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objKernelLibs = new Array();
			var objControlCaller=new Object();
			var bReturn = enableKernelAntJs(objKernelLibs, "", objControlCaller);
			if(!objControlCaller.bReturnControl){								
				bReturn=false;
				sReturn="";
			}else{										
				sReturn=tryout_jaz_stringCamelcase(objKernelLibs,myString, objControlCaller);		
				if(!objControlCaller.bReturnControl){									
					bReturn=false;
					sReturn="";
				}else{					
				}
			}	
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			//project.setProperty(attributes.get("returnboolean"),bReturn);
			project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);

			//###################################################################
            //#### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verfügung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k."
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
		//#################################################################################################
			function tryout_jaz_stringCamelcase(objKernelLibs, myString, objControl){	 			
				var sScript = "tryout_jaz_stringCamelcase: ";
				var sReturn="nixnix"; 
				var bReturnControl=false;
				var sReturnControl="Fehler";	
				
				try{															
					//IN JEDER FUNKTION DAS LADERN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG					
					if(objKernelLibs==undefined || objKernelLibs==null){
						print("Keine Kernel Ant Js Libs uebergeben.");
					} else {						
						if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
							print("Keine Kernel Ant Js Libs vorhanden zum Laden");
						} else {
							print("Loading Kernel Ant Js Libs: " + objKernelLibs.length);
							for (var i = 0; i < objKernelLibs.length; i++) { 	
								//print("Lib: " + objKernelLibs[i]["Alias"]);					
								//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
								//funktioniert: 
								eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
								//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
							}
						}
					}
					print("#######################");								
					enableJava();
		   
					//Allgemein für Import Statements gilt:
					//importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
					//                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
					// import statements, funktionieren beide
					//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
					//importPackage(basic.zBasic.util.datatype.string);
					importPackage(Packages.basic.zBasic.util.datatype.string);
	 
					var test = java.lang.System.getProperty("java.class.path");
					println("classpath="+test);
		
					 //#### EINGABE ######	 
					print("myString="+myString);
					
					//#### Java, etc.
					sReturn = StringZZZ.toCamelCase(myString,"_");
					print("sReturn="+sReturn);
					
					sReturnControl=sScript+"Alles o.k.";
					bReturnControl=true;
					
					}catch(err){	
						print("Fehler gefangen: " + err);
						//#### SIMPLES ERROR HANDLING #######							
						//bReturnControl=false;
						//sReturnControl=sScript+"Fehler. "+ err;	


						//#### ERROR HANDLING #######
						try{																
							//Wende Funktion an, zur Ermittlung der aktuellen Funktion
							var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
							var myErrorString = handleError(err,objControlErrh);
							if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
							bReturnControl = false;
							sReturnControl= myErrorString;				
						}catch(e){
							print(e);					
							bReturnControl=false;
							sReturnControl=sScript+"Fehler im ErrorHandling. "+ e;
						}
					}
					
					//#### RÜCKGABE #####
					objControl.sReturnControl=sReturnControl;				
					objControl.bReturnControl=bReturnControl;
					return sReturn;
				}
	      ]]>
  </scriptdef>
  				
 <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_errorHandlingJs" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[		
			var myFilepath = attributes.get("inputfilepath");
			
			var sReturn=""; //Wird hier nicht zurueckgegeben
			var bReturn=false; 
			var bReturnControl=false;
			var sReturnControl="Fehler";
		
			//Die benoetigten Kernel-Funktionen laden
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objKernelLibs = new Array();
			var objControlCaller=new Object();
			var bReturn = enableKernelAntJs(objKernelLibs, "", objControlCaller);
			if(!objControlCaller.bReturnControl){								
				bReturn=false;
				sReturn="";
			}else{			
				var sInputFilepath=attributes.get("inputfilepath");				
				bReturn=tryout_jaz_errorHandling(objKernelLibs,myFilepath,objControlCaller);		
				if(!objControlCaller.bReturnControl){									
					bReturn=false;
					sReturn="";
				}else{					
				}
			}	
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			project.setProperty(attributes.get("returnboolean"),bReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);

			//###################################################################
            //#### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verfügung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k."
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
		//#################################################################################################	
		function tryout_jaz_errorHandling(objKernelLibs, myFilepath, objControl){
			var sReturn="TEST sReturn";		
				var bReturnControl=false;
				var sReturnControl="Fehler";	
				try{
					//IN JEDER FUNKTION DAS LADERN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG				
					if(objKernelLibs==undefined || objKernelLibs==null){
						print("Keine Kernel Ant Js Libs uebergeben.");
					} else {												
						if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
							print("Keine Kernel Ant Js Libs vorhanden zum Laden");
						} else {
							//print("Loading Kernel Ant Js Libs: " + objKernelLibs.length);
							for (var i = 0; i < objKernelLibs.length; i++) { 									
								eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.								
							}
						}
					}
					
					print("#######################");
					var objControlCaller = new Object();
					var sScript = reflectMethodCurrent_Name(null, objControlCaller);					
					if(!objControlCaller.bReturnControl) throw new Error("tryout_reflectMethodCallingName: " + objControlCaller.sReturnControl);
					sScript=sScript+": ";
					sReturnControl=sScript+"Fehler";
					print(sScript+"START");

			
				print("#######################");
				print(sScript+"Error objekt im Zusammenspiel mit JAVA");
				enableJava();
		
				//Allgemein für Import Statements gilt:
				//importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
				//                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
 
				//import statements, funktionieren beide
				//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
				//importPackage(basic.zBasic.util.datatype.string);				
				importPackage(Packages.basic.zBasic.util.file);
			
				//#############
				//#### EINGABE ######	 				
				var myFilepath="";  ////NOCH KAPUTT 20160402: Damit wird der Fehler erzwungen
				print("myFilepath="+myFilepath);
		
				var bReturn = false;
				var bReturnControl = false; //Zumindest Fehler zurückgegen, wenn der Programmablauf (z.B. im Errorhandling) nicht so ist wie erwartet.
				var sReturnControl = sScript+"Fehler."; 
			
				
					//#### Java, etc.
					var bErg = FileEasyZZZ.isRoot(myFilepath);
					print("bErg="+bErg);
					bReturn=bErg;
					bReturnControl = true;
					sReturnControl = "Alles o.k.";
         
					//Doku:
					//Von der Reihenfolge der catches wäre notwendig: Erst die genau definierten Fehler abfangen, dann die allgemeinen.
					//Da dies in einer einzelnen Funktion gekapselt werden soll, machen wir einen catch und darin if - Abfragen.
					//}catch (err if err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO, 
					//		myReturnControlString = "Error: " + err.javaException.getMessageLast();
					//.................................................	
					//}catch (err if err.instanceof ExceptionZZZ) {  // So geht das nur mit NASHORN, 
					//    myReturnControlString = "Error: " + err.getMessageLast();
					//}catch(err){
					// ................................................
					//}				
				
				}catch(err) {
					print("Fehler gefangen: " + err);
						//#### SIMPLES ERROR HANDLING #######							
						//bReturnControl=false;
						//sReturnControl=sScript+"Fehler. "+ err;	

						//#### ERROR HANDLING #######
						try{																
							//Wende Funktion an, zur Ermittlung der aktuellen Funktion
							var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
							var myErrorString = handleError(err,objControlErrh);
							if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
							bReturnControl = false;
							sReturnControl= myErrorString;				
						}catch(e){
							print(e);					
							bReturnControl=false;
							sReturnControl=sScript+"Fehler im ErrorHandling. "+ e;
						}
				}
				print("zuruegegebener controlstring aus JAZ-Fehler:" + sReturnControl);
				objControl.sReturnControl=sReturnControl;				
				objControl.bReturnControl=bReturnControl;	
				return bReturn;
			}//end function tryout...
	      ]]>
  </scriptdef>
  
  <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_fileeasy_isRoot" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[
			var myFilepath = attributes.get("inputfilepath");
			
			var sReturn=""; 
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";
		
			//Die benoetigten Kernel-Funktionen laden
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objKernelLibs = new Array();
			var objControlCaller=new Object();
			var bReturn = enableKernelAntJs(objKernelLibs,"", objControlCaller);
			if(!objControlCaller.bReturnControl){								
				bReturn=false;
				sReturn="";
			}else{										
				bReturn=tryout_jaz_fileeasyIsRoot(objKernelLibs,myFilepath, objControlCaller);		
				if(!objControlCaller.bReturnControl){									
					bReturn=false;
					sReturn="";
				}else{										
				}
			}	
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			project.setProperty(attributes.get("returnboolean"),bReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);

			//###################################################################
            //#### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verfügung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k."
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					//print("Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
		//#################################################################################################
		function tryout_jaz_fileeasyIsRoot(objKernelLibs, myFilepath, objControl){	 			
				var sScript = "tryout_jaz_fileeasyIsRoot: ";
				//var sReturn="nixnix"; 
				var bReturn=false;
				var bReturnControl=false;
				var sReturnControl="Fehler";	
				
				try{															
					//IN JEDER FUNKTION DAS LADERN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG					
					if(objKernelLibs==undefined || objKernelLibs==null){
						print("Keine Kernel Ant Js Libs uebergeben.");
					} else {						
						if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
							print("Keine Kernel Ant Js Libs vorhanden zum Laden");
						} else {
							print("Loading Kernel Ant Js Libs: " + objKernelLibs.length);
							for (var i = 0; i < objKernelLibs.length; i++) { 	
								//print("Lib: " + objKernelLibs[i]["Alias"]);					
								//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
								//funktioniert: 
								eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
								//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
							}
						}
					}
					print("#######################");								
					enableJava();
		
		   //Allgemein für Import Statements gilt:
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
		   //                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
		   // import statements, funktionieren beide
			//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
			//importPackage(basic.zBasic.util.datatype.string);
			importPackage(Packages.basic.zBasic.util.file);
	 
			var test = java.lang.System.getProperty("java.class.path");
			print("classpath="+test);
			

			 //#### EINGABE ######
			print("myFilepath="+myFilepath);
			
			//#### Java, etc.
			bReturn = FileEasyZZZ.isRoot(myFilepath);
			print("bReturn="+bReturn);
			
					sReturnControl=sScript+"Alles o.k.";
					bReturnControl=true;
					
					}catch(err){	
						print("Fehler gefangen: " + err);
						//#### SIMPLES ERROR HANDLING #######							
						//bReturnControl=false;
						//sReturnControl=sScript+"Fehler. "+ err;	

						//#### ERROR HANDLING #######
						try{																
							//Wende Funktion an, zur Ermittlung der aktuellen Funktion
							var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
							var myErrorString = handleError(err,objControlErrh);
							if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
							bReturnControl = false;
							sReturnControl= myErrorString;				
						}catch(e){
							print(e);					
							bReturnControl=false;
							sReturnControl=sScript+"Fehler im ErrorHandling. "+ e;
						}
					}
					
					//#### RÜCKGABE #####
					objControl.sReturnControl=sReturnControl;				
					objControl.bReturnControl=bReturnControl;
					return bReturn;
			}
	      ]]>
  </scriptdef>
         
  
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!--<target name="compile" depends=" -myTestJAZUsedByJavaScript_ErrorHandling, -myTestJAZUsedByJavaScript_ErrorHandlingCascaded, -myTestJAZUsedByJavaScript_FileEasyZZZ, -myTestJAZUsedByJavaScript_StringZZZ, ">-->
 <target name="compile" depends="-myTestJAZUsedByJavaScript_ErrorHandlingCascaded">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>

	<target name="-myTestJAZUsedByJavaScript_ErrorHandling">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_ErrorHandling: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
			<not>
				<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
			</not>
			<ac:then>
				<fl:fail message="FileEasyZZZ existiert nicht."/>
			</ac:then>
			<ac:else>
				<echo message="FileEasyZZZ vorhanden." />
			 </ac:else>
		 </ac:if>
		 
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		  <fl:let>myInputFilepath::="c:\\temp"</fl:let>
		 <echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_jaz_errorHandlingJs inputfilepath="${myInputFilepath}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		 
	 		
		<!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		<fl:let>myInputFilepath::="c:\\temp"</fl:let>
		<echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_jaz_errorHandlingJs inputfilepath="${myInputFilepath}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString2}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		
		 <fl:let>myInputFilepath::=""</fl:let>
		<echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_jaz_errorHandlingJs inputfilepath="${myInputFilepath}" returnboolean="myReturnValue03" returncontrol="myReturnControl03" returnControlString="myReturnControlString03"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl03} | ${myReturnControlString03} | ${myReturnValue03}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl03}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString03}</echo>	
				<fail message="${myReturnControlString03}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sicherstellen, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
	</trycatch>
		
		
	</target> 
	
	
	<target name="-myTestJAZUsedByJavaScript_ErrorHandlingCascaded">
	    <!-- Der Java/JAZ-Kernel Fehler tritt nun in einem Untertarget auf und soll bis nach 'oben' durchgereicht werden -->
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_ErrorHandlingCascaded: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
		<ac:var name="myReturnControl" value="true"/> <!-- unset="true"/> -->
		<ac:var name="myReturnControlString" value="alles o.k."/> <!-- unset="true" />-->
		
		<!--<fl:let>returnControlStringMain::='im Haupttarget alles ok. '</fl:let>-->
		<ac:var name="returnControlStringMain" value="im Haupttarget alles o.k."/> <!-- unset="true" />-->
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
		<!-- 1. Aufruf, sollte keinen Fehler werfen -->
		<fl:let>mysFiledirEscaped::='c:\\temp'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
		<antcallback target="--myTestJAZUsedByJavaScript_SubtargetDummy" return="returnBoolean,returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->								
			</antcallback>			
			<ac:var name="myReturnControl" value="${returnControl}"/>
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
			<ac:if>
				<equals arg1="${myReturnControl}" arg2="false" />
				<ac:then>		 
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>						
				</ac:else>
			</ac:if>
			<ac:if>
				<equals arg1="${returnBoolean}" arg2="false" />
				<ac:then>		
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<!--<fl:fail message="${sScript}${myReturnControlString}"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
						<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} ist nicht Root." />
				</ac:then>
				<ac:else>	
						<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} IST Root." />				
				</ac:else>
			</ac:if>
			
		<!-- 2. Aufruf mit Leerstring, sollte Fehler werfen! -->
		<fl:let>mysFiledirEscaped::=''</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
		<antcallback target="--myTestJAZUsedByJavaScript_SubtargetDummy" return="returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
		</antcallback>	
		<ac:var name="myReturnControl" value="${returnControl}"/>
		<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>
		<ac:var name="myReturnControlString" value="${returnControlString}"/>			
		<ac:if>
			<equals arg1="${myReturnControl}" arg2="false" />
		<ac:then>		
				<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
				<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:then>
		<ac:else>						
		</ac:else>
		
		</ac:if>
		<ac:if>
			<equals arg1="${returnBoolean}" arg2="false" />
		<ac:then>		
				<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
				<!--<fl:fail message="${sScript}${myReturnControlString}"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
				<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} ist nicht Root." />
		</ac:then>
		<ac:else>	
				<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} IST Root." />				
		</ac:else>
		</ac:if>
		
		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}CATCH - Fehler zurueckgeben: ${myReturnControlString}</echo>-->
			
			<!-- Rueckgabe an das aufrufenden Target / Haupttarget -->
			<!--<fl:let>returnControlStringMain::=${myReturnControlString}</fl:let>-->
			<ac:var name="returnControlStringMain" value="${myReturnControlString}"/> <!-- unset="true" />-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
	
	<echo>${sScript}An aufrufendes Target/Haupttarget zurueckgeben: ${returnControlStringMain}</echo>
			
		
	</target> 
	
	<target name="--myTestJAZUsedByJavaScript_SubtargetDummy">
	    <!-- Der Java/JAZ-Kernel Fehler tritt nun in einem Untertarget auf und soll bis nach 'oben' durchgereicht werden -->
		<fl:let>sScript::='--myTestJAZUsedByJavaScript_SubtargetDummy: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
		<ac:var name="myReturnControl" value="true" unset="true"/>
		<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		<echo>${sScript}Start</echo>
         
		 <!-- Uebergabeparameter abholen -->
		<fl:let>mysFiledir::='${sFiledir}'</fl:let><!-- Warum geht hier die Referenz verloren? Das muss mit den Backslashes zu tun haben. Ausserdem muss der Wert mit Backslashes in Hochkommata übertragen werden, quasi eine Möglichkeit es als byValue zu übertragen. -->
	
		
		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
			<not>
				<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
			</not>
			<ac:then>
				<fl:fail message="${sScript}FileEasyZZZ existiert nicht."/>
			</ac:then>
			<ac:else>
				<echo message="${sScript}FileEasyZZZ vorhanden." />
			 </ac:else>
		 </ac:if>
	 		
		<!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		<tryout_jaz_errorHandlingJs inputfilepath="${mysFiledir}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
		
		<!--Rueckgabwerte an aufrufendes Target -->
		<ac:var name="returnBoolean" value="${myReturnBoolean}"/>
		<ac:var name="returnControl" value="${myReturnControl}"/>
		<ac:var name="returnControlString" value="${myReturnControlString}"/>	
	</target> 
	
	
	<target name="-myTestJAZUsedByJavaScript_FileEasyZZZ">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_FileEasyZZZ: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>
		
		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>

		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
		<not>
			<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
		</not>
	  <ac:then>
		<fl:fail message="FileEasyZZZ existiert nicht."/>
	   </ac:then>
	   <ac:else>
	   <echo message="FileEasyZZZ vorhanden." />
	   </ac:else>
	 </ac:if>
	 
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<tryout_jaz_fileeasy_isRoot inputfilepath="c:\\" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<tryout_jaz_fileeasy_isRoot inputfilepath="c:\\temp" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
	</trycatch>
		
	</target> 
	
	<target name="-myTestJAZUsedByJavaScript_StringZZZ">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_StringZZZ: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
		<not>
			<available classname="basic.zBasic.util.datatype.string.StringZZZ" />        
		</not>
	  <ac:then>
		<fl:fail message="StringZZZ existiert nicht."/>
	   </ac:then>
	   <ac:else>
	   <echo message="StringZZZ vorhanden." />
	   </ac:else>
	 </ac:if>
	 
	 
		<!-- Hier wird die scriptdef Methode tryout_jaz_string_camelcase aufgerufen -->
		<tryout_jaz_string_camelcase inputstring="Das_ist_ein_camelcase_test" returnstring="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		
		<!-- Hier wird die scriptdef Methode tryout_jaz_string_camelcase aufgerufen. -->
		<tryout_jaz_string_camelcase inputstring="h_a" returnstring="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		<echo message="myReturnValue = ${myReturnValue}" />
		
	</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
	</trycatch>
		
		
	</target> 
 </project>