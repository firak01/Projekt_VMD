<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_JAZUsedByJavaScript"  default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">

	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<!-- gebraucht wird das z.B. für den <for> </for> Task. -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>

  <!-- ######## Scriptdefs ############################################################################--> 

 <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_string_camelcase" language="javascript">
     <attribute name="filename_search" />
     <attribute name="filenames" />
	 <attribute name="filelengths" />
	 <attribute name="tryout" />
     <![CDATA[
		   enableJava();
		   
		   //Allgemein für Import Statements gilt:
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
		   //                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
		   // import statements, funktionieren beide
			//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
			//importPackage(basic.zBasic.util.datatype.string);
			importPackage(Packages.basic.zBasic.util.datatype.string);
	 
			var test = java.lang.System.getProperty("java.class.path");
			println("classpath="+test);
			
			
			//#############
			 //#### EINGABE ######	 
			var file2search = attributes.get("filename_search");
			print("file2search="+file2search);
			
			//#### Java, etc.
			var serg = StringZZZ.toCamelCase(file2search,"_");
			//var serg = "test ohne java";
			print("serg="+serg);
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         
			  
		//	var arrayFilenames=new Array();
		//	var arrayFilelengths=new Array();
			
		//	arrayFilenames.push('Woa'); 
		//	arrayFilenames.push('Wob'); 
		//	arrayFilelengths.push(1234); 
			
			
			//#### RÜCKGABE #####
		//	project.setProperty(attributes.get("tryout"), "Text zurueckgeben: " + serg);  
		//	project.setProperty(attributes.get("filenames"), arrayFilenames);
		//	project.setProperty(attributes.get("filelengths"), arrayFilelengths); 
		
		
		
		//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//print("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
	      ]]>
  </scriptdef>
  
    <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_errorHandlingJs" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[
			enableJava();
		   
			//Allgemein für Import Statements gilt:
			//importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
			//                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
			// import statements, funktionieren beide
			//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
			//importPackage(basic.zBasic.util.datatype.string);
			importClass(Packages.basic.zBasic.ExceptionZZZ);
			importPackage(Packages.basic.zBasic.util.file);
	 			
			//#############
			//#### EINGABE ######	 
			var myFilepath = attributes.get("inputfilepath");
			print("myFilepath="+myFilepath);
			
			var bErg = false;
			var myReturnControl = true;
			var myReturnControlString = "Alles o.k.";
			
			//#### ERROR HANDLING #######
			try{
			
			//#### Java, etc.
			bErg = FileEasyZZZ.isRoot(myFilepath);
			print("bErg="+bErg);
			
			
			//var serg = StringZZZ.toCamelCase(myFilepath,"_");
			//println("serg="+serg);
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         
		    //Doku:
			//Von der Reihenfolge der catches wäre notwendig: Erst die genau definierten Fehler abfangen, dann die allgemeinen.
			//Da dies in einer einzelnen Funktion gekapselt werden soll, machen wir einen catch und darin if - Abfragen.
			//}catch (err if err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO, 
			//		myReturnControlString = "Error: " + err.javaException.getMessageLast();
			//.................................................	
			//}catch (err if err.instanceof ExceptionZZZ) {  // So geht das nur mit NASHORN, 
			//    myReturnControlString = "Error: " + err.getMessageLast();
			//}catch(err){
			// ................................................
			//}				
				
			}catch(err) {
				bErg = false; //sicher ist sicher....
				myReturnControl = false;
				myReturnControlString = handleError(err);
			}
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         
			 //Beispiel für die Array-Rueckgabe 
			//	var arrayFilenames=new Array();
			//	var arrayFilelengths=new Array();
			
			//	arrayFilenames.push('Woa'); 
			//	arrayFilenames.push('Wob'); 
			//	arrayFilelengths.push(1234); 
			
			
			//#### RÜCKGABE #####
			project.setProperty(attributes.get("returnboolean"), bErg);
			project.setProperty(attributes.get("returncontrol"), myReturnControl);
			project.setProperty(attributes.get("returncontrolstring"), myReturnControlString);			
			//	project.setProperty(attributes.get("filenames"), arrayFilenames);
			//	project.setProperty(attributes.get("filelengths"), arrayFilelengths); 
		
		
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
					print("Verwende das alte Rhino unter Java 8");
				}catch(e){
					print("Verwende Standard JavaScript Engine dieser Java Vesion.");
				}
			}//End function enableJava
			
			function handleError(err){
				//document.getElementById("demo").innerHTML = err.message;
				//Aber: Wir wollen auf ein ExceptionZZZ Objekt zugreifen. Seit Aenderung der Javascript Engine in Nashorn ist dies Unterschiedlich.
				//                                                                                       In Nashorn steht das Objekt direkter zur Verfügung.
					if(err instanceof ExceptionZZZ) {  //So geht das nur mit NASHORN.
						print("ExceptionZZZ Fehler abgefangen (NASHORN)");
						print("err.getMessageLast()="+ err.getMessageLast());  //DIE LÖSUNG MIT NASHORN !!!!
						myReturnControlString = "Error: " + err.getMessageLast();
					}else if(err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO !!!
						print("ExceptionZZZ Fehler abgefangen (RHINO)");
						print("err.javaException.getMessageLast()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
						myReturnControlString = "Error: " + err.javaException.getMessageLast();
					}else{
					   //weitere, unbestimmte Fehler abfangen
					   print("Unbestimmten Fehler abfangen.");
					   var version = java.lang.System.getProperty("java.version");
					   print("JavaVersion: " + version);
					   print("typeof err: "+typeof(err));					   
						if(version.substring(0,3)=="1.8"){
							print ("Javascript Engine: 'Nashorn'");
							print("Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							myReturnControlString = "Error: " + err.message;												
						}else{
							print ("Javascript Engine: 'Rhino'");
							print("err.contructor.name="+err.constructor.name);	//In Rhino wird der Fehler nicht direkt zurückgegeben.			
							if(err.constructor.name=='JavaException'){
								print("Error.name=" + err.name);
								print("Error=" + err);
								print("Error.getCause=" + err.getCause); //Ergebnis: undefined
								//print("Error.getCause()=" + err.getCause());
								print("Error.message: " + err.message);//Ergebnis der Ausgabe: basic.zBasic.ExceptionZZZ: null;
								//print("Error.message(): " + err.message());//Ergebnis: Es wird ein Fehler geworfen 'is not a function, it is "string"
								//print("Error: " + err.getMessageLast());//Ergebnis: Es wird ein Fehler geworfen 'cannot find function getMessageLast in object JavaException
								//print("Error: " + err.getMessageLast);//Ergebnis: dito, kein Unterschied zu getMessageLast()
								print("err.javaException.getMessage()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
								myReturnControlString = "Error: " + err.javaException.getMessage();
							}else{
								print("normaler Fehler.  Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							    myReturnControlString = "Error: " + err.message;
							}									
						}
					}					
					return myReturnControlString;
			}//End function handleError
	      ]]>
  </scriptdef>
  
  <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_fileeasy_isRoot" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
     <![CDATA[
		   enableJava();
		   
		   //Allgemein für Import Statements gilt:
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
		   //                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
		   // import statements, funktionieren beide
			//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
			//importPackage(basic.zBasic.util.datatype.string);
			importPackage(Packages.basic.zBasic.util.file);
	 
			var test = java.lang.System.getProperty("java.class.path");
			print("classpath="+test);
			
			
			//#############
			 //#### EINGABE ######	 
			var myFilepath = attributes.get("inputfilepath");
			print("myFilepath="+myFilepath);
			
			//#### Java, etc.
			var bErg = FileEasyZZZ.isRoot(myFilepath);
			print("bErg="+bErg);
			
			
			//var serg = StringZZZ.toCamelCase(file2search,"_");
			//var serg = "test ohne java";
			//println("serg="+serg);
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         
			  
		//	var arrayFilenames=new Array();
		//	var arrayFilelengths=new Array();
			
		//	arrayFilenames.push('Woa'); 
		//	arrayFilenames.push('Wob'); 
		//	arrayFilelengths.push(1234); 
			
			
			//#### RÜCKGABE #####
			project.setProperty(attributes.get("returnboolean"), bErg);  
		//	project.setProperty(attributes.get("filenames"), arrayFilenames);
		//	project.setProperty(attributes.get("filelengths"), arrayFilelengths); 
		
		
		
		//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
	      ]]>
  </scriptdef>
         
  
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!--<target name="compile" depends="-myTestJAZUsedByJavaScript_ErrorHandling, -myTestJAZUsedByJavaScript_ErrorHandlingCascaded, -myTestJAZUsedByJavaScript_FileEasyZZZ, -myTestJAZUsedByJavaScript_StringZZZ, ">-->
 <target name="compile" depends="-myTestJAZUsedByJavaScript_ErrorHandlingCascaded">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  	
	<target name="-myTestJAZUsedByJavaScript_ErrorHandling">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_ErrorHandling: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
			<not>
				<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
			</not>
			<ac:then>
				<fl:fail message="FileEasyZZZ existiert nicht."/>
			</ac:then>
			<ac:else>
				<echo message="FileEasyZZZ vorhanden." />
			 </ac:else>
		 </ac:if>
	 		
		<!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		<tryout_jaz_errorHandlingJs inputfilepath="c:\\temp" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString2}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		
		<tryout_jaz_errorHandlingJs inputfilepath="" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sicherstellen, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
	</trycatch>
		
		
	</target> 
	
	
	<target name="-myTestJAZUsedByJavaScript_ErrorHandlingCascaded">
	    <!-- Der Java/JAZ-Kernel Fehler tritt nun in einem Untertarget auf und soll bis nach 'oben' durchgereicht werden -->
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_ErrorHandlingCascaded: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
		<ac:var name="myReturnControl" value="true"/> <!-- unset="true"/> -->
		<ac:var name="myReturnControlString" value="alles o.k."/> <!-- unset="true" />-->
		
		<!--<fl:let>returnControlStringMain::='im Haupttarget alles ok. '</fl:let>-->
		<ac:var name="returnControlStringMain" value="im Haupttarget alles o.k."/> <!-- unset="true" />-->
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
		<!-- 1. Aufruf, sollte keinen Fehler werfen -->
		<fl:let>mysFiledirEscaped::='c:\\temp'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
		<antcallback target="--myTestJAZUsedByJavaScript_SubtargetDummy" return="returnBoolean,returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->								
			</antcallback>			
			<ac:var name="myReturnControl" value="${returnControl}"/>
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
			<ac:if>
				<equals arg1="${myReturnControl}" arg2="false" />
				<ac:then>		 
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>						
				</ac:else>
			</ac:if>
			<ac:if>
				<equals arg1="${returnBoolean}" arg2="false" />
				<ac:then>		
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<!--<fl:fail message="${sScript}${myReturnControlString}"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
						<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} ist nicht Root." />
				</ac:then>
				<ac:else>	
						<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} IST Root." />				
				</ac:else>
			</ac:if>
			
		<!-- 2. Aufruf mit Leerstring, sollte Fehler werfen! -->
		<fl:let>mysFiledirEscaped::=''</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
		<antcallback target="--myTestJAZUsedByJavaScript_SubtargetDummy" return="returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
			</antcallback>	
			<ac:var name="myReturnControl" value="${returnControl}"/>
			<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
			<ac:if>
				<equals arg1="${myReturnControl}" arg2="false" />
				<ac:then>		
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>						
				</ac:else>
			</ac:if>
			<ac:if>
				<equals arg1="${returnBoolean}" arg2="false" />
			<ac:then>		
					<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
					<!--<fl:fail message="${sScript}${myReturnControlString}"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
					<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} ist nicht Root." />
			</ac:then>
			<ac:else>	
					<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} IST Root." />				
			</ac:else>
		</ac:if>
			
			
		
		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}CATCH - Fehler zurueckgeben: ${myReturnControlString}</echo>-->
			
			<!-- Rueckgabe an das aufrufenden Target / Haupttarget -->
			<!--<fl:let>returnControlStringMain::=${myReturnControlString}</fl:let>-->
			<ac:var name="returnControlStringMain" value="${myReturnControlString}"/> <!-- unset="true" />-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
	
	<echo>${sScript}An aufrufendes Target/Haupttarget zurueckgeben: ${returnControlStringMain}</echo>
			
		
	</target> 
	
	<target name="--myTestJAZUsedByJavaScript_SubtargetDummy">
	    <!-- Der Java/JAZ-Kernel Fehler tritt nun in einem Untertarget auf und soll bis nach 'oben' durchgereicht werden -->
		<fl:let>sScript::='--myTestJAZUsedByJavaScript_SubtargetDummy: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
		<ac:var name="myReturnControl" value="true" unset="true"/>
		<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		<echo>${sScript}Start</echo>
         
		 <!-- Uebergabeparameter abholen -->
		<fl:let>mysFiledir::='${sFiledir}'</fl:let><!-- Warum geht hier die Referenz verloren? Das muss mit den Backslashes zu tun haben. Ausserdem muss der Wert mit Backslashes in Hochkommata übertragen werden, quasi eine Möglichkeit es als byValue zu übertragen. -->
	
		
		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
			<not>
				<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
			</not>
			<ac:then>
				<fl:fail message="${sScript}FileEasyZZZ existiert nicht."/>
			</ac:then>
			<ac:else>
				<echo message="${sScript}FileEasyZZZ vorhanden." />
			 </ac:else>
		 </ac:if>
	 		
		<!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		<tryout_jaz_errorHandlingJs inputfilepath="${mysFiledir}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
		
		<!--Rueckgabwerte an aufrufendes Target -->
		<ac:var name="returnBoolean" value="${myReturnBoolean}"/>
		<ac:var name="returnControl" value="${myReturnControl}"/>
		<ac:var name="returnControlString" value="${myReturnControlString}"/>	
	</target> 
	
	
	<target name="-myTestJAZUsedByJavaScript_FileEasyZZZ">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_FileEasyZZZ: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
		<not>
			<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
		</not>
	  <ac:then>
		<fl:fail message="FileEasyZZZ existiert nicht."/>
	   </ac:then>
	   <ac:else>
	   <echo message="FileEasyZZZ vorhanden." />
	   </ac:else>
	 </ac:if>
	 
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<tryout_jaz_fileeasy_isRoot inputfilepath="c:\\" returnboolean="myReturnValue"/>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<tryout_jaz_fileeasy_isRoot inputfilepath="c:\\temp" returnboolean="myReturnValue"/>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		<!-- Verwende antcontrib für eine Schleife über die Arrays --><!-- do something with @{myelement} -->
<!-- 		<for list="${myfilenames}" param="myelement">
			<sequential>				
				<echo>myelement= @{myelement}</echo>
			</sequential>
		</for> -->
		
	</target> 
	
	<target name="-myTestJAZUsedByJavaScript_StringZZZ">
		<echo>myTestJavaUsedByJavaScript: </echo>
		<property name="fs.dir" value="../testused"/>
		<property name="fs.includes" value="**/*.txt"/>
		<property name="fs.excludes" value="**/*.tmp"/>

		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
		<not>
			<available classname="basic.zBasic.util.datatype.string.StringZZZ" />        
		</not>
	  <ac:then>
		<fl:fail message="StringZZZ existiert nicht."/>
	   </ac:then>
	   <ac:else>
	   <echo message="StringZZZ vorhanden." />
	   </ac:else>
	 </ac:if>
	 
		<!-- Hier wird die scriptdef Methode tryout_java_file_length aufgerufen -->
		<tryout_jaz_string_camelcase filename_search="Das_ist_ein_camelcase_test" filenames="myfilenames" filelengths="myfilelengths" tryout="mytryout_string"/>
		<echo message="mytryout_string = ${mytryout_string}" />
		
		<!-- Verwende antcontrib für eine Schleife über die Arrays --><!-- do something with @{myelement} -->
<!-- 		<for list="${myfilenames}" param="myelement">
			<sequential>				
				<echo>myelement= @{myelement}</echo>
			</sequential>
		</for> -->
		
	</target> 
 </project>