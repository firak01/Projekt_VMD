<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_JAZUsedByJavaScript"  default="compile" basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka">

	<!-- ### Einbinden von Ant-Contrib, hierbei muss man die Task-Namen so wählen, wie sie in der ant-contrib Doku benannt sind ### -->
	<!--        Der Vorteil ist, das man mit der einen Deklaration alle Tasks nutzen kann, der Nachteil ist, man kann keinen 'namespace' faken -->
	<!-- gebraucht wird das z.B. für den <for> </for> Task. -->
	<taskdef resource="net/sf/antcontrib/antlib.xml">
	  <classpath>
		<pathelement location="${basedir}/lib/ant-contrib-1.0b3.jar"/>
	  </classpath>
	</taskdef>

  <!-- ######## Scriptdefs ############################################################################--> 

 <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_string_camelcase" language="javascript">
     <attribute name="filename_search" />
     <attribute name="filenames" />
	 <attribute name="filelengths" />
	 <attribute name="tryout" />
     <![CDATA[
		   enableJava();
		   
		   //Allgemein für Import Statements gilt:
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
		   //                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
		   // import statements, funktionieren beide
			//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
			//importPackage(basic.zBasic.util.datatype.string);
			importPackage(Packages.basic.zBasic.util.datatype.string);
	 
			var test = java.lang.System.getProperty("java.class.path");
			println("classpath="+test);
			
			
			//#############
			 //#### EINGABE ######	 
			var file2search = attributes.get("filename_search");
			print("file2search="+file2search);
			
			//#### Java, etc.
			var serg = StringZZZ.toCamelCase(file2search,"_");
			//var serg = "test ohne java";
			print("serg="+serg);
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         
			  
		//	var arrayFilenames=new Array();
		//	var arrayFilelengths=new Array();
			
		//	arrayFilenames.push('Woa'); 
		//	arrayFilenames.push('Wob'); 
		//	arrayFilelengths.push(1234); 
			
			
			//#### RÜCKGABE #####
		//	project.setProperty(attributes.get("tryout"), "Text zurueckgeben: " + serg);  
		//	project.setProperty(attributes.get("filenames"), arrayFilenames);
		//	project.setProperty(attributes.get("filelengths"), arrayFilelengths); 
		
		
		
		//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//print("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
	      ]]>
  </scriptdef>
  				
 <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_errorHandlingJs" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
	 <attribute name="returncontrol" />
	 <attribute name="returncontrolstring" />
     <![CDATA[				        
			var myFilepath = attributes.get("inputfilepath");
		
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var objControl=new Object();		
			var bReturn=tryout_jaz_errorHandling(myFilepath,objControl);	
			project.setProperty(attributes.get("returnboolean"),bReturn);
			project.setProperty(attributes.get("returncontrol"),objControl.bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),objControl.sReturnControl);	
		
			function tryout_jaz_errorHandling(myFilepath,objControl){
			try{
				print("#######################");
				var objControlCaller=new Object();
				var sScript=reflectMethodCurrent_Name(null, objControlCaller);
				if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
				sScript=sScript+": ";
				print(sScript+"START");
			
				print("#######################");
				print(sScript+"Error objekt im Zusammenspiel mit JAVA");
				enableJava();
		
				//Allgemein für Import Statements gilt:
				//importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
				//                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
 
				//import statements, funktionieren beide
				//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
				//importPackage(basic.zBasic.util.datatype.string);
				importClass(Packages.basic.zBasic.ExceptionZZZ);
				importPackage(Packages.basic.zBasic.util.file);
			
				//#############
				//#### EINGABE ######	 
				var myFilepath="";
				print("myFilepath="+myFilepath);
		
				var bReturn = false;
				var bReturnControl = false; //Zumindest Fehler zurückgegen, wenn der Programmablauf (z.B. im Errorhandling) nicht so ist wie erwartet.
				var sReturnControl = sScript+"Fehler."; 
			
				
					//#### Java, etc.
					var bErg = FileEasyZZZ.isRoot(myFilepath);
					print("bErg="+bErg);
					bReturn=bErg;
					bReturnControl = true;
					sReturnControl = "Alles o.k.";
         
					//Doku:
					//Von der Reihenfolge der catches wäre notwendig: Erst die genau definierten Fehler abfangen, dann die allgemeinen.
					//Da dies in einer einzelnen Funktion gekapselt werden soll, machen wir einen catch und darin if - Abfragen.
					//}catch (err if err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO, 
					//		myReturnControlString = "Error: " + err.javaException.getMessageLast();
					//.................................................	
					//}catch (err if err.instanceof ExceptionZZZ) {  // So geht das nur mit NASHORN, 
					//    myReturnControlString = "Error: " + err.getMessageLast();
					//}catch(err){
					// ................................................
					//}				
				
				}catch(err) {
					//#### ERROR HANDLING #######
					print("Fehler gefangen: " + err);
					try{																
						//Wende Funktion an, zur Ermittlung der aktuellen Funktion
						var objControlErrh=new Object();//wichtig: Neues Error Objekt.										
						var myErrorString = handleError(err,objControlErrh);
						if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
						bReturnControl = false;
						sReturnControl=sScript + myErrorString;				
					}catch(e){
						print(e);					
						bReturnControl=false;
						sReturnControlString=sScript+"Fehler im ErrorHandling. "+ e;
					}
				}
				print("zuruegegebener controlstring in JS-Unter-Funktion:" + sReturnControl);
				objControl.sReturnControl=sReturnControl;
				print("zuruegegebener controlstring in JS-Unter-Funktion 02:" + objControl.sReturnControl);
				objControl.bReturnControl=bReturnControl;	
				return bReturn;
			}//end function tryout...
						
			
			//#############################################
			//### ERROROHANDLING
			//#############################################		
			function handleError(err,objControl){
				
				//TEST: Versuche aus dem uebergebenen Error-Objekt weitere Infos zu holen
				print("##### in handle Error");
				var myFunctionCurrentName=reflectMethodCurrent_Name(err, objControl);
				if(!objControl.bReturnControl) throw new Error("Fehler beim Ermittlen des Funktionnamens im ErrorHandling: " + objControl.sReturnControl);					
				print("gefundener Funktionsname: " + myFunctionCurrentName);
					
				//TODO GOON TODO GOON 
				
				//JAVA 7 (Rhino), hier wird nichts ausgegeben, schade.	Stack ist undefined.
				//JAVA 8 (Nashorn), hier wird die Zeilenummer ausgegeben.
				print("TEST, neues ErrorObjekt erzeugen und die Zeilennummer ausgeben: "  + (new Error).lineNumber);			
				
				print("##### in handle Error für den Java-Fehler");				
				print("Error Objekt: " + err);
				print("Fehlerobjekt Zeilennummer: " + err.lineNumber);
				print("Fehlerobjekt Dateiname: " + err.fileName);
				
				
				var caller_line="Kein Stacktrace vorhanden.";
				if(undefined!=err.stack){
				    //RUECKGABE MOEGLICH BEI RHINO
					//print("Fehlerobjekt Stacktrace: " + err.stack);
					caller_line = err.stack.split("\n")[0];
					//print("caller line=" + caller_line);
					
					//TODO: Einzelne Informationen zerlegen, um die Ausgabe schöner zu machen.
					//var index = caller_line.indexOf("at ");
					//var clean = caller_line.slice(index+2, caller_line.length);
					//print("TESTE caller_line" + clean );
			    }else{
					//Bei NASHORN WIRD NIX ZURUECKGELIEFERT
					//probiere hier: NashornException.getScriptStackString(e.getCause());
					print("kein stack vorhanden für " + typeof(err));
					
				}	

//document.getElementById("demo").innerHTML = err.message;
				//Aber: Wir wollen auf ein ExceptionZZZ Objekt zugreifen. Seit Aenderung der Javascript Engine in Nashorn ist dies Unterschiedlich.
				//                                                                                       In Nashorn steht das Objekt direkter zur Verfügung.
					if(err instanceof ExceptionZZZ) {  //So geht das nur mit NASHORN.
						print("################################");
						print("ExceptionZZZ Fehler abgefangen (NASHORN)");
						print("err.getMessageLast()="+ err.getMessageLast());  //DIE LÖSUNG MIT NASHORN !!!!
						
						var caller_line="Kein Stacktrace vorhanden.";
						if(undefined!=err.stack){		
							//print("err.stack="+err.stack);
						
							caller_line = err.stack.split("\n")[0];
							
							//TODO: Einzelne Informationen zerlegen, um die Ausgabe schöner zu machen.
							//var index = caller_line.indexOf("at ").trim();
							//var clean = caller_line.slice(index+2, caller_line.length);
							//print("TESTE caller_line" + clean );
						} else {
							print("Definitiv kein Stack vorhanden");
						}
						
						
						myReturnControlString = "Error: '" + err.getMessageLast()  + "' " + caller_line;;
					}else if(err.javaException instanceof ExceptionZZZ) {  // So geht das nur mit RHINO !!!
						print("################################");
						print("ExceptionZZZ Fehler abgefangen (RHINO)");
						print("err.javaException.getMessageLast()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
						
						var caller_line="Kein Stacktrace vorhanden.";
						if(undefined!=err.stack){		
							//print("err.stack="+err.stack);
						
							caller_line = err.stack.split("\n")[0];
							
							//TODO: Einzelne Informationen zerlegen, um die Ausgabe schöner zu machen.
							//var index = caller_line.indexOf("at ").trim();
							//var clean = caller_line.slice(index+2, caller_line.length);
							//print("TESTE caller_line" + clean );
						} else {
							print("Definitiv kein Stack vorhanden");
						}							
						myReturnControlString = "Error: '" + err.javaException.getMessageLast() + "' " + caller_line;
					}else{
					   //weitere, unbestimmte Fehler abfangen
					   print("################################");
					   print("Unbestimmten Fehler abfangen.");
					   var version = java.lang.System.getProperty("java.version");
					   print("JavaVersion: " + version);
					   print("typeof err: "+typeof(err));					   
						if(version.substring(0,3)=="1.8"){
							print ("Javascript Engine: 'Nashorn'");
							print("Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							myReturnControlString = "Error: " + err.message;												
						}else{
							print("################################");
							print ("Javascript Engine: 'Rhino'");
							print("err.contructor.name="+err.constructor.name);	//In Rhino wird der Fehler nicht direkt zurückgegeben.			
							if(err.constructor.name=='JavaException'){
								print("Error.name=" + err.name);
								print("Error=" + err);
								print("Error.getCause=" + err.getCause); //Ergebnis: undefined
								//print("Error.getCause()=" + err.getCause());
								print("Error.message: " + err.message);//Ergebnis der Ausgabe: basic.zBasic.ExceptionZZZ: null;
								//print("Error.message(): " + err.message());//Ergebnis: Es wird ein Fehler geworfen 'is not a function, it is "string"
								//print("Error: " + err.getMessageLast());//Ergebnis: Es wird ein Fehler geworfen 'cannot find function getMessageLast in object JavaException
								//print("Error: " + err.getMessageLast);//Ergebnis: dito, kein Unterschied zu getMessageLast()
								print("err.javaException.getMessage()="+ err.javaException.getMessageLast());  //DIE LÖSUNG MIT RHINO !!!!
								print("err.rhinoExcption.stack="+err.rhinoExcption.stack);
								myReturnControlString = "Error: " + err.javaException.getMessage();
							}else{
								print("normaler Fehler.  Error=" + err); //Hier wird in Nashorn der Name der Exception-Klasse direkt zurückgegeben.
							    myReturnControlString = "Error: " + err.message;
							}									
						}
					}					
					return myReturnControlString;
			}//End function handleError	
			
				
			
			
			//###############################################################
			//### REFLECTION 
			//###############################################################
			function reflectMethodCurrent_Name(myError, objControl){
				var sScript="reflectMethodCurrent_Name: ";				
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl="Fehler";
				var objControlCaller = new Object();
				try{	
                    var sMethod="";							
					
					var sLine=reflectMethodCurrent_StackLine(myError, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					print(sScript +"sLine="+sLine);
												
					sMethod=reflectMethodCurrent_StackMethodFromLine(sLine, objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);												
					
					sReturn=sMethod;
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";								
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				//print(sScript+"sReturn="+sReturn);
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrentName		
				
			//#################################################################
			function reflectMethodCurrent_StackLine(myError, objControl){
				var sScript="reflectMethodCurrent_StackLine: ";
				var sReturn="";
				var bReturnControl=false;
				var sReturnControl=sScript+"Fehler";
				
				var objControlCaller = new Object();
				try{
				    var sCallerLine="";
					
					var bIsJava7=isJava7(objControlCaller);
					if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
					
					//Merke Java 7: Nur wenn man tatsächlich einen Fehler provoziert, bekommt man einen Stacktrace.
					//ACHTUNG: Wir Suchen als Funktion das VORLETZTE Element in dem Array
					if(bIsJava7){		
						print(sScript+"7: Ausfuehrung unter Java7");					
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								print(sScript+"7: Stack im Error Objekt vorhanden");
								var saStacktrace = myError.stack.split("\n");						
								var iUbound = saStacktrace.length;
								sCallerLine = saStacktrace[(iUbound-2)];//-1 wg. Index
							} else {
								//Normal in Java7, da kein Stacktrace im error-objekt vorhanden ist.
								print(sScript+"7: KEIN Stack im Error Objekt vorhanden");
								var saStacktrace=createStackTrace();
								//print(sScript + "7: Erstellter StackTrace=" + saStacktrace);
								
								var iUbound = saStacktrace.length;
								sCallerLine = saStacktrace[(iUbound-2)];//-1 wg. Index
								//sCallerLine = saStacktrace[3]; //Da ich den Stacktrace später als in der Version mit Stacktrace erzeuge, muss der Index um 1 höher sein.							
							}				
						}else{
							print(sScript+"7: KEIN Error Objekt vorhanden");
							var saStacktrace=createStackTrace();
							var iUbound = saStacktrace.length;
							sCallerLine = saStacktrace[(iUbound-2)];//-1 wg. Index
							//sCallerLine = saStacktrace[4]; //Da ich den Stacktrace später als in der Version mit Stacktrace erzeuge, muss der Index um 1 höher sein.																		
						}					
					}else{
						print(sScript+"8: Ausfuehrung unter Java8");
						if('undefined'!=myError && null!=myError){					
							if(undefined!=myError.stack){		
								//Java 8, NASHORN funktioniert.
								print(sScript + "8: Error Stack=" + myError.stack);
								var saStacktrace = myError.stack.split("\n");						
								var iUbound = saStacktrace.length;
								sCallerLine = saStacktrace[(iUbound-2)];//-1 wg. Index			
							} else {
								//Ungewöhnlich in Java 8 - wenn kein error-objekt vorhanden ist, vermutlich wurde kein Error Objekt übergeben.
								print(sScript + "8: KEIN Error Stack vorhanden OBWOHL Error Objekt vorhanden ist.");
															
								var saStacktrace=createStackTrace();
								print(sScript + "8: Erstellter StackTrace=" + saStacktrace);												
								var iUbound = saStacktrace.length;
								sCallerLine = saStacktrace[(iUbound-2)];//-1 wg. Index
								//sCallerLine = saStacktrace[4]; //Da ich den Stacktrace später als in der Version mit Stacktrace erzeuge, muss der Index um 1 höher sein.							
							}				
						}else{
							//Vermutlich Java7, da kein Stacktrace im error-objekt vorhanden ist.
							var saStacktrace=createStackTrace();
							var iUbound = saStacktrace.length;
							sCallerLine = saStacktrace[(iUbound-2)];//-1 wg. Index
							//sCallerLine = saStacktrace[4]; //Da ich den Stacktrace später als in der Version mit Stacktrace erzeuge, muss der Index um 1 höher sein.																		
						}
					}
					print(sScript+"CallerLine="+sCallerLine);
					sReturn=sCallerLine;
					bReturnControl=true;
					sReturnControl=sScript + "Alles o.k.";
				}catch(err){
					//#### SIMPLES ERROR HANDLING #######
					//print(err);					
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return sReturn;
			}//End function reflectMethodCurrent_StackLine
			
						
	//#####################################################################
	//### REFLECTION DETAIL: Funktionsnamen von einer Fehlerzeile bekommen
	//#####################################################################
	function reflectMethodCurrent_StackMethodFromLine(sStackLine, objControl){
		var sScript="reflectMethodCurrent_StackMethodFromLine: ";
		var sReturn = sStackLine;					
		var bReturnControl=false;
		var sReturnControl=sScript+"Fehler";
		try {
			if(undefined==sStackLine || null==sStackLine) throw new Error(sScript+"Parameter Stacktrace-Zeile fehlt.");
												
			var objControlCaller=new Object();
			var bJava7=isJava7(objControlCaller);					
			if(!objControlCaller.bReturnControl) throw new Error(objControlCaller.sReturnControl);
			
			var clean2="";
			if(bJava7){
				//print(sScript+"Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf(" (");
				var clean = sStackLine.slice(index+2, sStackLine.length);
				
				var index2 = clean.indexOf(")");							
				if(index2>=1){
					clean2 = clean.substring(0,index2).trim();
				}else{
					clean2 = clean.trim();
				}			
			} else {
				//Java8
				//print(sScript+"NICHT Java 7 Zweig. sStackLine="+sStackLine);
				var index = sStackLine.indexOf("at ");
				//print(sScript+"index="+index);
				var clean = sStackLine.slice(index+2, sStackLine.length);						
				//print(sScript+"clean="+clean);
				
				
				index = clean.indexOf(" (");
				var clean = clean.substring(0,index);
				//print(sScript+"clean="+clean);
				
				clean2 = clean.trim();
			}
			sReturn=clean2;					
			bReturnControl=true;
			sReturnControl=sScript + "Alles o.k.";
		}catch(err){
			//#### SIMPLES ERROR HANDLING #######
			print(err);					
			bReturnControl=false;
			sReturnControl=sScript+"Fehler. "+ err;					
		}
		objControl.bReturnControl=bReturnControl;
		objControl.sReturnControl=sReturnControl;								
		print(sScript+"sReturn="+sReturn);
		return sReturn;
	}//End function reflectMethodCurrent_StackMethodFromLine
			
    //#########################################
	//### Hilfsfunktion zur Generierung eines Stacktraces. Als Workaround für Java7. 
	//#########################################			
	function createStackTrace() {
	  var callstack = [];
	  var isCallstackPopulated = false;
	  try {
		i.dont.exist+=0; //doesn't exist- that's the point
	  } catch(e) {
		if (e.stack) { //Firefox
			//print("ffox");
			//print(e.stack);
		  var lines = e.stack.split('\n');
		  for (var i=0, len=lines.length; i<=len-1; i++) {
			//print(i + ": '" + lines[i].trim() +"'");
			//klappt hier nicht....  if (lines[i].trim().match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			if (lines[i].trim()!=''){
			  //print("line used");
			  callstack.push(lines[i]);
			}else		 {
			  //print("empty line NOT used");  				
			}
		  }
		  
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
		else if (window.opera && e.message) { //Opera
			print("opera  untested");
		  var lines = e.message.split('\n');
		  for (var i=0, len=lines.length; i<len; i++) {
			if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
			  var entry = lines[i];
			  //Append next line also since it has the file info
			  if (lines[i+1]) {
				entry += ' at ' + lines[i+1];
				i++;
			  }
			  callstack.push(entry);
			}
		  }
		  //Remove call to printStackTrace()
		  callstack.shift();
		  isCallstackPopulated = true;
		}
	  }
	  if (!isCallstackPopulated) { //IE and Safari
		print("ie untested");
		var currentFunction = arguments.callee.caller;
		while (currentFunction) {
		  var fn = currentFunction.toString();
		  var fname = fn.substring(fn.indexOf("function") + 8, fn.indexOf('')) || 'anonymous';
		  callstack.push(fname);
		  currentFunction = currentFunction.caller;
		}
	  }
	  //output(callstack);
	  return callstack;
	}

	function output(arr) {
	  //Optput however you want
	  //alert(arr.join('\n\n'));
	  //print("aaaaaaa " + arr);
	  print(arr.join('\n\n'));
	}			
			
			
	//#############################################
    //### Hilfsfunktion JAVA
	//#############################################	
		function isJava7(objControl){	
			var sScript="isJava7: ";
			var bReturn = false;
			var bReturnControl=false;
			var sReturnControl=sScript+"Fehler";
			try {			
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				if(version.substring(0,3)=="1.7"){
					bJava7found=true;
				}else {
					bJava7found=false;
				}
				
				bReturn=bJava7found;
				bReturnControl=true;
				sReturnControl=sScript + "Alles o.k.";
			}catch(err){
				//#### SIMPLES ERROR HANDLING #######
				//print(err);					
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;					
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;								
			return bReturn;
		}//End function isJava7
			
			//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				var version = java.lang.System.getProperty("java.version");
				print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
					print("Verwende das alte Rhino unter Java 8");
				}catch(e){
					print("Verwende Standard JavaScript Engine dieser Java Vesion.");
				}
			}//End function enableJava
						
	      ]]>
  </scriptdef>
  
  <!-- ########################### -->
 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten. -->
 <scriptdef name="tryout_jaz_fileeasy_isRoot" language="javascript">
     <attribute name="inputfilepath" />
     <attribute name="returnboolean" />
     <![CDATA[
		   enableJava();
		   
		   //Allgemein für Import Statements gilt:
		   //importClass(Package.zxyz.abc.myclassZZZ);//um Verkürzt auf File zuzugreifen. sonst nur sinnvoll für Klassen, die nicht BasisJava sind und dann ist 'Package' notwendig
		   //                                                                  //Bei Klassen, die aus dem BasisJava stammen darf 'Package' nicht verwendet werden:    importClass(java.io.File);
	 
		   // import statements, funktionieren beide
			//importClass(package.basic.zBasic.util.datatype.string.StringZZZ);
			//importPackage(basic.zBasic.util.datatype.string);
			importPackage(Packages.basic.zBasic.util.file);
	 
			var test = java.lang.System.getProperty("java.class.path");
			print("classpath="+test);
			
			
			//#############
			 //#### EINGABE ######	 
			var myFilepath = attributes.get("inputfilepath");
			print("myFilepath="+myFilepath);
			
			//#### Java, etc.
			var bErg = FileEasyZZZ.isRoot(myFilepath);
			print("bErg="+bErg);
			
			
			//var serg = StringZZZ.toCamelCase(file2search,"_");
			//var serg = "test ohne java";
			//println("serg="+serg);
			
			// create and use a Task via Ant API
			//funktioniert hier nicht, selbst wenn man den Projektnamen angibt echo = MyProject.createTask("echo");
			//echo = self.getProject().createTask("echo");
			//echo.setMessage("Ergebnis + ": " + serg);
			//echo.perform();
         
			  
		//	var arrayFilenames=new Array();
		//	var arrayFilelengths=new Array();
			
		//	arrayFilenames.push('Woa'); 
		//	arrayFilenames.push('Wob'); 
		//	arrayFilelengths.push(1234); 
			
			
			//#### RÜCKGABE #####
			project.setProperty(attributes.get("returnboolean"), bErg);  
		//	project.setProperty(attributes.get("filenames"), arrayFilenames);
		//	project.setProperty(attributes.get("filelengths"), arrayFilelengths); 
		
		
		
		//Todo: Diese Funktion in den JSZ Kernel packen
			function enableJava(){
			/* Diese Funktion stellt alles bereit, um von JavaScript aus auf Java zuzugreifen.
			   - Stelle Kompatibilität zu Java 7 (Rhino) her, um importPackage, importClass nutzen zu können, die es im neuen Java 8 (Nashorn) nicht gibt.
			   - ....
			*/
			
				//zu Testzwecken:
				//var version = java.lang.System.getProperty("java.version");
				//print("Java Version:" + version);
				
				//var test = java.lang.System.getProperty("java.class.path");
				//println("classpath="+test);
				
				//Merke: Damit wird auch unter Java 8 (Nashorn) die alte Java 7 (Rhino) Funktionalität bereitgestellt.
				try{
					load("nashorn:mozilla_compat.js"); //Das wirft ausser in Java 8 einen Fehler.
				}catch(e){}
			}
	      ]]>
  </scriptdef>
         
  
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
  <!-- Merke: 'interne Targets' sollten mit einem Minuszeichen beginnen, so dass sie von aussen nicht gestartet werden können.
             Dies gibt einen 'unknown argument' Fehler, der sich unter Windows auch nicht mit dem Setzen in Hockkommata umgehen.-->
 <!--<target name="compile" depends=" -myTestJAZUsedByJavaScript_ErrorHandling, -myTestJAZUsedByJavaScript_ErrorHandlingCascaded, -myTestJAZUsedByJavaScript_FileEasyZZZ, -myTestJAZUsedByJavaScript_StringZZZ, ">-->
 <target name="compile" depends="-myTestJAZUsedByJavaScript_ErrorHandling">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>

	<target name="-myTestJAZUsedByJavaScript_ErrorHandling">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_ErrorHandling: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<trycatch property="myError" reference="myErrorObject">
		<try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
			<not>
				<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
			</not>
			<ac:then>
				<fl:fail message="FileEasyZZZ existiert nicht."/>
			</ac:then>
			<ac:else>
				<echo message="FileEasyZZZ vorhanden." />
			 </ac:else>
		 </ac:if>
		 
		 <!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		  <fl:let>myInputFilepath::="c:\\temp"</fl:let>
		 <echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_jaz_errorHandlingJs inputfilepath="${myInputFilepath}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		 
	 		
		<!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		<fl:let>myInputFilepath::="c:\\temp"</fl:let>
		<echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_jaz_errorHandlingJs inputfilepath="${myInputFilepath}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString2}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		
		 <fl:let>myInputFilepath::=""</fl:let>
		<echo>${sScript}myInputFilepath='${myInputFilepath}'</echo>
		<tryout_jaz_errorHandlingJs inputfilepath="${myInputFilepath}" returnboolean="myReturnValue03" returncontrol="myReturnControl03" returnControlString="myReturnControlString03"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl03} | ${myReturnControlString03} | ${myReturnValue03}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl03}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString03}</echo>	
				<fail message="${myReturnControlString03}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sicherstellen, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		</try>
		<catch>
			<echo>In &lt;catch&gt;.</echo>
			<echo>Fehler aus 'fail' in Ant abgefangen: ${myError}</echo>
		</catch>

		<finally>
			<echo>In &lt;finally&gt;.</echo>
		</finally>
	</trycatch>
		
		
	</target> 
	
	
	<target name="-myTestJAZUsedByJavaScript_ErrorHandlingCascaded">
	    <!-- Der Java/JAZ-Kernel Fehler tritt nun in einem Untertarget auf und soll bis nach 'oben' durchgereicht werden -->
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_ErrorHandlingCascaded: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
		<ac:var name="myReturnControl" value="true"/> <!-- unset="true"/> -->
		<ac:var name="myReturnControlString" value="alles o.k."/> <!-- unset="true" />-->
		
		<!--<fl:let>returnControlStringMain::='im Haupttarget alles ok. '</fl:let>-->
		<ac:var name="returnControlStringMain" value="im Haupttarget alles o.k."/> <!-- unset="true" />-->
		<echo>${sScript}Start</echo>

		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
		<!-- 1. Aufruf, sollte keinen Fehler werfen -->
		<fl:let>mysFiledirEscaped::='c:\\temp'</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
		<antcallback target="--myTestJAZUsedByJavaScript_SubtargetDummy" return="returnBoolean,returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->								
			</antcallback>			
			<ac:var name="myReturnControl" value="${returnControl}"/>
			<ac:var name="myReturnControlString" value="${returnControlString}"/>			
			<ac:if>
				<equals arg1="${myReturnControl}" arg2="false" />
				<ac:then>		 
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
				</ac:then>
				<ac:else>						
				</ac:else>
			</ac:if>
			<ac:if>
				<equals arg1="${returnBoolean}" arg2="false" />
				<ac:then>		
						<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
						<!--<fl:fail message="${sScript}${myReturnControlString}"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
						<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} ist nicht Root." />
				</ac:then>
				<ac:else>	
						<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} IST Root." />				
				</ac:else>
			</ac:if>
			
		<!-- 2. Aufruf mit Leerstring, sollte Fehler werfen! -->
		<fl:let>mysFiledirEscaped::=''</fl:let><!--wichtig: In Hochkommata setzen. Dadurch wird der Wert 'byValue' uebergeben, aber: Es wird einmal die Backslashverdoppelung wieder entfernt. -->							
		<antcallback target="--myTestJAZUsedByJavaScript_SubtargetDummy" return="returnControl,returnControlString">					
				<param name="sFiledir" value="${mysFiledirEscaped}" /><!--wichtig: In der aufgerufenen Methode den Wert per Hochkommata abholen. Dadurch wird der Wert 'byValue' uebergeben, aber es wird einmal die Backslashverdoppelung wieder entfernt. -->												
		</antcallback>	
		<ac:var name="myReturnControl" value="${returnControl}"/>
		<echo>${sScript}direkter Rueckgabewert abgeholt: ${returnControlString}</echo>
		<ac:var name="myReturnControlString" value="${returnControlString}"/>			
		<ac:if>
			<equals arg1="${myReturnControl}" arg2="false" />
		<ac:then>		
				<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
				<fl:fail message="${sScript}${myReturnControlString}"/><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->									
		</ac:then>
		<ac:else>						
		</ac:else>
		
		</ac:if>
		<ac:if>
			<equals arg1="${returnBoolean}" arg2="false" />
		<ac:then>		
				<!--<fl:echo message="${sScript}Fehler in -FGLDelLocal_DeleteFileSingle festgestellt - ${myReturnControlString}" />-->
				<!--<fl:fail message="${sScript}${myReturnControlString}"/>--><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird -->
				<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} ist nicht Root." />
		</ac:then>
		<ac:else>	
				<fl:echo message="${sScript}Verzeichnis ${mysFiledirEscaped} IST Root." />				
		</ac:else>
		</ac:if>
		
		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<!--<echo>${sScript}CATCH - Fehler zurueckgeben: ${myReturnControlString}</echo>-->
			
			<!-- Rueckgabe an das aufrufenden Target / Haupttarget -->
			<!--<fl:let>returnControlStringMain::=${myReturnControlString}</fl:let>-->
			<ac:var name="returnControlStringMain" value="${myReturnControlString}"/> <!-- unset="true" />-->
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
	
	
	<echo>${sScript}An aufrufendes Target/Haupttarget zurueckgeben: ${returnControlStringMain}</echo>
			
		
	</target> 
	
	<target name="--myTestJAZUsedByJavaScript_SubtargetDummy">
	    <!-- Der Java/JAZ-Kernel Fehler tritt nun in einem Untertarget auf und soll bis nach 'oben' durchgereicht werden -->
		<fl:let>sScript::='--myTestJAZUsedByJavaScript_SubtargetDummy: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<!-- Verwende für die von 'unten' nach 'oben' (also Richtung main-Methode) durchgereichten Variablen antcontrib mit unset="true". Verwende nicht flaka! -->
		<ac:var name="myReturnControl" value="true" unset="true"/>
		<ac:var name="myReturnControlString" value="alles o.k." unset="true" />
		<echo>${sScript}Start</echo>
         
		 <!-- Uebergabeparameter abholen -->
		<fl:let>mysFiledir::='${sFiledir}'</fl:let><!-- Warum geht hier die Referenz verloren? Das muss mit den Backslashes zu tun haben. Ausserdem muss der Wert mit Backslashes in Hochkommata übertragen werden, quasi eine Möglichkeit es als byValue zu übertragen. -->
	
		
		<!-- Wende hier von antcontrib den try...catch mechanismus an. -->
		<ac:trycatch property="myError" reference="myErrorObject">
		<ac:try>
		
		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
			<not>
				<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
			</not>
			<ac:then>
				<fl:fail message="${sScript}FileEasyZZZ existiert nicht."/>
			</ac:then>
			<ac:else>
				<echo message="${sScript}FileEasyZZZ vorhanden." />
			 </ac:else>
		 </ac:if>
	 		
		<!-- Hier wird die scriptdef Methode aufgerufen. Ein Leerstring führt zu einem Fehler (ExceptionZZZ) in der intern aufgerufenen JAZ-Kernel Klasse. -->
		<tryout_jaz_errorHandlingJs inputfilepath="${mysFiledir}" returnboolean="myReturnValue" returncontrol="myReturnControl" returnControlString="myReturnControlString"/>
		<echo message="myReturnControl | myReturnConstrolString | myReturnValue = ${myReturnControl} | ${myReturnControlString} | ${myReturnValue}" />
		<ac:if>
			<equals arg1="false" arg2="${myReturnControl}"/>
			<ac:then>							
				<echo>${sScript}Fehler aus Funktion zurueckgegeben: ${myReturnControlString}</echo>	
				<fail message="${myReturnControlString}" /><!-- Das fail bewirkt, dass das Ant Script sofort abgebrochen wird --><!-- das keepgoing-Attribut koennte in der for-Schleife sichergestellt werden, das jetzt nicht alles komplett aufhört -->				
			</ac:then>		
		</ac:if>
		
		</ac:try>
		<ac:catch>
			<!-- PROBLEM myError wird nicht zurückgegeben. --> 
			<!--<echo>In &lt;catch&gt;${sScript}.</echo>-->
			<!--<echo>${sScript}Fehler abgefangen: ${myError}</echo>-->					
			<property name="baz" refid="myErrorObject" />
			<!--<echo>${sScript}Fehler Object abgefangen: '${baz}'</echo>-->
			<ac:var name="myReturnControl" value="false"/>
			<ac:var name="myReturnControlString" value="${baz}"/>						
			<echo>${sScript}Fehler zurueckgeben: ${myReturnControlString}</echo>
		</ac:catch>
		<ac:finally>
			<echo>In &lt;finally&gt;${sScript}.</echo>
		</ac:finally>
	</ac:trycatch>
		
		<!--Rueckgabwerte an aufrufendes Target -->
		<ac:var name="returnBoolean" value="${myReturnBoolean}"/>
		<ac:var name="returnControl" value="${myReturnControl}"/>
		<ac:var name="returnControlString" value="${myReturnControlString}"/>	
	</target> 
	
	
	<target name="-myTestJAZUsedByJavaScript_FileEasyZZZ">
		<fl:let>sScript::='-myTestJAZUsedByJavaScript_FileEasyZZZ: '</fl:let>
		<fl:let>sTrace::=""</fl:let>
		<echo>${sScript}Start</echo>

		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
		<not>
			<available classname="basic.zBasic.util.file.FileEasyZZZ" />        
		</not>
	  <ac:then>
		<fl:fail message="FileEasyZZZ existiert nicht."/>
	   </ac:then>
	   <ac:else>
	   <echo message="FileEasyZZZ vorhanden." />
	   </ac:else>
	 </ac:if>
	 
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<tryout_jaz_fileeasy_isRoot inputfilepath="c:\\" returnboolean="myReturnValue"/>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		<!-- Hier wird die scriptdef Methode aufgerufen -->
		<tryout_jaz_fileeasy_isRoot inputfilepath="c:\\temp" returnboolean="myReturnValue"/>
		<echo message="myReturnValue = ${myReturnValue}" />
		
		<!-- Verwende antcontrib für eine Schleife über die Arrays --><!-- do something with @{myelement} -->
<!-- 		<for list="${myfilenames}" param="myelement">
			<sequential>				
				<echo>myelement= @{myelement}</echo>
			</sequential>
		</for> -->
		
	</target> 
	
	<target name="-myTestJAZUsedByJavaScript_StringZZZ">
		<echo>myTestJavaUsedByJavaScript: </echo>
		<property name="fs.dir" value="../testused"/>
		<property name="fs.includes" value="**/*.txt"/>
		<property name="fs.excludes" value="**/*.tmp"/>

		<!-- Probier aus, ob eine Java - Klasse zur Verfügung steht. Merke: Weil if nicht im scriptdef - Tag eingesetzt werden kann, ist das so nur hier möglich. -->
		<ac:if>
		<not>
			<available classname="basic.zBasic.util.datatype.string.StringZZZ" />        
		</not>
	  <ac:then>
		<fl:fail message="StringZZZ existiert nicht."/>
	   </ac:then>
	   <ac:else>
	   <echo message="StringZZZ vorhanden." />
	   </ac:else>
	 </ac:if>
	 
		<!-- Hier wird die scriptdef Methode tryout_java_file_length aufgerufen -->
		<tryout_jaz_string_camelcase filename_search="Das_ist_ein_camelcase_test" filenames="myfilenames" filelengths="myfilelengths" tryout="mytryout_string"/>
		<echo message="mytryout_string = ${mytryout_string}" />
		
		<!-- Verwende antcontrib für eine Schleife über die Arrays --><!-- do something with @{myelement} -->
<!-- 		<for list="${myfilenames}" param="myelement">
			<sequential>				
				<echo>myelement= @{myelement}</echo>
			</sequential>
		</for> -->
		
	</target> 
 </project>