<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_FlakaListHandling"   default="compile" basedir=".."
	xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->
	
		 <!-- ########################### -->
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<scriptdef name="listElementCountFlakaZZZ" language="javascript">
			<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
			Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
			<attribute name="lista" />
			<attribute name="ireturn" />
			<![CDATA[
				var lista = attributes.get("lista");		 
				var iReturn = -1;
											
				//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
				
				var icount=0;
				var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				if(typeof(objectArray)=="object"){
				for(x in objectArray){
					//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
					if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					}else{
						icount++;
					};				
				}							
				}else{
					iReturn=0;
				}
				
					//Merke: Zugriff auf die Bestandteile des Array bekäme man so:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 //for(yy in objectArray){
					//		print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
					//		print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
					//	};
									
				iReturn = icount;
				
				project.setProperty(attributes.get("ireturn"), iReturn);
			]]>
		</scriptdef>
		
		 <!-- ########################### -->
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
							 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		 <scriptdef name="substring" language="javascript">
			 <attribute name="text" />
			 <attribute name="start" />
			 <attribute name="end" />
			 <attribute name="property" />
			 <![CDATA[
			   var text = attributes.get("text");
			   var start = attributes.get("start");
			   var end = attributes.get("end") || text.length();
			   project.setProperty(attributes.get("property"), text.substring(start, end));
			 ]]>
		  </scriptdef>
		
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
 <target name="compile" depends="declaration,myTestArrayInitJsZZZ">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="declaration">
	  <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	  dies passiert hier durch flaka´s install-property handler task -->
	  <fl:install-property-handler />	
  </target>
  
	<target name="myTestArrayInitJsZZZ">
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayInitJsZZZ:
			Meine Loesung: Scriptdef arrayInitJsZZZ</fl:logo>		
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<testArrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<testArrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode listElementCountFlakaZZZ aufgerufen -->
		<listElementCountFlakaZZZ lista="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von listElementCountFlakaZZZ: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss <#!!FGLEMPTY!!#> drin stehen. -->
		
		<echo>#################################</echo>
		<fl:let>
			myArraySize::=0; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<testArrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<testArrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode listElementCountFlakaZZZ aufgerufen -->
		<listElementCountFlakaZZZ lista="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von listElementCountFlakaZZZ: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss <#!!FGLEMPTY!!#> drin stehen. -->
		
		<echo>#################################</echo>
		
			<fl:let>
			myArraySize::=1; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<testArrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Debug Ausgabe, wie das Array nun aussieht: -->
		<testArrayDebugJsZZZ arrayinput="${myArray}" iLevel="1"/>
		
		<!-- Hier wird die scriptdef Methode listElementCountFlakaZZZ aufgerufen -->
		<listElementCountFlakaZZZ lista="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse von listElementCountFlakaZZZ: ${iSize}</echo><!-- Auch diese Methode darf nur 0 zurückgeben. -->
		<echo>myArray nachher (2): ${myArray}</echo><!-- hier muss <#!!FGLEMPTY!!#> drin stehen. -->
		
		<echo>#################################</echo>
		
		
	</target>
  
	<target name="myTestArrayDebugJsZZZ">
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayDebugJsZZZ:
		Meine Loesung: Scriptdef arrayInitJsZZZ</fl:logo>		
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<!-- Hier wird die scriptdef Methode listElementCountFlakaZZZ aufgerufen -->
		<testArrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
	
		<!--TODO GOON:  -->	
		<testArrayDebugJsZZZ arrayinput="${myArray}" value="blabla" arrayreturn="myArray"/>
		
		<!-- TODO: nun andere Arrays mit anderen Größen testen -->
		<echo>myArray nachher (2): ${myArray}</echo>
		
		<!-- TODO: nun testen etwas daran etwas anhaengen -->
	</target> 
	
		<scriptdef name="testArrayInitJsZZZ" language="javascript">
			<!-- Hiermit faked man die Erstellung eines Arrays -->
			
			 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
                     Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
			<attribute name="isize" />
			<attribute name="arrayreturn" />		
			<![CDATA[		
								 
				var mySize = attributes.get("isize");	
				print("iSize = '" + mySize + "'");
				
				//Prüfen, ob mySize eine Zahl ist. 
				//Merke: Ist z.B. die Flaka - Variable nicht oder leer deklariert, kommt hier der Variablenname '${irgendwas}' an.
				//           Das bewirkt, dass dieses '${irgendwas}' als erstes Element in´s Array kommt und das Array sofort die Größe 1 hat, was in dem Fall nicht beabsichtigt ist.
				if(isNumber(mySize)){
					print("eine Zahl");
					var myArrayReturn = new Array(); //Merke: Egal was man hier als Groesse angiebt [irgendwas] wird als Wert übernommen genauso wie leiglich: irgendwas
					
					if(mySize==0){
								//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
								myArrayReturn[0]="<#!!FGLEMPTY!!#>";
					}
					
				//Definition eines Werts:
				//myArrayReturn[0]="kljlkj";
				//myArrayReturn[1]="ghfgh";
				//myArrayReturn[2]="tuztuz"; //Die über die ursprüngliche Dimensionierung hinausgehende Erweiterung ist egal...
									
				}else{
					print("KEINE Zahl");
					var myArrayReturn = new Array();

					//Analog zu LSZ: ZCraft.Logic.Formula32  wie <#!!FGLSLASH!!#> <#!!FGLDBLSLASH!!#>
					myArrayReturn="<#!!FGLEMPTY!!#>";
					}
				
			
				project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
				
				function isNumber(n) {
					return !isNaN(parseFloat(n)) && isFinite(n);
				}
			]]>
		</scriptdef>
		
			<scriptdef name="testArrayDebugJsZZZ" language="javascript">
			<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
                   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
				   - der Inhalt
				   - die Größe des Arrays			-->
			
			 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
                     Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
			<attribute name="arrayinput" />
			<attribute name="ilevel" />	
			<![CDATA[										 								
				var myArray = attributes.get("arrayinput");					
				var myLevel = attributes.get("ilevel");					
				if(myLevel<=0){
					
				}else{
				
				<!-- Typausgabe -->
				print("typeof myarray = " + typeof(myArray));
						
				
				var iSize=0;
				if(Array.isArray(myArray)){
					print("Array uebergeben bekommen");
					iSize = myArray.length;
					print("Arraygroesse="+iSize);
					
					//TODO: Die gleichen Ausgaben wie im KEIN ARRAY Fall.
					//- Werte
				}else{
					print("kein Array uebergeben bekommen.");
					
					var icount=0;					
					if(typeof(myArray)=="object"){
					    print("Object uebergeben bekommen.");
						
						if(myLevel>=2){
					    //das listet alle Methoden des objekts auf.... scheint ein String zu sein....
						//print("ALLE METHODEN DES OBJEKTS:");
						//for(x in myArray){
						//	print(x);		
						//};	
						
						print("#################################");
						print("ALLE METHODEN UND CODEINHALT DES OBJEKTS:");
						for(xx in myArray){
							print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
						};
						};//myLevel>=2;
						
						print("#################################");
						print("myArray ist jetzt leider ein String ='"+ myArray +"'");
						//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
						
						print("splitte diesn String nach Komma.");
						var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
						for(x in objectArray){
							print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
						};
						
						//var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
						//for(x2 in objectArray02){
						//	print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
						//};
						
						//var objectArrayString = myArray.toString();
						//var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
						//for(z in objectArray03){
						//	print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
						//};
						
						print("#################################");
						print("Versuch die Werte auszugeben: ");	
						//Merke: Voraussetzung ist:
						//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
						 for(yy in objectArray){
								print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
								print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
							};
						}else{
							print("kein Objekt");
							//iReturn=0;
						};
				};
				};//myLevel <= 0;
			]]>
		</scriptdef>
		
		<!-- Beispiel für JAVA Arrays
		<scriptdef name="validateTimeZone" language="javascript">
    <attribute name="zone" />
    <![CDATA[
        importClass(java.util.TimeZone);
        importClass(java.util.Arrays);
        var tz = attributes.get("zone"); //get attribute defined for scriptdef
        println("    got attribute: " + tz);
        var result = Arrays.asList(TimeZone.getAvailableIDs()).contains(tz); //testing if timezone is known
        project.setProperty("zoneIsValid", result);
    ]]> 
</scriptdef> 
-->
		
 </project>