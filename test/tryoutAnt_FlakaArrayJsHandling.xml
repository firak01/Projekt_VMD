<?xml version="1.0" encoding="UTF-8" ?>  
<project name="tryoutAnt_FlakaListHandling"   default="compile" basedir=".."
	xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->
	
		 <!-- ########################### -->
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<scriptdef name="listElementCountFlakaZZZ" language="javascript">
			<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
			Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
			<attribute name="lista" />
			<attribute name="ireturn" />
			<![CDATA[
				var lista = attributes.get("lista");		 
				var iReturn = -1;
											
				//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
				
				var icount=0;
				var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
				if(typeof(objectArray)=="object"){
				for(x in objectArray){
				icount++;
				}							
				}else{
					iReturn=0;
				}
				
					//Merke: Zugriff auf die Bestandteile des Array bekäme man so:
					//var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 //for(yy in objectArray){
					//		print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
					//		print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
					//	};
									
				iReturn = icount;
				
				project.setProperty(attributes.get("ireturn"), iReturn);
			]]>
		</scriptdef>
		
		 <!-- ########################### -->
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
							 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		 <scriptdef name="substring" language="javascript">
			 <attribute name="text" />
			 <attribute name="start" />
			 <attribute name="end" />
			 <attribute name="property" />
			 <![CDATA[
			   var text = attributes.get("text");
			   var start = attributes.get("start");
			   var end = attributes.get("end") || text.length();
			   project.setProperty(attributes.get("property"), text.substring(start, end));
			 ]]>
		  </scriptdef>
		
<!-- ################################################################################# -->
<!-- Die einzelnen Tests im depends hinzufügen -->
 <target name="compile" depends="declaration,myTestArrayInitJsZZZ">
    <echo>Im default - Target..., das von allen anderen Targets abhängt. </echo>
	<!-- WIRD NICHT BENÖTIGT -->
	
    <!-- Compile the java code from ${src} into ${build} -->
	<!-- example how to create a directory -->
    <!-- <mkdir dir="${build}"/>
	-->
    
	<!-- Example how to use a java compile task to compile files from a source file directory (containing .java files) to a build file directory (containig .class files) -->
	<!-- <javac debug="yes" srcdir="${src}" destdir="${build}">
    	<classpath refid="project.classpath"/>
    </javac>
	-->
  </target>
  
  <target name="declaration">
	  <!-- um EL referencen zusätzlich zu den normalen Ant Referencen anzustellen (außerhalb der Flaka Tasks), muss man die ant standard property 	helper engine austauschen.
	  dies passiert hier durch flaka´s install-property handler task -->
	  <fl:install-property-handler />	
  </target>
  
	<target name="myTestArrayInitJsZZZ">
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayInitJsZZZ:
			Meine Loesung: Scriptdef arrayInitJsZZZ</fl:logo>		
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<testArrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
		
		<!-- Hier wird die scriptdef Methode listElementCountFlakaZZZ aufgerufen -->
		<listElementCountFlakaZZZ lista="${myArray}" ireturn="iSize"/>
		<echo>ArrayGroesse: ${iSize}</echo>
		
		
		<echo>myArray nachher (2): ${myArray}</echo>
	</target>
  
	<target name="myTestArrayDebugJsZZZ">
		<!-- Merke: Die einzelnen Tests im depends vom target 'compile' hinzufügen-->
		<fl:logo>myTestArrayDebugJsZZZ:
		Meine Loesung: Scriptdef arrayInitJsZZZ</fl:logo>		
		<fl:let>
			myArraySize::=; 
		</fl:let>
		<echo>ArrayGroesse: ${myArraySize}</echo>
		<!-- Hier wird die scriptdef Methode listElementCountFlakaZZZ aufgerufen -->
		<testArrayInitJsZZZ isize="${myArraySize}" arrayreturn="myArray"/>
		<echo>myArray nachher: ${myArray}</echo>
	
		<!--TODO GOON -->	
		<testArrayDebugJsZZZ arrayinput="${myArray}" value="blabla" arrayreturn="myArray"/>
		
		<!-- TODO: nun andere Arrays mit anderen Größen testen -->
		<echo>myArray nachher (2): ${myArray}</echo>
		
		<!-- TODO: nun testen etwas daran etwas anhaengen -->
	</target> 
	
		<scriptdef name="testArrayInitJsZZZ" language="javascript">
			<!-- Hiermit faked man die Erstellung eines Arrays -->
			
			 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
                     Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
			<attribute name="isize" />
			<attribute name="arrayreturn" />		
			<![CDATA[		
								 
				var mySize = attributes.get("isize");	
				print("iSize = '" + mySize + "'");
				
				//TODO: Prüfen, ob mySize eine Zahl ist. 
				//Merke: Ist z.B. die Flaka - Variable nicht oder leer deklariert, kommt hier der Variablenname '${irgendwas}' an.
				//           Das bewirkt, dass dieses '${irgendwas}' als erstes Element in´s Array kommt und das Array sofort die Größe 1 hat, was in dem Fall nicht beabsichtigt ist.
				
				var myArrayReturn = new Array([mySize]);
				//Definition eines Werts:
				//myArrayReturn[0]="kljlkj";
				//myArrayReturn[1]="ghfgh";
				//myArrayReturn[2]="tuztuz"; //Die über die ursprüngliche Dimensionierung hinausgehende Erweiterung ist egal...
				
				project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			]]>
		</scriptdef>
		
			<scriptdef name="testArrayDebugJsZZZ" language="javascript">
			<!-- Hiermit versuche ich an ein vorher erstelltes JavaScript-Array einen Wert anzuhängen,
                   was daran scheitert, das die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt			-->
			
			 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
                     Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
			<attribute name="arrayinput" />
			<attribute name="value" />
			<attribute name="arrayreturn" />		
			<![CDATA[										 								
				var myArray = attributes.get("arrayinput");					
				var myValue = attributes.get("value");					
				
				
				print("typeof myarray = " + typeof(myArray));
						
				
				var iSize=0;
				if(Array.isArray(myArray)){
					print("Array uebergeben bekommen");
					iSize = myArray.length;
					print("Arraygroesse="+iSize);
				}else{
					print("kein Array uebergeben bekommen.");
					
					var icount=0;					
					if(typeof(myArray)=="object"){
					    print("Object uebergeben bekommen.");
					
					    //das listet alle Methoden des objekts auf.... scheint ein String zu sein....
						for(x in myArray){
							print(x);		
							//print(typeof(x));
							icount++;
						};	
						
						print("myArray ist jetzt leider ein String ='"+ myArray +"'");
						//print("myArray[0]='"+myArray[0]+"'");    //Versuch so auf den Inhalt des Arrays zuzugreifen. ABER FEHLER: java.lang.String has no public instce field or method named "0".
						

						var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.
						for(x in objectArray){
							print("x: '"+ x + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
						//	print(typeof(x));
						};
						
						var objectArray02= new Array(myArray);				//Merke: Versuche so ein Array zu machen.
						for(x2 in objectArray02){
							print("x2: '"+ x2 + "'");  //ABER: Durch die neuezuweisung bekommt man nur noch die "0"
						//	print(typeof(x));
						};
						
						var objectArrayString = myArray.toString();
						var objectArray03 = objectArrayString.split(',');		//Merke: Versuche so ein Array zu machen.
						for(z in objectArray03){
							print("z: '"+ z + "'");		//ABER: Damit bekommt man die Indizes und nicht die Werte. Also "0","1","2" !!!!	Man erzeugt also damit auch kein Array
						//	print(typeof(x));
						};
						
						for(xx in myArray){
							print("xx: '"+ xx + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber xx: '" + myArray[xx] + "'"); //damit bekommt man codeinhalt der Methoden.
							//	print(typeof(x));
						};
						
					//Merke: var objectArray = myArray.split(',');						//Merke: Versuche so ein Array zu machen.	
					 for(yy in objectArray){
							print("yy: '"+ yy + "'");		//ABER: Damit bekommt man die Namen der Methoden
							print("zugriff ueber yy: '" + objectArray[yy] + "'"); //BINGO !!!!
							//	print(typeof(x));
						};
					}else{
						print("kein Objekt");
						//iReturn=0;
					};
				};
				
				//project.setProperty(attributes.get("arrayreturn"), myArrayReturn);
			]]>
		</scriptdef>
		
		<!-- Beispiel für JAVA Arrays
		<scriptdef name="validateTimeZone" language="javascript">
    <attribute name="zone" />
    <![CDATA[
        importClass(java.util.TimeZone);
        importClass(java.util.Arrays);
        var tz = attributes.get("zone"); //get attribute defined for scriptdef
        println("    got attribute: " + tz);
        var result = Arrays.asList(TimeZone.getAvailableIDs()).contains(tz); //testing if timezone is known
        project.setProperty("zoneIsValid", result);
    ]]> 
</scriptdef> 
-->
		
 </project>