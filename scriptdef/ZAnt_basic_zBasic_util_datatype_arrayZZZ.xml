 <project name="ZAnt_basic_util_datatype_arrayZZZ"   basedir=".."
	xmlns:ac="antlib://net/sf/antcontrib"
	xmlns:fl="antlib:it.haefelinger.flaka"><!-- damit definiert man für FLAKA einen eigenen Namespace -->

	<!-- ############################################################-->
	<scriptdef name="arrayAppendJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="valueinput" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="returncontrol" />
		<attribute name="returncontrolstring" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myValue = attributes.get("valueinput");
			var myFlagControl = attributes.get("sflagcontrol");
			
			//Aufruf der "Arbeitsfunktion".
			var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
			var objControlCaller=new Object();
			var arrReturn = arrayAppendJs(objKernelLibs, myArray, myValue, objControlCaller);				
			if(!objControlCaller.bReturnControl){									
				bReturnControl=false;
				sReturn="";
				iReturn=-1;
			}else{					
			}
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
	
			//project.setProperty(attributes.get("ireturn"), iReturn);			
			project.setProperty(attributes.get("arrayreturn"), arrReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
						
			//### START SNIPPET 01 ################################################################
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
		
			//###################################################################
            //### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			//### ENDE SNIPPET 01 ################################################################
			
		//######################################################################################################
		function arrayAppendJs(objKernelLibs, myArray, myValue, objControl){
			var myArrayReturn = new Array();
			
			//###START SNIPPET 02 ###################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript=null;
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null)	throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
					//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
					var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
					var objControlCallerKernel=new Object();
					var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
					if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
				}
				
				//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
				for (var i = 0; i < objKernelLibs.length; i++) { 	
					//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
					//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
					//funktioniert: 
					eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
					//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
				}				
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl="Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("###ENDE SNIPPET 02 ###################################################");
			
			if(myArray==undefined || myArray==null)	throw new Error("Kein Array uebrgeben.");
			if(myValue==undefined || myValue==null){
				bReturnControl=true;
				sReturnControl="Alles o.k.. Anzuhängender Wert war NULL oder undefined.";
				break main;
			}
			
			//TEST: FEHLER PROVOZIEREN
			print ("Ddas gibts nicht" + nixda);
						
			
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
			
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					}
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugenbende Array
			icount=-1; icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;					
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				}
			}
						
			//3. Erweitere das Array UM ENCODIERTEN WERT
			icountGlobal++;
			print("Wert encoded anhängen an position " + icountGlobal + ": '" + myValue + "'");
			var textEncoded = encodeMyHtml(myValue);
			print("Encoded Wert wird kopiert: '" + textEncoded + "'");
			
			//TODO An dieser Stelle bei der Erweiterung arrays anzuhängen: Prüfen, ob das ein Einzelwert oder ein Array ist.
			myArrayReturn[icountGlobal]=textEncoded;
		
			//bReturnControl=objControlCallerImplode.bReturnControl;
			//sReturnControl=objControlCallerImplode.sReturnControl;
			sReturnControl="Alles o.k.";
			bReturnControl=true;
					//print("### START SNIPPET 03 ###################################################");
					//print(sScript + "ENDE");								
					} //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;
            //### ENDE SNIPPET 03 ###########################################################			
			
			return myArrayReturn;
		}																		
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayAppendArrayJsZZZ" language="javascript">
		<!-- Hiermit häng man an ein Array einen anderen Wert (Array oder Einzelwert) an.
             Merke: Hier wird nicht encoded da davon ausgegangen wird, das die anzuhängenden Werte schon encoded erzeugt wurden.-->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
			 
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
					Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. -->
		<attribute name="arrayinput" />
		<attribute name="array2append" /><!-- Erst einmal nur als Einzelstring, später auch Array an Array anhängen. -->
		<attribute name="arrayreturn" />
		<attribute name="returncontrol" />
		<attribute name="returncontrolstring" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->

		<![CDATA[
			var myArray = attributes.get("arrayinput");		 
			var myArray2append = attributes.get("array2append");
			var myFlagControl = attributes.get("sflagcontrol");
						
			//Aufruf der "Arbeitsfunktion".
			var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
			var objControlCaller=new Object();
			var arrReturn = arrayAppendArrayJs(objKernelLibs, myArray, myArray2append, objControlCaller);				
			if(!objControlCaller.bReturnControl){									
				bReturnControl=false;
				sReturn="";
				iReturn=-1;
			}else{					
			}
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
	
			//project.setProperty(attributes.get("ireturn"), iReturn);				
			project.setProperty(attributes.get("arrayreturn"), arrReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
				
			
			//### START SNIPPET 01 ################################################################
			project.setProperty(attributes.get("returncontrol"),bReturnControl);
			project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
		
			//###################################################################
            //### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			//### ENDE SNIPPET 01 ################################################################
			
		//######################################################################################################
		function arrayAppendArrayJs(objKernelLibs, myArray, myArray2append, objControl){
			var myArrayReturn = new Array();
			
			//###START SNIPPET 02 ###################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript=null;
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null)	throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
					//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
					var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
					var objControlCallerKernel=new Object();
					var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
					if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
				}
				
				//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
				for (var i = 0; i < objKernelLibs.length; i++) { 	
					//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
					//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
					//funktioniert: 
					eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
					//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
				}				
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl="Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("###ENDE SNIPPET 02 ###################################################");
			
			var objectArray2append = myArray2append.split(',');  //Merke: Versuche so ein Array zu machen.							
			var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
			var icount=-1;
			var iuboundfilled=-1;
			var bnormal=true;
					
			//1. Ermittle von hinten die "UNDEFINED" Werte und somit das ubound "gefuellter Werte".									
			for(x in objectArray){
				//print("Wert: '" + objectArray[x]+ "'");
				icount++;
			
				//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
				if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
				    if(bnormal==true){					
						iuboundfilled = icount-1; //und diese Grenze nur noch verschieben, wenn ein normaler Wert dazwischen kommt.
						bnormal = false;
					};
				}else if(objectArray[x]=="<#!!FGLEMPTY!!#>"){
					//nix tun bei leeren Werten.
					bnormal=true;
				}else{
					//nix tun bei normalen Werten.
					bnormal=true;
				};				
			};
			if(iuboundfilled==-1 && bnormal==true) iuboundfilled = icount;
						

			//2. Kopiere die Werte von 0 bis iboundfilled in das zurueckzugebende Array
			icount=-1; 
			var icountGlobal=-1;
			for(x in objectArray){
				icount++;
				if(icount<=iuboundfilled){
					icountGlobal++;
					//print("Wert wird kopiert: '" + objectArray[x]+ "'");
					myArrayReturn[icount]=objectArray[x];
				}else{
					//nix
				};
			};
						
			//3. Erweitere das Array, UM ALLE ANDEREN ARRAYWERTE
			for(z in objectArray2append){								
				if(objectArray2append[z]=="<#!!FGLUNDEFINED!!#>"){
					print("<#!!FGLUNDEFINED!!#> Wert NICHT anhaengen.");
				}else{
					icountGlobal++;
					print("Wert anhaengen an position " + icountGlobal + ": '" + objectArray2append[z]+ "'");
					myArrayReturn[icountGlobal]=objectArray2append[z];
				};							
			};			
			
			
			//bReturnControl=objControlCallerImplode.bReturnControl;
			//sReturnControl=objControlCallerImplode.sReturnControl;
			sReturnControl="Alles o.k.";
			bReturnControl=true;
					//print("### START SNIPPET 03 ###################################################");
					//print(sScript + "ENDE");								
					} //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;
            //### ENDE SNIPPET 03 ###########################################################			
			
			return myArrayReturn;
			}
		]]>
	</scriptdef>
	
	<!-- ############################################################-->
	<scriptdef name="arrayCopyJsZZZ" language="javascript">
		<!-- Hiermit kopiert man ein Array in eine anderes neues Array.
             Beispielsweise sinnvoll, wenn von einer Funktion ein neues Array zurückgegeben wird,
             man aber noch mit dem alten 'Variablennamen' weiterarbeiten möchte.			 -->
		
	<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
		<attribute name="sDirRepositoryJsscriptdef" /><!-- Falls mal der Name des Verzeichnisses der Bibliothek überschrieben werden soll -->
					
		<attribute name="arrayinput" />
		<attribute name="arrayreturn" />
		<attribute name="sflagcontrol" /> <!-- so mögliche Erweiterungen wie 'leere auffüllen' von vorne bzw. von hinten realisieren. -->
		
		<attribute name="returnstring" /> 
		<attribute name="returncontrol" /> 
		<attribute name="returncontrolString" />
			

		<![CDATA[
			var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
		
			var myArray = attributes.get("arrayinput");		 
			var myFlagControl = attributes.get("sflagcontrol");
			var myArrayReturn = new Array();
			
			//###################################################################
			//### Die benoetigten Kernel-Funktionen laden
			//###################################################################			
			var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
			var objControlCaller=new Object();
			myArrayReturn=arrayCopyJs(objKernelLibs, myArray, objControlCaller);				
			if(!objControlCaller.bReturnControl){									
				bReturnControl=false;
				sReturn="";
				iReturn=-1;
				myArrayReturn=null;
			}else{					
			}
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			
			//project.setProperty(attributes.get("ireturn"), iReturn);				
			project.setProperty(attributes.get("arrayreturn"), myArrayReturn);			
			//project.setProperty(attributes.get("arrayreturn"), arrReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
			//project.setProperty(attributes.get("returncontrol"),bReturnControl);
			//project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			//###################################################################
            //#### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, die in einer Bibliothek ausgelagert wurde, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
		function arrayCopyJs(objKernelLibs,myArray,objControl){			
			var iReturn=-1;
			var objReturn="<#!!FGLUNDEFINED!!#>";
			var arrReturn=null;
			var myArrayReturn=new Array();
			var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
											
            //######################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript=null;
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null){
					throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				} else{						
					if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
						//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
						var objControlCallerKernel=new Object();
						var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
						if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
					}
					
					//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
						//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
						//funktioniert: 
						eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
						//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
					}				
				}
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("######################################################");
								
						var objectArray = myArray.split(',');  //Merke: Versuche so ein Array zu machen.				
						var icount=-1;
						
						//Kopiervorgang, noch ohne irgendwelche FlagControl Erweiterungen.			
						for(x in objectArray){
							//print("Wert: '" + objectArray[x]+ "'");
							icount++;
							myArrayReturn[icount]=objectArray[x];
						};
						//bReturnControl=objControlCallerImplode.bReturnControl;
						//sReturnControl=objControlCallerImplode.sReturnControl;
						sReturnControl="Alles o.k.";
						bReturnControl=true;					
						//print("######################################################");
						//print(sScript + "ENDE");								
					}; //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}			
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;						
			//return objReturn;	
			return myArrayReturn;
		}															
		]]>
	</scriptdef>
	
 <!-- ############################################################ -->
	<scriptdef name="arrayDebugJsZZZ" language="javascript">
		<!-- Hiermit gibt man Informationen eines vorher erstelltes JavaScript-Arrays aus.
			   - ob die übergebene Variable gar kein JavaScript-Array mehr ist, sondern nur noch ein Objekt, 
			   - der Inhalt
			   - die Größe des Arrays			-->
		
		 <!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in den eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				 Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung!!! -->
		<attribute name="sDirRepositoryJsscriptdef" /><!-- Falls mal der Name des Verzeichnisses der Bibliothek überschrieben werden soll -->
	
		<attribute name="arrayinput" />
		<attribute name="ilevel" />	
		
	<!--<attribute name="returnstring" /> 
	<attribute name="returncontrol" /> 
	<attribute name="returncontrolString" />-->
	
		<![CDATA[	
			var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
		
			var myArray = attributes.get("arrayinput");					
			var myLevel = attributes.get("ilevel");					
			if(myLevel<=0){
				
			}else{
				if(myArray===undefined) print("myarray = undefined");
				if(myArray==null) print("myarray = NULL");	
				
				//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
				var sReturn="";
				var bReturn=false; //Wird hier nicht zurueckgegeben
				var bReturnControl=false;
				var sReturnControl="Fehler";
			
				//Die benoetigten Kernel-Funktionen laden
				var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
				var objControlCaller=new Object();
				arrayDebugJs(objKernelLibs, myArray, objControlCaller);				
				if(!objControlCaller.bReturnControl){									
					bReturnControl=false;
					sReturn="";
				}else{					
				}
				bReturnControl=objControlCaller.bReturnControl;
				sReturnControl=objControlCaller.sReturnControl;
					
				//project.setProperty(attributes.get("returnstring"),sReturn);
				//project.setProperty(attributes.get("returncontrol"),bReturnControl);
				//project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
			}//else myLevel <=0
			
			//###################################################################
            //#### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				var bReturn=false; //Wird hier nicht zurueckgegeben
				var bReturnControl=false;
				var sReturnControl="Fehler";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			
		//####################################################################################################					
		function arrayDebugJs(objKernelLibs, myArray, objControl){	 	
			var bReturn=true;
			var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
			var bReturnControl=false;
			var sReturnControl="Fehler";	
				
			 //######################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript = "arrayDebugJs: ";
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null){
					throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				} else{						
					if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
						//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
						var objControlCallerKernel=new Object();
						var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
						if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
					}
					
					//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
						//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
						//funktioniert: 
						eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
						//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
					}				
				}
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("######################################################");
						
				var objControlCaller=new Object();			
				debugArray(myArray,objControlCaller);
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);						
				bReturnControl=objControlCaller.bReturnControl;
				sReturnControl=objControlCaller.sReturnControl;
			
				//print("######################################################");
						//print(sScript + "ENDE");								
					}; //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}			
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;
			return bReturn;
		}							
		]]>
	</scriptdef>

 <!-- ############################################################# -->	
	<scriptdef name="arrayElementCountJsZZZ" language="javascript">
		<!-- Hiermit faked man die Ermittlung einer size, welche nach Anwendung flaks von split(...) nicht das gewünschte Ergebnis liefert.
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	 -->
		
		 <!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
		<attribute name="sDirRepositoryJsscriptdef" /><!-- Falls mal der Name des Verzeichnisses der Bibliothek überschrieben werden soll -->
				
	
		<attribute name="arrayinput" />
		<attribute name="ireturn" />

		<attribute name="returnstring" /> 
		<attribute name="returncontrol" /> 
		<attribute name="returncontrolString" />
			

		<![CDATA[			
			var lista = attributes.get("arrayinput");		 
			var iReturn = -1;
			
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			
			var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
			var objControlCaller=new Object();
			iReturn=arrayElementCountJs(objKernelLibs, objControlCaller);				
			if(!objControlCaller.bReturnControl){									
				bReturnControl=false;
				sReturn="";
				iReturn=-1;
			}else{					
			}
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
	
			project.setProperty(attributes.get("ireturn"), iReturn);			
			//project.setProperty(attributes.get("arrayreturn"), arrReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
			//project.setProperty(attributes.get("returncontrol"),bReturnControl);
			//project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			//### START SNIPPET 01 ################################################################
            //### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			//### ENDE SNIPPET 01 ################################################################
			
		//######################################################################################################
		function arrayElementCountJs(objKernelLibs, objControl){	
			var iReturn=-1;
			var arrReturn=null;
			var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.

			//###START SNIPPET 02 ###################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript=null;
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null){
					throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				} else{						
					if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
						//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
						var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
						var objControlCallerKernel=new Object();
						var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
						if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
					}
					
					//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
						//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
						//funktioniert: 
						eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
						//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
					}				
				}
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("###ENDE SNIPPET 02 ###################################################");
									
						var icount=0;
						var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
						if(typeof(objectArray)=="object"){
							for(x in objectArray){
								//Merke: Bei ArrayInit() wird dies gesetzt, damit ein lediglich nur initialisiertes Array erkannt werden kann.
								if(objectArray[x]=="<#!!FGLUNDEFINED!!#>"){
								}else{
									icount++;
								};				
							}	
							iReturn=icount;
						}else{
							iReturn=0;
						}

						//bReturnControl=objControlCallerImplode.bReturnControl;
						//sReturnControl=objControlCallerImplode.sReturnControl;
						sReturnControl="Alles o.k.";
						bReturnControl=true;
						//print("### START SNIPPET 03 ###################################################");
						//print(sScript + "ENDE");								
					} //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;
            //### ENDE SNIPPET 03 ###########################################################			
			return iReturn;	
			}
		]]>
	</scriptdef>
	
<!-- ########################### -->	
	<scriptdef name="arrayGetJsZZZ" language="javascript">
		<!-- Hiermit holt man den Wert an einer Indexposition (beginnend mit 0)
		Es wird einfach ein String hinsichtlich der Kommata zerlegt. DAS IST GEFAEHRLICH.	-->
				
		<!-- Verwende dieses Ergebnis aus der Tatsache, dass FLAKA keine korrekte Größe einer Liste zurückgibt -->
		<!-- Merke: Es gibt in Ant und auch in den dazugehörigen Bibliotheken (Flaka, AntContrib) nix für entsprechende Listenobperationen.
					Also weder für die Größenermittlung, noch für den Zugriff auf ein Listenelement mit Index, wie z.B. lista[2].
					Es gibt zwar z.B. size(list(1,2)), das aber hier nicht funktioniert.
					Darum mit scriptdef behelfen. -->
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
		<attribute name="sDirRepositoryJsscriptdef" /><!-- Falls mal der Name des Verzeichnisses der Bibliothek überschrieben werden soll -->
				
		<attribute name="arrayinput" />
		<attribute name="index" />
		<attribute name="arrayget" />
		<attribute name="sflagcontrol" /><!-- sflagcontrol werte: raw=mache kein unescape. -->
		
		<attribute name="returnstring" /> 
		<attribute name="returncontrol" /> 
		<attribute name="returncontrolString" />
		
		<![CDATA[
			var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
		
			var lista = attributes.get("arrayinput");		 
			var iIndex = attributes.get("index");
			var mysFlagControl = attributes.get("sflagcontrol");
			var objReturn="<#!!FGLUNDEFINED!!#>";
			
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			
			var objKernelLibs = new Array();
			var objControlCaller=new Object();
			objReturn=arrayGetJs(objKernelLibs, lista, iIndex, objControlCaller);				
			if(!objControlCaller.bReturnControl){									
				bReturnControl=false;
				sReturn="";
				iReturn=-1;
				objReturn="<#!!FGLUNDEFINED!!#>";
			}else{					
			}
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			
			project.setProperty(attributes.get("arrayget"), objReturn);
			
			//project.setProperty(attributes.get("ireturn"), iReturn);			
			//project.setProperty(attributes.get("arrayreturn"), arrReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
			//project.setProperty(attributes.get("returncontrol"),bReturnControl);
			//project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			//### START SNIPPET 01 ################################################################
            //### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			//### ENDE SNIPPET 01 ################################################################
			
		//######################################################################################################
		function arrayGetJs(objKernelLibs,lista,iIndex,objControl){
			var sScript=null;
			var iReturn=-1;
			var objReturn="<#!!FGLUNDEFINED!!#>";
			var arrReturn=null;
			var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
			var bReturnControl=false;
			var sReturnControl="Fehler";
			var bKernelInitialised=true;
							
            //###START SNIPPET 02 ###################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript=null;
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null){
					throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				} else{						
					if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
						//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
						var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
						var objControlCallerKernel=new Object();
						var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
						if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
					}
					
					//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
						//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
						//funktioniert: 
						eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
						//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
					}				
				}
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("###ENDE SNIPPET 02 ###################################################");
					
						if(iIndex <= -1) break main;
						
						//Merke: lista ist irgendwie nur ein String, oder das was einen String zurückgibt: lista.lastIndexOf('a'); //funktioniert
					
						var icount=-1;
						var objectArray = lista.split(',');						//Merke: Man erzeugt damit auch kein normales Array, aber man kann die Werte durchzählen.
						if(typeof(objectArray)=="object"){
						for(x in objectArray){
							//print("x="+x);
							//print("objectArray[x]="+objectArray[x]);
							
							//Undefinierte, d.h. nur initialisierte Arrays abfangen
							//Sie haben die Groesse 0 und an erster Stelle das <#!!FGLUNDEFINED!!#>
							if(objectArray.length<=1 && objectArray[x]=="<#!!FGLUNDEFINED!!#>"){						
								break main;
							}else{
								icount++;
								if(icount==iIndex){
									//Per Schalter das unescapen abstellbar machen. Also auf Wunsch also die 'raw Werte' zurückliefern.
									if(mysFlagControl=='raw'){
										objReturn = objectArray[x];
									}else{
										var textUnescaped = unescape(objectArray[x]); //Merke: In ArrayAppendJsZZZ werden die Strings nur noch encoded angehängt.
										objReturn = textUnescaped;								
									}
									break main;
								}				
							}; //end if
							}; //end for
						}; //end if(typeof(objectArray)=="object")				
						//bReturnControl=objControlCallerImplode.bReturnControl;
						//sReturnControl=objControlCallerImplode.sReturnControl;
						sReturnControl="Alles o.k.";
						bReturnControl=true;
						//print("### START SNIPPET 03 ###################################################");
						//print(sScript + "ENDE");								
					} //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;
            //### ENDE SNIPPET 03 ###########################################################								
			return objReturn;	
			}
		]]>
	</scriptdef>
				
	<!-- ############################################################-->		
	<scriptdef name="arrayInitJsZZZ" language="javascript">
		<!-- Hiermit faked man die Erstellung eines Arrays.
			 Da scheinbar kein "call by reference" gemacht wird, muss das neue Array als neue Variable zurückgegeben werden.-->
		
		<!-- Merke: Da scheinbar kein 'call by reference' gemacht wird, muss ein geänderter Wert als neue Variable zurückgegeben werden.-->		
		<!-- MERKE: GROSS-/Kleinschreibung ist bei den Tagnamen wichtig! Trotzdem in der eingesetzten -ZZZ Funktionen wg. der Übersicht die Camelcase Variante beibehalten.
				Bei den Attributen, die in den Tags verwendet werden, funktioniert nur Kleinschreibung. --> 
		<attribute name="sDirRepositoryJsscriptdef" /><!-- Falls mal der Name des Verzeichnisses der Bibliothek überschrieben werden soll -->
				
		<attribute name="isize" />		
		<attribute name="arrayreturn" />		
		<!--<attribute name="returnstring" />-->
		<attribute name="returncontrol" /> 
		<attribute name="returncontrolString" />
	
		<![CDATA[							
			var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
		
			var mySize = attributes.get("isize");	
			//print("iSize = '" + mySize + "'");
			
			//There is no "pass by reference" available in JavaScript. You can pass an object (which is to say, you can pass-by-value a reference to an object) and then have a function modify the object contents:
			var arrReturn=null;
			var sReturn="";
			var bReturn=false; //Wird hier nicht zurueckgegeben
			var bReturnControl=false;
			var sReturnControl="Fehler";
			
			//###################################################################
			//### Die benoetigten Kernel-Funktionen laden
			//###################################################################			
			var objKernelLibs = new Array(); //ACHTUNG, NICHT LOESCHEN DOKU: objKernelLibs als eigenes Objekt in den Funktionsargumenten. Grund: Sonst müsste bei jedem objControlCaller Objekt die objKernelLibs erst ubergeben werden.
			var objControlCaller=new Object();			
			arrReturn=arrayInitJs(objKernelLibs, mySize, objControlCaller);				
			if(!objControlCaller.bReturnControl){									
				bReturnControl=false;
				sReturn="";
			}else{					
			}
			bReturnControl=objControlCaller.bReturnControl;
			sReturnControl=objControlCaller.sReturnControl;
			
			project.setProperty(attributes.get("arrayreturn"), arrReturn);
			//project.setProperty(attributes.get("returnstring"),sReturn);
			//project.setProperty(attributes.get("returncontrol"),bReturnControl);
			//project.setProperty(attributes.get("returncontrolstring"),sReturnControl);
						
			//### START SNIPPET 01 ################################################################
            //### KERNEL LIBS HINZUFÜGEN
            //###################################################################			
			function enableKernelAntJs(objKernelLibs, sDirSubDefault, objControl){			
				var sScript = "enableKernelAntJs: ";
				try{
					if(objKernelLibs==undefined || objKernelLibs==null){
						var err = new Error("objKernelLibs nicht deklariert.");
						throw err;
					}
					if(sDirSubDefault==undefined || sDirSubDefault==null){				
						sDirSubDefault="jsscriptdef";
					}else if(sDirSubDefault.trim()==''){
						sDirSubDefault="jsscriptdef";
					}
					eval('' + org.apache.tools.ant.util.FileUtils.readFully(new java.io.FileReader( '../'+sDirSubDefault+'/ZAnt.basic.zBasic.HandleKernelZZZ.js' )) ); //Zentrale Funktion, in der alle anderen Bibliotheken zur Verf�gung gestellt werden.
										
					var objControlCaller=new Object();
					usedKernelAntLibJs(objKernelLibs, sDirSubDefault, objControlCaller); //Rufe die zentrale Funktion auf, um die weiteren Bibliotheken einubinden.
					if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);	
						
					bReturnControl=true;
					sReturnControl=sScript+"Alles o.k.";
					bReturn=true;
				}catch(err){	
					//#### SIMPLES ERROR HANDLING #######
					print(sScript+"Fehler gefangen: " + err);
					bReturnControl=false;
					sReturnControl=sScript+"Fehler. "+ err;					
				}
				objControl.bReturnControl=bReturnControl;
				objControl.sReturnControl=sReturnControl;
				return bReturn;
			}
			//### ENDE SNIPPET 01 ################################################################
			
		//######################################################################################################
		function arrayInitJs(objKernelLibs, mySize, objControl){	
			var sScript=null;
			var arrReturn=null;
			var sReturn="nixnix"; //Ziel dieses Tests ist es den Namen der in der Unterfunktion ermitteltent aufrufenden Funktion an die aufrufende Ant-Script-Ebene zurueckzugeben.
			//###START SNIPPET 02 ###################################################################################################################			
			//IN JEDER FUNKTION DAS LADEN DER FUNKTIONEN PER EVAL AUSFUEHREN, SONST STEHEND DIE FUNKTIONEN NICHT ZUR VERFUEGUNG	
            //######################################################################################################################
			var sScript=null;
			var bKernelInitialised=true;
			var bReturnControl=false;
			var sReturnControl="Fehler";	
			try{				
				if(objKernelLibs==undefined || objKernelLibs==null){
					throw new Error("Keine Kernel Ant Js Libs uebergeben.");
				} else{						
					if(objKernelLibs.length==0 || objKernelLibs.length==undefined){
						//print("Noch keine Kernel Ant Js Libs vorhanden zum Laden, lade sie jetzt.");
						
						var sDirRepositoryJsscriptdef = attributes.get("sDirRepositoryJsscriptdef");
						var objControlCallerKernel=new Object();
						var bReturn = enableKernelAntJs(objKernelLibs, sDirRepositoryJsscriptdef, objControlCallerKernel);			
						if(!objControlCallerKernel.bReturnControl) throw new Error(objControlCallerKernel.sReturnControl);	
					}
					
					//print("Eval Kernel Ant Js Libs: " + objKernelLibs.length);
					for (var i = 0; i < objKernelLibs.length; i++) { 	
						//print("Lib: " + objKernelLibs[i]["ALIAS"]);					
						//print("LOADINGSTRING: " + objKernelLibs[i]["LOADINGSTRING"]);
						//funktioniert: 
						eval(''+objKernelLibs[i]["LOADER"]); //Loader-String einsetzen.
						//funktioniert nicht, is ein bissl zuviel: eval(objKernelLibs[i]["CODEEXECUTED"]);
					}				
				}
				enableJava();//Der Aufruf geht erst nachdem die Kernelbibliotheken geladen wurden	
				var objControlCaller = new Object();
				sScript = reflectMethodCurrent_Name(null, objControlCaller) + ": ";					
				if(!objControlCaller.bReturnControl) throw new Error(sScript + objControlCaller.sReturnControl);
				
			}catch(err){	
				//#### SIMPLES ERROR HANDLING VOR SCRIPT ERMITTLUNG #######
				print("Fehler gefangen: " + err);
				bReturnControl=false;
				sReturnControl=sScript+"Fehler. "+ err;
				bKernelInitialised=false;
			}
			try{
				if(bKernelInitialised){						
					main:{			
						//print(sScript + "START");								
						//print("###ENDE SNIPPET 02 ###################################################");
						
						
				var objControlCallerInit=new Object();				
				arrReturn=arrayInitZZZ(objKernelLibs,mySize,objControlCallerInit);
				if(!objControlCallerInit.bReturnControl) throw new Error(sScript + objControlCallerInit.sReturnControl);	
					
				bReturnControl=objControlCallerInit.bReturnControl;
				sReturnControl=objControlCallerInit.sReturnControl;
				bReturnControl=true;
			//print("### START SNIPPET 03 ###################################################");
						//print(sScript + "ENDE");								
					} //end main:
				}//end if bKernelInitialised
			}catch(err){	
				//#### ERROR HANDLING #######				
				print(sScript+"Fehler gefangen: " + err);
				//bReturnControl=false;
				//sReturnControl=sScript+"Fehler. " + err;					
				try{																
					//Wende Funktion an, zur Ermittlung der aktuellen Funktion
					var objControlErrh=new Object();//wichtig: Neues ErrorControl Objekt.										
					var myErrorString = handleError(err,objControlErrh);
					if(!objControlErrh.bReturnControl) throw new Error(sScript + objControlErrh.sReturnControl);										
					bReturnControl=false;
					sReturnControl=sScript + myErrorString;				
				}catch(e){
					//#### ERROR HANDLING IM ERRORHANDLING #######
					print(e);					
					bReturnControl=false;
					sReturnControl=sScript + "Fehler im ErrorHandling. "+ e;
				}
			}
			objControl.bReturnControl=bReturnControl;
			objControl.sReturnControl=sReturnControl;
            //### ENDE SNIPPET 03 ###########################################################			
			return arrReturn;
		}			
		]]>
	</scriptdef>
				
	</project>